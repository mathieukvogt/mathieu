<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Programming Syntax Notes"
    />
    <meta
      property="og:title"
      content="Programming Syntax Notes"
    />
    <meta
      name="twitter:title"
      content="Programming Syntax Notes"
    />
    <title>Syntax Notes</title>
    <link href="main.css" rel="stylesheet" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.css"
    />
    <link rel="icon" href="logo.png" type="image/png">
    <base href="https://mathieu.so/" />
    <style>
      p {
        text-align: justify;
      }
    </style>
  </head>

  <body>
    <header>
      <h1>JAVASCRIPT SYNTAX NOTES</h1>
      <p>Content last updated on 25/08/2024 by <em>Mathieu</em></p>
    </header>
    <main>
      <section id="elements">
        <h2>Index</h2>
      </section>
      <hr />
      <div class="alphsort">
        <a href="#variables">Variables</a>
        <a href="#conditionals">Conditionals</a>
        <a href="#ao">Arithmetic Operators</a>
        <a href="#functions">Functions</a>
        <a href="#scope">Scope</a>
        <a href="#arrays">Arrays</a>
        <a href="#array-access">Array Inspection</a>
        <a href="#array-transformation">Array Transformation</a>
        <a href="#array-iteration">Array Iteration</a>
        <a href="#array-mutation">Array Mutation</a>
        <a href="#array-utility">Array Utility</a>
        <a href="#loops">Loops</a>
        <a href="#objects">Objects</a>
        <a href="#comments">Comments</a>
        <a href="#data-types">Data Types</a>
      </div>
      <hr />
      <br />
      <table>
        <tbody>
          <tr>
            <td id="variables" class="tableletters">Variables</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-let', event)">
              let
            </td>
          </tr>
          <tr id="detail-tag-let" class="expandable-row-content">
            <td>
              <h3>let</h3>
              <p>A variable in programming is a storage location identified by a name, which can hold data that may be modified during the execution of a program. Variables are used to store values so that these values can be used and manipulated throughout the program. They can hold different types of data, such as numbers, strings, objects, and more. Variables enable developers to write flexible and dynamic code by providing a way to reference and operate on data without hard-coding values directly into the program.

                <br><br>In JavaScript, the let keyword is used to declare a variable that is block-scoped, which means it is limited to the block, statement, or expression where it is declared. This contrasts with the older var keyword, which declares a variable globally or locally to an entire function regardless of block scope. The let keyword was introduced in ECMAScript 6 (ES6) to provide better control over variable scope and to avoid issues related to variable hoisting that are associated with var.
                
                <br><br>When you declare a variable using let, it is not hoisted to the top of its enclosing block. Instead, it is hoisted to the top of the block but not initialized, which means it cannot be accessed until the execution reaches the line of code where it is declared. This behavior is known as the "temporal dead zone" and helps prevent errors that can occur when variables are used before they are defined.
                
                <br><br>For example, in a block, trying to access a variable declared with let before its declaration line results in a ReferenceError. Once the declaration line is reached, the variable can be accessed and used. The let keyword also prevents the redeclaration of the same variable within the same scope, providing an additional layer of error checking. Attempting to redeclare a variable with let in the same scope results in a SyntaxError, which helps to catch mistakes and enforce cleaner code practices.
                
                <br><br>Overall, the let keyword in JavaScript provides a way to declare variables that are confined to their block scope, reducing the likelihood of errors related to variable hoisting and redeclaration, and promoting better coding practices by encouraging the use of variables only within their intended context.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Redeclaration in the same block
let x = 10;
// let x = 20; // SyntaxError: Identifier 'x' has already been declared
x = 20; // Allowed: updating the value
console.log(x); // 20

// Example 2: Redeclaration in nested blocks
let y = 30;
{
  // let y = 40; // SyntaxError: Identifier 'y' has already been declared
  let z = 50;
  console.log(z); // 50
}
{
  let y = 40; // Allowed: different block scope
  console.log(y); // 40
}
console.log(y); // 30 (original y)

// Example 3: Redeclaration in a function
function redeclareLet() {
  let a = 60;
  // let a = 70; // SyntaxError: Identifier 'a' has already been declared
  a = 70; // Allowed: updating the value
  console.log(a); // 70
}
redeclareLet();

// Example 4: Redeclaration in an if block
let condition = true;
if (condition) {
  let status = 'active';
  // let status = 'inactive'; // SyntaxError: Identifier 'status' has already been declared
  status = 'inactive'; // Allowed: updating the value
  console.log(status); // 'inactive'
}

// Example 5: Block scope
{
  let x = 10;
  console.log(x); // 10
}
console.log(typeof x); // undefined (x is not accessible here)

// Example 6: Temporal Dead Zone
{
  // console.log(y); // ReferenceError: Cannot access 'y' before initialization
  let y = 20;
  console.log(y); // 20
}

// Example 7: let in a loop block
for (let i = 0; i < 3; i++) {
  console.log(i); // 0, 1, 2
}
// console.log(i); // ReferenceError: i is not defined (i is not accessible here)

// Example 8: Nested blocks
{
  let outer = 'outer';
  {
    let inner = 'inner';
    console.log(outer); // outer
    console.log(inner); // inner
  }
  // console.log(inner); // ReferenceError: inner is not defined
}

// Example 9: let in functions
function testLet() {
  let z = 50;
  console.log(z); // 50
}
// console.log(z); // ReferenceError: z is not defined
testLet();

// Example 10: Updating let variables
let score = 10;
score += 5;
console.log(score); // 15
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-const', event)">
              const
            </td>
          </tr>
          <tr id="detail-tag-const" class="expandable-row-content">
            <td>
              <h3>const</h3>
              <p>The `const` keyword in JavaScript is used to declare variables that are intended to be constant, meaning their values are not supposed to change after they are initialized. Similar to the `let` keyword, `const` creates block-scoped variables. This means that the variable declared with `const` is limited to the block, statement, or expression where it is defined, and cannot be accessed outside of that scope. 

                <br><br>When you declare a variable with `const`, it must be initialized with a value at the time of declaration. This is because `const` variables are read-only after they are assigned a value. Trying to declare a `const` variable without initializing it will result in a syntax error. Once assigned, the variable cannot be reassigned a new value, which helps enforce immutability at the variable level.
                
                <br><br>It's important to note that while the `const` keyword prevents reassignment of the variable itself, it does not make the value immutable. For example, if the value assigned to a `const` variable is an object or an array, the contents of that object or array can still be modified. This means you can change the properties of an object or elements of an array, but you cannot reassign the variable to a different object or array. 
                
                <br><br>Using `const` for variables that should remain unchanged helps improve code reliability and readability by signaling the intent that the variable's value should not be altered. It also reduces the risk of unintended side effects caused by variable reassignment. However, because `const` is block-scoped like `let`, it can only be accessed within the block it is declared in, and it cannot be redeclared within that same block. 
                
                <br><br>In summary, the `const` keyword in JavaScript is used to declare variables with a constant value that should not be reassigned. It provides block scope similar to `let` and enforces immutability for the variable binding itself, though not necessarily for the value it holds if that value is an object or array.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Redeclaration in the same block
const a = 10;
// const a = 20; // SyntaxError: Identifier 'a' has already been declared
// a = 20; // TypeError: Assignment to constant variable
console.log(a); // 10

// Example 2: Redeclaration in nested blocks
const b = 30;
{
  // const b = 40; // SyntaxError: Identifier 'b' has already been declared
  const c = 50;
  console.log(c); // 50
}
{
  const b = 40; // Allowed: different block scope
  console.log(b); // 40
}
console.log(b); // 30 (original b)

// Example 3: Redeclaration in functions
function exampleFunction() {
  const d = 60;
  // const d = 70; // SyntaxError: Identifier 'd' has already been declared
  console.log(d); // 60
}
exampleFunction();

// Example 4: Redeclaration in if block
const condition = true;
if (condition) {
  const status = 'active';
  // const status = 'inactive'; // SyntaxError: Identifier 'status' has already been declared
  console.log(status); // 'active'
}

// Example 5: Initializing const without assignment
// const e; // SyntaxError: Missing initializer in const declaration

// Example 6: Modifying properties of a const object
const obj = { key: 'value' };
obj.key = 'newValue'; // Allowed: modifying object properties
console.log(obj.key); // 'newValue'

// Example 7: Modifying array elements of a const array
const arr = [1, 2, 3];
arr[0] = 10; // Allowed: modifying array elements
console.log(arr[0]); // 10

// Example 8: Block scope with const
{
  const f = 70;
  console.log(f); // 70
}
// console.log(f); // ReferenceError: f is not defined

// Example 9: const in loops
for (const g of [1, 2, 3]) {
  console.log(g); // 1, 2, 3
}
// console.log(g); // ReferenceError: g is not defined

// Example 10: const in a switch case
const h = 'A';
switch (h) {
  case 'A':
    const grade = 'Excellent';
    console.log(grade); // 'Excellent'
    break;
  case 'B':
    // const grade = 'Good'; // SyntaxError: Identifier 'grade' has already been declared
    break;
  default:
    const grade = 'Unknown'; // Allowed: different block scope
    console.log(grade); // 'Unknown'
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td id="conditionals" class="tableletters">Conditionals</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-if', event)">
              if statement
            </td>
          </tr>
          <tr id="detail-tag-if" class="expandable-row-content">
            <td>
              <h3>if statement</h3>
              <p>In JavaScript, an if statement is a fundamental control structure used to execute a block of code only if a specified condition is true. The syntax starts with the keyword if, followed by a condition enclosed in parentheses. This condition is an expression that the JavaScript engine evaluates to either true or false. If the condition evaluates to true, the code block enclosed in curly braces {} immediately following the if statement is executed. For instance, consider the example if (temperature > 30) { console.log("It's hot outside!"); }. In this case, if the value of the variable temperature is greater than 30, the message "It's hot outside!" will be logged to the console. However, if the condition evaluates to false, the code block within the curly braces is skipped and not executed. This allows developers to control the flow of their programs by specifying actions that should only occur when certain conditions are met, making the code more dynamic and responsive to different scenarios.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
let age = 18;
if (age >= 18) {
  console.log("You are an adult.");
}

let temperature = 25;
if (temperature < 0) {
  console.log("It is freezing outside.");
}

let score = 85;
if (score >= 80) {
  console.log("You passed the exam.");
}

let isMember = true;
if (isMember) {
  console.log("Welcome, member!");
}

let name = "Alice";
if (name === "Alice") {
  console.log("Hello, Alice!");
}

let balance = 1000;
if (balance >= 500) {
  console.log("You have sufficient funds.");
}

let light = "green";
if (light === "green") {
  console.log("You can go.");
}

let password = "securePassword123";
if (password.length >= 8) {
  console.log("Password is long enough.");
}

let itemsInCart = 3;
if (itemsInCart > 0) {
  console.log("Your cart is not empty.");
}

let hasAccess = false;
if (!hasAccess) {
  console.log("Access denied.");
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-else', event)">
              else statement
            </td>
          </tr>
          <tr id="detail-tag-else" class="expandable-row-content">
            <td>
              <h3>else statement</h3>
              <p>In JavaScript, the `else` statement is used to define a block of code that will be executed if the condition in the preceding `if` statement evaluates to false. It acts as a fallback or default action when the specified condition is not met. When an `if` statement evaluates its condition and finds it to be false, the code inside the `else` block runs instead. This ensures that one of the two blocks of code (either the `if` block or the `else` block) will always execute, making it useful for handling alternative outcomes. For instance, in the code snippet `if (condition) { /* code if condition is true */ } else { /* code if condition is false */ }`, if `condition` evaluates to false, the program will skip the first block and execute the code within the `else` block.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Checking if a number is positive
let number = 5;
if (number > 0) {
    console.log("The number is positive");
} else {
    console.log("The number is not positive");
}

// Example 2: Checking if a user is logged in
let isLoggedIn = false;
if (isLoggedIn) {
    console.log("Welcome, user!");
} else {
    console.log("Please log in");
}

// Example 3: Checking if an array is empty
let array = [];
if (array.length > 0) {
    console.log("The array is not empty");
} else {
    console.log("The array is empty");
}

// Example 4: Checking if a string is not empty
let str = "";
if (str !== "") {
    console.log("The string is not empty");
} else {
    console.log("The string is empty");
}

// Example 5: Checking if a number is even
let num = 7;
if (num % 2 === 0) {
    console.log("The number is even");
} else {
    console.log("The number is odd");
}

// Example 6: Checking if a temperature is above freezing
let temperature = -5;
if (temperature > 0) {
    console.log("The temperature is above freezing");
} else {
    console.log("The temperature is below freezing");
}

// Example 7: Checking if a year is a leap year
let year = 2023;
if ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0) {
    console.log("The year is a leap year");
} else {
    console.log("The year is not a leap year");
}

// Example 8: Checking if a password is valid (simplified)
let password = "pass123";
if (password.length >= 8) {
    console.log("The password is valid");
} else {
    console.log("The password is invalid");
}

// Example 9: Checking if a light is on
let lightOn = true;
if (lightOn) {
    console.log("The light is on");
} else {
    console.log("The light is off");
}

// Example 10: Checking if a value is greater than a threshold
let value = 15;
let threshold = 10;
if (value > threshold) {
    console.log("The value is above the threshold");
} else {
    console.log("The value is below the threshold");
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-elseif', event)">
              else if statement
            </td>
          </tr>
          <tr id="detail-tag-elseif" class="expandable-row-content">
            <td>
              <h3>else if statement</h3>
              <p>In JavaScript, the `else if` statement is used to specify a new condition to test if the previous `if` condition evaluates to false. This allows for multiple conditions to be checked sequentially, enabling more complex decision-making within the code. When an `if` statement's condition is false, the program moves to the `else if` statement to check its condition. If this condition is true, the corresponding block of code executes. If it is also false, the program can continue to additional `else if` statements, if any are present. This chaining of conditions with `else if` statements enables the program to handle various scenarios in a structured manner. If all `if` and `else if` conditions are false, an optional `else` statement can be used as a final fallback. For instance, in the code snippet `if (condition1) { /* code if condition1 is true */ } else if (condition2) { /* code if condition2 is true */ } else { /* code if none of the conditions are true */ }`, the program evaluates each condition in sequence until one is true, executing the corresponding block of code and skipping the rest.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Checking user role
let userRole = "editor";
if (userRole === "admin") {
    console.log("Access level: Full");
} else if (userRole === "editor") {
    console.log("Access level: Edit");
} else if (userRole === "viewer") {
    console.log("Access level: View");
} else {
    console.log("Access level: None");
}

// Example 2: Determining shipping cost
let orderValue = 75;
if (orderValue >= 100) {
    console.log("Shipping cost: Free");
} else if (orderValue >= 50) {
    console.log("Shipping cost: $5");
} else if (orderValue >= 20) {
    console.log("Shipping cost: $10");
} else {
    console.log("Shipping cost: $15");
}

// Example 3: Movie rating classification
let movieRating = "R";
if (movieRating === "G") {
    console.log("Suitable for all ages");
} else if (movieRating === "PG") {
    console.log("Parental guidance suggested");
} else if (movieRating === "PG-13") {
    console.log("Parents strongly cautioned");
} else if (movieRating === "R") {
    console.log("Restricted to 17 and older");
} else {
    console.log("Rating not recognized");
}

// Example 4: Network connection status
let connectionStatus = "connected";
if (connectionStatus === "connected") {
    console.log("Network status: Connected");
} else if (connectionStatus === "connecting") {
    console.log("Network status: Connecting");
} else if (connectionStatus === "disconnected") {
    console.log("Network status: Disconnected");
} else {
    console.log("Network status: Unknown");
}

// Example 5: Battery level indicator
let batteryLevel = 45;
if (batteryLevel > 80) {
    console.log("Battery status: High");
} else if (batteryLevel > 40) {
    console.log("Battery status: Medium");
} else if (batteryLevel > 20) {
    console.log("Battery status: Low");
} else {
    console.log("Battery status: Critical");
}

// Example 6: Air quality index (AQI) categorization
let aqi = 120;
if (aqi <= 50) {
    console.log("Air quality: Good");
} else if (aqi <= 100) {
    console.log("Air quality: Moderate");
} else if (aqi <= 150) {
    console.log("Air quality: Unhealthy for sensitive groups");
} else if (aqi <= 200) {
    console.log("Air quality: Unhealthy");
} else if (aqi <= 300) {
    console.log("Air quality: Very Unhealthy");
} else {
    console.log("Air quality: Hazardous");
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-comparison', event)">
              comparison operators
            </td>
          </tr>
          <tr id="detail-tag-comparison" class="expandable-row-content">
            <td>
              <h3>comparison operators</h3>
              <p>In JavaScript, comparison operators are used in conditionals to compare two values and determine the relationship between them, returning a boolean value (true or false) as the result. The equality operator (`==`) checks if two values are equal, while the strict equality operator (`===`) checks for both value and type equality. The inequality operator (`!=`) checks if two values are not equal, and the strict inequality operator (`!==`) checks for both value and type inequality. The greater than (`>`), greater than or equal to (`>=`), less than (`<`), and less than or equal to (`<=`) operators are used to compare the relative magnitude of two values. These operators are essential in conditional statements like `if`, `else if`, and `while`, allowing the code to execute different blocks based on whether specific conditions are met. For example, `if (a > b) { /* code */ }` will execute the contained code if `a` is greater than `b`. Comparison operators provide the fundamental logic needed for decision-making processes in programming.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Equality and Inequality Operators

// Example 1: Check if two strings are equal
let string1 = "hello";
let string2 = "hello";
if (string1 == string2) {
    console.log("The strings are equal"); // Logs: "The strings are equal"
} else {
    console.log("The strings are not equal");
}

// Example 2: Check if two numbers are not equal
let a = 10;
let b = 20;
if (a != b) {
    console.log("a is not equal to b"); // Logs: "a is not equal to b"
} else {
    console.log("a is equal to b");
}

// Example 3: Check if a value is strictly equal to another
let value1 = 100;
let value2 = "100";
if (value1 === value2) {
    console.log("value1 is strictly equal to value2");
} else {
    console.log("value1 is not strictly equal to value2"); // Logs: "value1 is not strictly equal to value2"
}

// Example 4: Check if a value is not strictly equal to another
let x = 15;
let y = "15";
if (x !== y) {
    console.log("x is not strictly equal to y"); // Logs: "x is not strictly equal to y"
} else {
    console.log("x is strictly equal to y");
}

// Example 5: Check if a string is not equal to another
let str1 = "apple";
let str2 = "orange";
if (str1 != str2) {
    console.log("The strings are not equal"); // Logs: "The strings are not equal"
} else {
    console.log("The strings are equal");
}

// Example 6: Check if a boolean value is true
let isTrue = true;
if (isTrue === true) {
    console.log("The value is true"); // Logs: "The value is true"
} else {
    console.log("The value is false");
}

// Example 7: Check if a boolean value is false
let isFalse = false;
if (isFalse === false) {
    console.log("The value is false"); // Logs: "The value is false"
} else {
    console.log("The value is true");
}

// Example 8: Check if a number is equal to a specific value
let num = 42;
if (num === 42) {
    console.log("The number is 42"); // Logs: "The number is 42"
} else {
    console.log("The number is not 42");
}

// Greater Than and Less Than Operators

// Example 9: Check if a number is greater than another number
let num1 = 5;
let num2 = 3;
if (num1 > num2) {
    console.log("num1 is greater than num2"); // Logs: "num1 is greater than num2"
} else {
    console.log("num1 is not greater than num2");
}

// Example 10: Check if a number is less than another number
let num3 = 5;
let num4 = 10;
if (num3 < num4) {
    console.log("num3 is less than num4"); // Logs: "num3 is less than num4"
} else {
    console.log("num3 is not less than num4");
}

// Example 11: Check if a number is greater than or equal to another number
let num5 = 10;
let num6 = 10;
if (num5 >= num6) {
    console.log("num5 is greater than or equal to num6"); // Logs: "num5 is greater than or equal to num6"
} else {
    console.log("num5 is less than num6");
}

// Example 12: Check if a number is less than or equal to another number
let num7 = 5;
let num8 = 8;
if (num7 <= num8) {
    console.log("num7 is less than or equal to num8"); // Logs: "num7 is less than or equal to num8"
} else {
    console.log("num7 is greater than num8");
}

// Example 13: Check if a value is greater than zero
let value = -1;
if (value > 0) {
    console.log("The value is greater than zero");
} else {
    console.log("The value is not greater than zero"); // Logs: "The value is not greater than zero"
}

// Example 14: Check if a value is less than zero
let value3 = -5;
if (value3 < 0) {
    console.log("The value is less than zero"); // Logs: "The value is less than zero"
} else {
    console.log("The value is not less than zero");
}

// Example 15: Check if a temperature is above freezing
let temperature = -5;
if (temperature > 0) {
    console.log("The temperature is above freezing");
} else {
    console.log("The temperature is below freezing"); // Logs: "The temperature is below freezing"
}

// Example 16: Check if a year is in the future
let currentYear = 2024;
let futureYear = 2030;
if (futureYear > currentYear) {
    console.log("The year is in the future"); // Logs: "The year is in the future"
} else {
    console.log("The year is not in the future");
}

// Example 17: Check if a person's age is over 18
let personAge = 20;
if (personAge > 18) {
    console.log("The person is over 18"); // Logs: "The person is over 18"
} else {
    console.log("The person is not over 18");
}

// Example 18: Check if a price is within a budget
let price = 50;
let budget = 100;
if (price <= budget) {
    console.log("The price is within the budget"); // Logs: "The price is within the budget"
} else {
    console.log("The price is not within the budget");
}

// Example 19: Check if a value is less than a threshold
let threshold = 10;
let testValue = 8;
if (testValue < threshold) {
    console.log("The value is less than the threshold"); // Logs: "The value is less than the threshold"
} else {
    console.log("The value is not less than the threshold");
}

// Example 20: Check if a password length is sufficient
let password = "12345";
if (password.length >= 8) {
    console.log("The password length is sufficient");
} else {
    console.log("The password length is insufficient"); // Logs: "The password length is insufficient"
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-logical', event)">
              logical operators
            </td>
          </tr>
          <tr id="detail-tag-logical" class="expandable-row-content">
            <td>
              <h3>logical operators</h3>
              <p>In JavaScript, logical operators are used in conditionals to combine or invert Boolean values, allowing for more complex decision-making. The three main logical operators are `&&` (logical AND), `||` (logical OR), and `!` (logical NOT). The `&&` operator evaluates to true only if both operands are true, making it useful for checking multiple conditions that must all be satisfied. The `||` operator evaluates to true if at least one of the operands is true, allowing for flexibility when only one of several conditions needs to be met. The `!` operator inverts the truthiness of its operand, turning true to false and vice versa, which is helpful for checking the opposite condition. These operators enable more nuanced control flow in programs, such as executing a block of code only if multiple criteria are met, or if at least one of several conditions is true, or even when a specific condition is not true.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Logical AND Operator

// Example 1: Check if both conditions are true
let temperature = 25;
let humidity = 50;
if (temperature > 20 && humidity < 60) {
    console.log("The weather is pleasant"); // Logs: "The weather is pleasant"
} else {
    console.log("The weather is not pleasant");
}

// Example 2: Check if a person is eligible for a senior discount
let personAge = 65;
let isMember = true;
if (personAge >= 65 && isMember) {
    console.log("Eligible for senior discount"); // Logs: "Eligible for senior discount"
} else {
    console.log("Not eligible for senior discount");
}

// Example 3: Check if a number is within a range
let age = 25;
if (age >= 18 && age <= 30) {
    console.log("The age is within the range"); // Logs: "The age is within the range"
} else {
    console.log("The age is outside the range");
}

// Example 4: Check if a string has a specific length and starts with a specific letter
let name = "Alice";
if (name.length > 3 && name.charAt(0) === "A") {
    console.log("The name is valid"); // Logs: "The name is valid"
} else {
    console.log("The name is not valid");
}

// Logical OR Operator

// Example 5: Check if a number is outside a range
let score = 45;
if (score < 50 || score > 90) {
    console.log("The score is outside the range"); // Logs: "The score is outside the range"
} else {
    console.log("The score is within the range");
}

// Example 6: Check if a user is an admin or a moderator
let role = "admin";
if (role === "admin" || role === "moderator") {
    console.log("User has elevated privileges"); // Logs: "User has elevated privileges"
} else {
    console.log("User does not have elevated privileges");
}

// Example 7: Check if it's a weekend or a holiday
let day = "Saturday";
let isHoliday = false;
if (day === "Saturday" || day === "Sunday" || isHoliday) {
    console.log("It's a day off"); // Logs: "It's a day off"
} else {
    console.log("It's a working day");
}

// Example 8: Check if an item is available in stock or on backorder
let inStock = false;
let onBackorder = true;
if (inStock || onBackorder) {
    console.log("The item can be ordered"); // Logs: "The item can be ordered"
} else {
    console.log("The item is not available");
}

// Logical NOT Operator

// Example 9: Check if a user is not logged in
let isLoggedIn = false;
if (!isLoggedIn) {
    console.log("User is not logged in"); // Logs: "User is not logged in"
} else {
    console.log("User is logged in");
}

// Example 10: Check if a value is not null or undefined
let data = null;
if (data !== null && data !== undefined) {
    console.log("Data is available");
} else {
    console.log("Data is not available"); // Logs: "Data is not available"
}

// Example 11: Check if an array is not empty
let array = [1, 2, 3];
if (array.length !== 0) {
    console.log("The array is not empty"); // Logs: "The array is not empty"
} else {
    console.log("The array is empty");
}

// Example 12: Check if a form field is not blank
let formField = "username";
if (formField !== "") {
    console.log("The form field is filled out"); // Logs: "The form field is filled out"
} else {
    console.log("The form field is blank");
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-ternary', event)">
              ternary operator
            </td>
          </tr>
          <tr id="detail-tag-ternary" class="expandable-row-content">
            <td>
              <h3>ternary operator</h3>
              <p>In JavaScript, the ternary operator is a concise way to perform conditional evaluations. It is the only operator that takes three operands: a condition, an expression to execute if the condition is true, and an expression to execute if the condition is false. The syntax is `condition ? expressionIfTrue : expressionIfFalse`. This operator is particularly useful for assigning values based on a condition or for inline conditional expressions, making the code more succinct. For example, `let result = (age >= 18) ? "Adult" : "Minor";` assigns the string "Adult" to the variable `result` if the `age` is 18 or older, otherwise it assigns "Minor". The ternary operator improves readability for simple conditional assignments, but for more complex logic, traditional `if...else` statements are often more appropriate.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Check if a number is positive, negative, or zero
let number = 5;
let numberCheck = (number > 0) ? "Positive" : (number < 0) ? "Negative" : "Zero";
console.log(numberCheck); // Logs: "Positive"

// Example 2: Determine if a user is an adult or a minor based on age
let age = 17;
let ageGroup = (age >= 18) ? "Adult" : "Minor";
console.log(ageGroup); // Logs: "Minor"

// Example 3: Check if a string is empty or not
let str = "";
let stringCheck = (str !== "") ? "Not empty" : "Empty";
console.log(stringCheck); // Logs: "Empty"

// Example 4: Assign a discount based on membership status
let isMember = true;
let discount = (isMember) ? "10% discount" : "No discount";
console.log(discount); // Logs: "10% discount"

// Example 5: Determine the maximum of two numbers
let a = 10;
let b = 20;
let max = (a > b) ? a : b;
console.log(max); // Logs: 20
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-switch', event)">
              switch statement
            </td>
          </tr>
          <tr id="detail-tag-switch" class="expandable-row-content">
            <td>
              <h3>switch statement</h3>
              <p>In JavaScript, the switch statement is used to perform different actions based on different conditions, serving as an alternative to multiple `if...else if` statements. It evaluates an expression and matches its value against a series of case labels, executing the corresponding block of code when a match is found. The switch statement starts with the keyword `switch`, followed by the expression in parentheses and a block of cases enclosed in curly braces. Each case block starts with the keyword `case`, followed by a value and a colon, and contains the code to execute if the expression matches that value. The `break` statement is typically used at the end of each case to exit the switch block, preventing the execution from falling through to the subsequent cases. If none of the cases match, an optional `default` case can be defined to execute a block of code as a fallback. This structure allows for cleaner and more readable code when handling multiple possible values for a single variable, compared to using numerous `if...else if` statements.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Determine the day of the week
let day = 3;
let dayName;
switch (day) {
    case 0:
        dayName = "Sunday";
        break;
    case 1:
        dayName = "Monday";
        break;
    case 2:
        dayName = "Tuesday";
        break;
    case 3:
        dayName = "Wednesday";
        break;
    case 4:
        dayName = "Thursday";
        break;
    case 5:
        dayName = "Friday";
        break;
    case 6:
        dayName = "Saturday";
        break;
    default:
        dayName = "Invalid day";
}
console.log(dayName); // Logs: "Wednesday"

// Example 2: Evaluate a grade and provide feedback
let grade = 'B';
let feedback;
switch (grade) {
    case 'A':
        feedback = "Excellent";
        break;
    case 'B':
        feedback = "Good";
        break;
    case 'C':
        feedback = "Fair";
        break;
    case 'D':
        feedback = "Poor";
        break;
    case 'F':
        feedback = "Fail";
        break;
    default:
        feedback = "Invalid grade";
}
console.log(feedback); // Logs: "Good"

// Example 3: Determine the browser type based on user agent
let browser = 'Chrome';
let browserType;
switch (browser) {
    case 'Edge':
        browserType = "Microsoft Edge";
        break;
    case 'Chrome':
        browserType = "Google Chrome";
        break;
    case 'Firefox':
        browserType = "Mozilla Firefox";
        break;
    case 'Safari':
        browserType = "Apple Safari";
        break;
    default:
        browserType = "Unknown browser";
}
console.log(browserType); // Logs: "Google Chrome"

// Example 4: Identify the traffic light color action
let trafficLight = 'Yellow';
let action;
switch (trafficLight) {
    case 'Red':
        action = "Stop";
        break;
    case 'Yellow':
        action = "Caution";
        break;
    case 'Green':
        action = "Go";
        break;
    default:
        action = "Invalid color";
}
console.log(action); // Logs: "Caution"

// Example 5: Determine the season based on the month
let month = 8;
let season;
switch (month) {
    case 12:
    case 1:
    case 2:
        season = "Winter";
        break;
    case 3:
    case 4:
    case 5:
        season = "Spring";
        break;
    case 6:
    case 7:
    case 8:
        season = "Summer";
        break;
    case 9:
    case 10:
    case 11:
        season = "Fall";
        break;
    default:
        season = "Invalid month";
}
console.log(season); // Logs: "Summer"
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-truthy', event)">
              truthy and falsy values
            </td>
          </tr>
          <tr id="detail-tag-truthy" class="expandable-row-content">
            <td>
              <h3>truthy and falsy values</h3>
              <p>In JavaScript, truthy and falsy values determine how expressions are evaluated in conditional statements. A value is considered truthy if it evaluates to true in a boolean context, and falsy if it evaluates to false. JavaScript treats the following values as falsy: `false`, `0`, `-0`, `0n` (BigInt zero), `""` (empty string), `null`, `undefined`, and `NaN` (Not-a-Number). All other values, including non-empty strings, non-zero numbers, objects, arrays, and functions, are considered truthy. Understanding truthy and falsy values is essential for writing concise and effective conditionals, as it allows developers to leverage implicit type coercion. For example, the expression `if (value)` will execute the block of code if `value` is truthy, and skip it if `value` is falsy. This implicit evaluation can simplify checks for empty strings, null values, or zeroes, making the code more readable and succinct.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Check if a variable is truthy
let value1 = "hello";
if (value1) {
    console.log("The value is truthy"); // Logs: "The value is truthy"
} else {
    console.log("The value is falsy");
}

// Example 2: Check if a variable is falsy
let value2 = 0;
if (value2) {
    console.log("The value is truthy");
} else {
    console.log("The value is falsy"); // Logs: "The value is falsy"
}

// Example 3: Check if a variable is undefined
let value3;
if (value3) {
    console.log("The value is truthy");
} else {
    console.log("The value is falsy"); // Logs: "The value is falsy"
}

// Example 4: Check if an empty string is falsy
let value4 = "";
if (value4) {
    console.log("The value is truthy");
} else {
    console.log("The value is falsy"); // Logs: "The value is falsy"
}

// Example 5: Check if a non-zero number is truthy
let value5 = 42;
if (value5) {
    console.log("The value is truthy"); // Logs: "The value is truthy"
} else {
    console.log("The value is falsy");
}

// Example 6: Check if null is falsy
let value6 = null;
if (value6) {
    console.log("The value is truthy");
} else {
    console.log("The value is falsy"); // Logs: "The value is falsy"
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-bp', event)">
              best practices
            </td>
          </tr>
          <tr id="detail-tag-bp" class="expandable-row-content">
            <td>
              <h3>best practices</h3>
              <p>Best practices for conditionals in JavaScript focus on writing clear, readable, and efficient code. First, always use strict equality (`===`) and strict inequality (`!==`) to avoid unexpected type coercion, ensuring that both the value and type are compared. Second, keep conditionals simple and avoid deeply nested structures; if a function becomes too complex, consider breaking it into smaller, more manageable pieces. Third, leverage short-circuit evaluation to provide default values or to avoid unnecessary computations. For example, use `||` to set default values and `&&` to execute code only if certain conditions are met. Fourth, use descriptive variable names and comments to make the purpose of the condition clear. Additionally, handle edge cases explicitly and use the `default` case in `switch` statements to cover unexpected values. Finally, when multiple conditions need to be checked, consider using `switch` statements for better readability over multiple `if...else if` statements. Following these practices will result in more maintainable and less error-prone code.</p>
              <br />
            </td>
          </tr>
          <td id="ao" class="tableletters">Arithmetic Operators</td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-add', event)"
            >
            addition (+)
            </td>
          </tr>
          <tr id="detail-tag-add" class="expandable-row-content">
            <td>
              <h3>addition (+)</h3>
              <p>In JavaScript, the + operator is used for two primary purposes: numeric addition and string concatenation. When used with numbers, + performs arithmetic addition to calculate their sum. For example, 5 + 3 results in 8 and 10 + 15 results in 25, while 7 + -2 adds a negative number to get 5. When used with strings, the + operator concatenates them into a single string. For instance, "Hello, " + "world!" produces "Hello, world!", and concatenating "Alice" and "Johnson" with a space results in "Alice Johnson". If you add a number to a string, the number is converted to a string and concatenated. For example, 10 + " apples" yields "10 apples", and "The result is " + (2 + 3) first evaluates the addition inside the parentheses to get 5, then concatenates it with the string to produce "The result is 5". A special case of addition is adding null to a number, where null is treated as 0, so 5 + null results in 5. Similarly, adding undefined to a string results in "undefined" as a string, so "Value is " + undefined produces "Value is undefined".</p>

              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Numeric Addition
let sum1 = 5 + 3;       // 8
let sum2 = 10 + 15;     // 25
let sum3 = 7 + -2;      // 5 (adding a negative number)

// String Concatenation
let greeting = "Hello, " + "world!";  // "Hello, world!"
let firstName = "Alice";
let lastName = "Johnson";
let fullName = firstName + " " + lastName;  // "Alice Johnson"

// Number and String Concatenation
let number = 10;
let text = "The number is " + number;  // "The number is 10"

// Adding a String and a Number (Implicit Conversion)
let addition = 5 + " apples";  // "5 apples" (number converted to string)
let result = "The result is " + (2 + 3);  // "The result is 5"

// Adding null to a number
let resultNull = 5 + null;  // 5 (null is converted to 0)

// Adding undefined to a string
let resultUndefined = "Value is " + undefined;  // "Value is undefined"

</code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-sub', event)"
            >
            subtraction (-)
            </td>
          </tr>
          <tr id="detail-tag-sub" class="expandable-row-content">
            <td>
              <h3>subtraction (-)</h3>
              <p>In JavaScript, the - operator is used primarily for numeric subtraction. It subtracts the right operand from the left operand to yield a numerical result. If used with two numbers, such as 8 - 3, it calculates the difference, which is 5. Subtraction can also be applied to negative numbers, for instance, 10 - (-4) results in 14 as it effectively adds the absolute value of the negative number. When - is used with non-numeric types, JavaScript first tries to convert the operands to numbers. If one operand is a string and the other is a number, JavaScript attempts to convert the string to a number; for example, "10" - 5 results in 5 because "10" is converted to the number 10. If the string cannot be converted to a number, such as in "hello" - 5, the result is NaN (Not-a-Number). Additionally, subtracting null from a number results in the number itself, as null is converted to 0; for instance, 15 - null equals 15. However, subtracting undefined from a number results in NaN, as undefined cannot be converted to a number, so 10 - undefined yields NaN.</p>

              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Numeric Subtraction
let difference1 = 8 - 3;         // 5
let difference2 = 10 - 4;        // 6
let difference3 = 10 - (-4);     // 14 (subtracting a negative number)

// Subtracting a String from a Number (Implicit Conversion)
let result1 = "10" - 5;         // 5 (string "10" is converted to number 10)
let result2 = "20" - "5";       // 15 (both strings are converted to numbers)

// Subtracting Non-Numeric Strings
let result3 = "hello" - 5;      // NaN (non-numeric string cannot be converted to a number)

// Subtracting null from a Number
let result4 = 15 - null;       // 15 (null is converted to 0)

// Subtracting undefined from a Number
let result5 = 10 - undefined;  // NaN (undefined cannot be converted to a number)

</code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-multi', event)"
            >
            multiplication (*)
            </td>
          </tr>
          <tr id="detail-tag-multi" class="expandable-row-content">
            <td>
              <h3>multiplication (*)</h3>
              <p>In JavaScript, the * operator is used for numeric multiplication. It multiplies the two operands and returns the product. For example, using 5 * 3 results in 15, as it multiplies 5 by 3. The * operator also supports multiplication with floating-point numbers, where 2.5 * 4 results in 10.0. JavaScript handles cases where one or both operands are non-numeric values by attempting to convert them into numbers before performing the multiplication. If one operand is a string that represents a number, like "7", multiplying it by a number results in 7, as the string "7" is converted to the number 7. However, if the string cannot be converted to a number, such as "hello" * 3, the result is NaN (Not-a-Number). Additionally, multiplying null by a number treats null as 0, so null * 4 yields 0. When undefined is involved in multiplication with a number, the result is also NaN, as undefined cannot be converted to a number, so 5 * undefined results in NaN.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Numeric Multiplication
let product1 = 5 * 3;         // 15
let product2 = 2.5 * 4;       // 10.0
let product3 = -7 * 6;        // -42 (multiplying a negative number)

// Multiplying a String that Represents a Number
let result1 = "7" * 2;        // 14 (string "7" is converted to number 7)
let result2 = "5.5" * 2;      // 11.0 (string "5.5" is converted to number 5.5)
let result3 = "10" * 3;       // 30 (string "10" is converted to number 10)

// Multiplying Non-Numeric Strings
let result4 = "hello" * 3;    // NaN (non-numeric string cannot be converted to a number)

// Multiplying null by a Number
let result5 = null * 4;      // 0 (null is converted to 0)

// Multiplying undefined by a Number
let result6 = 5 * undefined; // NaN (undefined cannot be converted to a number)

</code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-div', event)"
            >
            division (/)
            </td>
          </tr>
          <tr id="detail-tag-div" class="expandable-row-content">
            <td>
              <h3>division (/)</h3>
              <p>In JavaScript, the / operator is used for numeric division. It divides the left operand by the right operand and returns the quotient. For example, 10 / 2 results in 5, as it divides 10 by 2. The / operator supports division with both integers and floating-point numbers, such as 7.5 / 2 which results in 3.75. When one or both of the operands are non-numeric types, JavaScript attempts to convert them to numbers before performing the division. For instance, if one operand is a string that represents a number, like "8", dividing it by a number yields 4, since the string "8" is converted to the number 8. However, if the string cannot be converted to a number, such as "hello" / 2, the result is NaN (Not-a-Number). Additionally, dividing a number by null treats null as 0, so dividing by null results in Infinity or -Infinity depending on the sign of the dividend. For example, 10 / null yields Infinity, while -10 / null results in -Infinity. When undefined is used in division with a number, the result is NaN, as undefined cannot be converted to a number, so 5 / undefined results in NaN.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Numeric Division
let quotient1 = 10 / 2;         // 5
let quotient2 = 7.5 / 2;       // 3.75
let quotient3 = -10 / 2;       // -5 (dividing a negative number)

// Dividing a String that Represents a Number
let result1 = "8" / 2;        // 4 (string "8" is converted to number 8)
let result2 = "5.5" / 2;      // 2.75 (string "5.5" is converted to number 5.5)
let result3 = "12" / 4;       // 3 (string "12" is converted to number 12)

// Dividing Non-Numeric Strings
let result4 = "hello" / 2;    // NaN (non-numeric string cannot be converted to a number)

// Dividing by null
let result5 = 10 / null;     // Infinity (null is converted to 0)
let result6 = -10 / null;    // -Infinity (null is converted to 0)

// Dividing by undefined
let result7 = 5 / undefined; // NaN (undefined cannot be converted to a number)

// Special Cases
let zeroDiv = 5 / 0;      // Infinity (dividing by zero yields Infinity)
let negativeZeroDiv = -5 / 0;  // -Infinity (dividing by zero yields -Infinity)

</code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-rem', event)"
            >
            remainder (%)
            </td>
          </tr>
          <tr id="detail-tag-rem" class="expandable-row-content">
            <td>
              <h3>remainder (%)</h3>
              <p>In JavaScript, the % operator is used to calculate the remainder of the division between two numbers. It performs a division operation and returns the remainder after the division. For example, 10 % 3 results in 1, as 10 divided by 3 is 3 with a remainder of 1. The % operator works with both positive and negative numbers, where -10 % 3 results in -1, as it computes the remainder considering the sign of the dividend. When used with non-numeric values, JavaScript attempts to convert the operands to numbers before calculating the remainder. For instance, if one operand is a string that represents a number, like "9", the operation "9" % 4 yields 1, as "9" is converted to 9 and then the remainder of 9 divided by 4 is 1. If the string cannot be converted to a number, such as "hello" % 2, the result is NaN (Not-a-Number). Additionally, when null is used as an operand, null is treated as 0, so 10 % null yields NaN because division by 0 is undefined. When undefined is involved, the result of the operation is also NaN, as undefined cannot be converted to a number, so 5 % undefined results in NaN.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Numeric Remainder
let remainder1 = 10 % 3;        // 1 (10 divided by 3 has a remainder of 1)
let remainder2 = 20 % 4;        // 0 (20 divided by 4 has no remainder)
let remainder3 = -10 % 3;       // -1 (negative dividend with positive divisor)

// Remainder with a String that Represents a Number
let result1 = "9" % 4;         // 1 (string "9" is converted to number 9)
let result2 = "15" % 6;        // 3 (string "15" is converted to number 15)
let result3 = "8" % 2;         // 0 (string "8" is converted to number 8)

// Remainder with Non-Numeric Strings
let result4 = "hello" % 2;     // NaN (non-numeric string cannot be converted to a number)

// Remainder with null
let result5 = 10 % null;      // NaN (null is converted to 0, division by 0 is undefined)

// Remainder with undefined
let result6 = 5 % undefined;  // NaN (undefined cannot be converted to a number)

// Special Cases
let zeroDiv = 0 % 5;          // 0 (0 divided by any number has a remainder of 0)
let negZeroDiv = -5 % 2;      // -1 (negative dividend with positive divisor)

</code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-expo', event)"
            >
            exponentiation (**)
            </td>
          </tr>
          <tr id="detail-tag-expo" class="expandable-row-content">
            <td>
              <h3>exponentiation (**)</h3>
              <p>In JavaScript, the / operator is used for numeric division. It divides the left operand by the right operand and returns the quotient. For example, 10 / 2 results in 5, as it divides 10 by 2. The / operator supports division with both integers and floating-point numbers, such as 7.5 / 2 which results in 3.75. When one or both of the operands are non-numeric types, JavaScript attempts to convert them to numbers before performing the division. For instance, if one operand is a string that represents a number, like "8", dividing it by a number yields 4, since the string "8" is converted to the number 8. However, if the string cannot be converted to a number, such as "hello" / 2, the result is NaN (Not-a-Number). Additionally, dividing a number by null treats null as 0, so dividing by null results in Infinity or -Infinity depending on the sign of the dividend. For example, 10 / null yields Infinity, while -10 / null results in -Infinity. When undefined is used in division with a number, the result is NaN, as undefined cannot be converted to a number, so 5 / undefined results in NaN.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Numeric Exponentiation
let power1 = 2 ** 3;          // 8 (2 raised to the power of 3 is 8)
let power2 = 4 ** -2;         // 0.0625 (4 raised to the power of -2 is 1/16)
let power3 = 2.5 ** 2;       // 6.25 (2.5 raised to the power of 2 is 6.25)

// Exponentiation with a String that Represents a Number
let result1 = "3" ** 2;      // 9 (string "3" is converted to number 3)
let result2 = "5.5" ** 2;    // 30.25 (string "5.5" is converted to number 5.5)
let result3 = "7" ** 0;      // 1 (any number to the power of 0 is 1)

// Exponentiation with Non-Numeric Strings
let result4 = "hello" ** 2; // NaN (non-numeric string cannot be converted to a number)

// Exponentiation with null
let result5 = null ** 2;    // 0 (null is treated as 0 for exponentiation)

// Exponentiation with undefined
let result6 = 5 ** undefined; // NaN (undefined cannot be converted to a number)

// Special Cases
let zeroBase = 0 ** 3;          // 0 (0 raised to any power other than 0 yields 0)
let negativeExponent = 2 ** -3; // 0.125 (2 raised to the power of -3 is 1/8)

</code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-inc', event)"
            >
            increment (++)
            </td>
          </tr>
          <tr id="detail-tag-inc" class="expandable-row-content">
            <td>
              <h3>increment (++)</h3>
              <p>In JavaScript, the ++ operator is used to increment a number by one. This operator can be applied in two ways: as a prefix (before the operand) or as a postfix (after the operand). When used as a prefix, such as ++x, the value of x is incremented before it is used in an expression. Conversely, when used as a postfix, such as x++, the value of x is incremented after its current value has been used in the expression. The ++ operator only affects numbers; when applied to non-numeric values, JavaScript attempts to convert them to numbers. For example, "5"++ converts "5" to 5 and increments it to 6. If the string cannot be converted to a number, such as "hello"++, it results in NaN (Not-a-Number). Applying the ++ operator to null treats null as 0, so null++ increments null to 1. However, applying the ++ operator to undefined results in NaN because undefined cannot be converted to a number, so undefined++ yields NaN.</p>

              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Prefix Increment
let x = 5;
let y = ++x;       // 6 (x is incremented to 6 before assigning to y)

// Postfix Increment
let a = 3;
let b = a++;       // 3 (a is assigned to b first, then a is incremented to 4)

// Increment with a String that Represents a Number
let result1 = "7"++;  // Results in an error (Postfix ++ does not work with strings)

// Increment with Non-Numeric Strings
let result2 = "hello"++; // NaN (non-numeric string cannot be incremented)

// Increment with null
let result3 = null++;  // 1 (null is treated as 0, then incremented to 1)

// Increment with undefined
let result4 = undefined++; // NaN (undefined cannot be incremented)

// Special Cases
let object = { count: 1 };
object.count++;       // 2 (increments the `count` property of the object)

// Prefix and Postfix Increment with Arrays
let array = [1, 2, 3];
++array[0];           // 2 (prefix increment on the first element of the array)
array[1]++;           // 3 (postfix increment on the second element of the array)

</code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-dec', event)"
            >
            decrement (--)
            </td>
          </tr>
          <tr id="detail-tag-dec" class="expandable-row-content">
            <td>
              <h3>decrement (--)</h3>
              <p>In JavaScript, the -- operator is used to decrement a number by one. This operator can be utilized in two distinct ways: as a prefix (before the operand) or as a postfix (after the operand). When used as a prefix, such as --x, the value of x is decremented before it is used in any expression. Conversely, when used as a postfix, such as x--, the value of x is decremented after its current value has been used. The -- operator operates exclusively on numbers; if applied to non-numeric values, JavaScript attempts to convert the operands to numbers before performing the decrement operation. For example, "5"-- converts the string "5" to 5 and decrements it to 4. If the string cannot be converted to a number, such as "hello"--, it results in NaN (Not-a-Number). When null is decremented, null is treated as 0, so null-- decrements null to -1. However, decrementing undefined results in NaN because undefined cannot be converted to a number, so undefined-- yields NaN.</p>

              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Prefix Decrement
let x = 5;
let y = --x;       // 4 (x is decremented to 4 before assigning to y)

// Postfix Decrement
let a = 3;
let b = a--;       // 3 (a is assigned to b first, then a is decremented to 2)

// Decrement with a String that Represents a Number
let result1 = "7"--;  // 6 (string "7" is converted to number 7 and decremented to 6)
let result2 = "3"--;  // 2 (string "3" is converted to number 3 and decremented to 2)

// Decrement with Non-Numeric Strings
let result3 = "hello"--; // NaN (non-numeric string cannot be decremented)

// Decrement with null
let result4 = null--;  // -1 (null is treated as 0, then decremented to -1)

// Decrement with undefined
let result5 = undefined--; // NaN (undefined cannot be decremented)

// Special Cases
let object = { count: 5 };
object.count--;       // 5 (decrements the `count` property of the object to 4)

// Prefix and Postfix Decrement with Arrays
let array = [3, 4, 5];
--array[0];           // 2 (prefix decrement on the first element of the array)
array[1]--;           // 3 (postfix decrement on the second element of the array)

</code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td id="functions" class="tableletters">Functions</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-overview', event)">
              overview
            </td>
          </tr>
          <tr id="detail-tag-overview" class="expandable-row-content">
            <td>
              <h3>overview</h3>
              <p>JavaScript functions are essential components of the language, providing a way to encapsulate code into reusable and maintainable blocks. Defined using the `function` keyword, followed by a function name, a set of parentheses, and a code block enclosed in curly braces, functions can take parameters and perform operations based on the provided arguments. They are invoked by calling the function name with parentheses, optionally passing arguments. Functions can return values using the `return` statement, allowing them to output results that can be used in other parts of the program. JavaScript also supports anonymous functions, which are functions without names, often utilized in event handling or as immediately invoked function expressions (IIFE). With the introduction of ES6, arrow functions offer a more concise syntax and lexically bind the `this` keyword, making them particularly useful for callbacks and functional programming techniques. Functions in JavaScript can be assigned to variables, passed as arguments to other functions, and even returned from other functions, enabling the creation of higher-order functions. They can also be nested, meaning a function can be defined within another function, providing a way to create private scopes. This encapsulation helps in avoiding global namespace pollution. Functions enhance code readability and organization by breaking down complex operations into smaller, manageable tasks. They support recursion, allowing a function to call itself, which is useful for tasks like traversing data structures or solving problems with repetitive patterns. Additionally, JavaScript functions can be defined using function expressions or function declarations, each with its scope and hoisting behaviors. Functions are fundamental in implementing modular, maintainable code structures, promoting reuse and reducing redundancy. Asynchronous operations, such as those involving callbacks, promises, and async/await syntax, rely heavily on functions. They are also the foundation for many JavaScript design patterns and libraries, making a deep understanding of functions crucial for effective JavaScript programming. Overall, JavaScript functions are versatile and powerful, enabling developers to write efficient, readable, and maintainable code.</p>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-fd', event)">
              function declaration
            </td>
          </tr>
          <tr id="detail-tag-fd" class="expandable-row-content">
            <td>
              <h3>function declaration</h3>
              <p>In JavaScript, function declarations are one of the primary ways to define functions, offering a straightforward syntax and certain benefits, such as hoisting. A function declaration consists of the `function` keyword followed by a name, a set of parentheses for parameters, and a block of code enclosed in curly braces. For example, `function greet() { console.log("Hello, world!"); }` defines a function named `greet` that logs a message to the console. One significant feature of function declarations is hoisting, which allows the function to be called before its definition in the code. This means that the JavaScript engine processes the function declarations at the compile phase, making them available throughout their scope. Function declarations are typically used when the function needs to be reused multiple times, enhancing code readability and maintainability. They create a function object and bind it to the function's name within the current scope, enabling easy invocation. Function declarations are integral to structuring code in a modular and organized manner, facilitating the breakdown of complex operations into manageable and reusable pieces.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Function to greet a user
function greet() {
    console.log("Hello, world!");
}
greet(); // Logs: "Hello, world!"

// Example 2: Function to add two numbers
function add(a, b) {
    return a + b;
}
console.log(add(5, 3)); // Logs: 8

// Example 3: Function to check if a number is even
function isEven(number) {
    return number % 2 === 0;
}
console.log(isEven(4)); // Logs: true

// Example 4: Function to calculate the square of a number
function square(x) {
    return x * x;
}
console.log(square(5)); // Logs: 25

// Example 5: Function to find the maximum of two numbers
function max(a, b) {
    return a > b ? a : b;
}
console.log(max(10, 15)); // Logs: 15

// Example 6: Function to print a message multiple times
function repeatMessage(message, times) {
    for (let i = 0; i < times; i++) {
        console.log(message);
    }
}
repeatMessage("Hello!", 3); // Logs: "Hello!" three times

// Example 7: Function to convert Celsius to Fahrenheit
function toFahrenheit(celsius) {
    return celsius * 9 / 5 + 32;
}
console.log(toFahrenheit(0)); // Logs: 32

// Example 8: Function to find the factorial of a number
function factorial(n) {
    if (n === 0) {
        return 1;
    }
    return n * factorial(n - 1);
}
console.log(factorial(5)); // Logs: 120

// Example 9: Function to reverse a string
function reverseString(str) {
    return str.split('').reverse().join('');
}
console.log(reverseString("hello")); // Logs: "olleh"

// Example 10: Function to check if a string is a palindrome
function isPalindrome(str) {
    let reversed = str.split('').reverse().join('');
    return str === reversed;
}
console.log(isPalindrome("racecar")); // Logs: true

            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-call', event)">
              calling a function
            </td>
          </tr>
          <tr id="detail-tag-call" class="expandable-row-content">
            <td>
              <h3>calling a function</h3>
              <p>Calling a function in JavaScript involves executing the code within the function's block by invoking the function's name followed by parentheses, optionally including arguments inside the parentheses if the function requires parameters. When a function is called, the JavaScript engine creates a new execution context for it, assigns the provided arguments to the corresponding parameters, and runs the function's code. If the function has a return statement, the value specified by that statement is returned to the caller; otherwise, the function returns `undefined` by default. Function calls can be made from anywhere in the code, including from within other functions, allowing for modular and reusable code. Calling a function is essential for utilizing its defined behavior and achieving the desired operations within a program. Properly invoking functions enables developers to build complex applications by breaking down tasks into manageable, reusable units of code.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Calling a function to print a greeting message
function greet() {
    console.log("Hello, world!");
}
greet(); // Logs: "Hello, world!"

// Example 2: Calling a function to add two numbers and print the result
function add(a, b) {
    return a + b;
}
console.log(add(5, 3)); // Logs: 8

// Example 3: Calling a function to check if a number is even and print the result
function isEven(number) {
    return number % 2 === 0;
}
console.log(isEven(4)); // Logs: true

// Example 4: Calling a function to convert Celsius to Fahrenheit and print the result
function toFahrenheit(celsius) {
    return celsius * 9 / 5 + 32;
}
console.log(toFahrenheit(0)); // Logs: 32

// Example 5: Calling a function to reverse a string and print the result
function reverseString(str) {
    return str.split('').reverse().join('');
}
console.log(reverseString("hello")); // Logs: "olleh"

            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-para', event)">
              parameters and arguments
            </td>
          </tr>
          <tr id="detail-tag-para" class="expandable-row-content">
            <td>
              <h3>parameters and arguments</h3>
              <p>In JavaScript, parameters and arguments are key concepts in functions that enable the passing of data into functions for processing. Parameters are the names listed in the function definition and act as placeholders for the values that will be passed to the function when it is called. For instance, in the function `function add(a, b)`, `a` and `b` are parameters. Arguments, on the other hand, are the actual values that are passed to the function when it is invoked. For example, in the call `add(5, 3)`, the values `5` and `3` are arguments. Parameters define what type of input a function can accept, while arguments provide the actual input data. When a function is called, the arguments are assigned to the corresponding parameters, and the function uses these values to execute its code. This mechanism allows functions to be flexible and reusable, as the same function can be called with different arguments to perform a variety of tasks. Understanding how to use parameters and arguments effectively is crucial for writing dynamic and adaptable JavaScript code.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Function with parameters to add two numbers
function add(a, b) {
    return a + b;
}
console.log(add(5, 3)); // Logs: 8

// Example 2: Function with parameters to greet a user by name
function greet(name) {
    console.log("Hello, " + name + "!");
}
greet("Alice"); // Logs: "Hello, Alice!"

// Example 3: Function with parameters to calculate the area of a rectangle
function calculateArea(width, height) {
    return width * height;
}
console.log(calculateArea(5, 10)); // Logs: 50

// Example 4: Function with parameters to determine if a number is greater than another
function isGreater(a, b) {
    return a > b;
}
console.log(isGreater(10, 5)); // Logs: true

// Example 5: Function with parameters to concatenate two strings
function concatenate(str1, str2) {
    return str1 + " " + str2;
}
console.log(concatenate("Hello", "world")); // Logs: "Hello world"
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-default', event)">
              default parameters
            </td>
          </tr>
          <tr id="detail-tag-default" class="expandable-row-content">
            <td>
              <h3>default parameters</h3>
              <p>Default parameters in JavaScript functions allow you to specify default values for parameters in case no arguments are provided or if `undefined` is passed as an argument when the function is called. This feature, introduced in ES6, simplifies the function definitions by eliminating the need for manual checks and assignments within the function body. To set a default parameter, you simply assign a value to the parameter in the function definition, like `function greet(name = "Guest")`. If the caller does not provide a value for `name`, it will default to "Guest". This mechanism enhances the flexibility and robustness of functions, ensuring they have meaningful default behavior even when some arguments are omitted. Default parameters can also be expressions or even other function calls, providing a powerful tool for managing function inputs and improving code readability.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Function with a default parameter for greeting
function greet(name = "Guest") {
    console.log("Hello, " + name + "!");
}
greet(); // Logs: "Hello, Guest!"
greet("Alice"); // Logs: "Hello, Alice!"

// Example 2: Function with a default parameter for addition
function add(a = 0, b = 0) {
    return a + b;
}
console.log(add()); // Logs: 0
console.log(add(5)); // Logs: 5
console.log(add(5, 3)); // Logs: 8

// Example 3: Function with a default parameter for multiplication
function multiply(a, b = 1) {
    return a * b;
}
console.log(multiply(5)); // Logs: 5
console.log(multiply(5, 2)); // Logs: 10

// Example 4: Function with a default parameter for calculating power
function power(base, exponent = 2) {
    return Math.pow(base, exponent);
}
console.log(power(3)); // Logs: 9
console.log(power(3, 3)); // Logs: 27

// Example 5: Function with a default parameter for formatting a date
function formatDate(date = new Date()) {
    return date.toDateString();
}
console.log(formatDate()); // Logs: Current date in string format
console.log(formatDate(new Date('2022-01-01'))); // Logs: "Sat Jan 01 2022"
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-return', event)">
              return keyword
            </td>
          </tr>
          <tr id="detail-tag-return" class="expandable-row-content">
            <td>
              <h3>return keyword</h3>
              <p>The `return` keyword in JavaScript functions is used to specify the value that a function should output when it is called. When a function reaches a `return` statement, it immediately stops execution and returns the specified value to the caller. This allows functions to produce results that can be used elsewhere in the code. For example, a function that performs a calculation can return the result so it can be assigned to a variable or used in another computation. If a function does not explicitly return a value, it implicitly returns `undefined`. The `return` keyword is essential for creating reusable and modular code, as it enables functions to provide outputs based on their input parameters and internal logic. Using `return` effectively can make functions more versatile and the overall codebase more maintainable and efficient.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Function with no return statement, implicitly returns undefined
function noReturn() {
    let a = 5 + 3;
}
console.log(noReturn()); // Logs: undefined

// Example 2: Function to add two numbers and return the result
function add(a, b) {
    return a + b;
}
console.log(add(5, 3)); // Logs: 8

// Example 3: Function to find the square of a number and return the result
function square(x) {
    return x * x;
}
console.log(square(4)); // Logs: 16

// Example 4: Function to concatenate two strings and return the result
function concatenate(str1, str2) {
    return str1 + " " + str2;
}
console.log(concatenate("Hello", "world")); // Logs: "Hello world"

// Example 5: Function to determine if a number is even and return the result
function isEven(number) {
    return number % 2 === 0;
}
console.log(isEven(10)); // Logs: true
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-helper', event)">
              helper functions
            </td>
          </tr>
          <tr id="detail-tag-helper" class="expandable-row-content">
            <td>
              <h3>helper functions</h3>
              <p>Helper functions in JavaScript are small, reusable functions designed to perform specific tasks that support the main operations of a program. These functions typically handle common or repetitive tasks, such as data formatting, calculations, or other utility operations, thereby promoting code reusability and modularity. By breaking down complex problems into smaller, manageable functions, helper functions make the main codebase cleaner, more readable, and easier to maintain. They encapsulate functionality that can be tested independently, improving code reliability and facilitating debugging. For instance, a helper function might be used to validate user input, format dates, or manipulate arrays. Using helper functions allows developers to avoid redundancy, as the same piece of logic can be called multiple times from different parts of the application, ensuring consistency and reducing the likelihood of errors. Overall, helper functions are a fundamental practice in writing efficient and maintainable JavaScript code.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Helper function to format a date
function formatDate(date) {
    const options = { year: 'numeric', month: 'long', day: 'numeric' };
    return date.toLocaleDateString(undefined, options);
}
const date = new Date('2024-07-24');
console.log(formatDate(date)); // Logs: "July 24, 2024"

// Example 2: Helper function to validate an email address
function isValidEmail(email) {
    const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return re.test(email);
}
console.log(isValidEmail("test@example.com")); // Logs: true
console.log(isValidEmail("invalid-email")); // Logs: false

// Example 3: Helper function to capitalize the first letter of a string
function capitalizeFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
console.log(capitalizeFirstLetter("hello")); // Logs: "Hello"

// Example 4: Helper function to generate a random integer between two values
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
console.log(getRandomInt(1, 10)); // Logs: a random number between 1 and 10

// Example 5: Helper function to remove duplicates from an array
function removeDuplicates(arr) {
    return [...new Set(arr)];
}
const arrayWithDuplicates = [1, 2, 2, 3, 4, 4, 5];
console.log(removeDuplicates(arrayWithDuplicates)); // Logs: [1, 2, 3, 4, 5]

            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-fexpressions', event)">
              function expressions
            </td>
          </tr>
          <tr id="detail-tag-fexpressions" class="expandable-row-content">
            <td>
              <h3>function expressions</h3>
              <p>Function expressions in JavaScript are a way to define functions as part of a larger expression, typically assigned to a variable. Unlike function declarations, which are hoisted and available throughout their scope, function expressions are not hoisted and are only available after their assignment is evaluated. A function expression can be anonymous, meaning it does not have a name, or named, where the function is assigned a name for reference within its own scope. For example, `const add = function(a, b) { return a + b; };` defines a function expression assigned to the variable `add`. This form of function definition is particularly useful for creating closures, passing functions as arguments to other functions, or defining functions within conditional blocks. Function expressions provide more flexibility and control over when and how functions are defined and executed, contributing to more modular and maintainable code. They are fundamental in many JavaScript programming patterns, including immediately invoked function expressions (IIFEs) and callbacks, enhancing the language's functional programming capabilities.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Anonymous function expression assigned to a variable
const greet = function() {
    console.log("Hello, world!");
};
greet(); // Logs: "Hello, world!"

// Example 2: Named function expression assigned to a variable
const factorial = function fact(n) {
    if (n <= 1) return 1;
    return n * fact(n - 1);
};
console.log(factorial(5)); // Logs: 120

// Example 3: Function expression used as a callback
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(function(num) {
    return num * 2;
});
console.log(doubled); // Logs: [2, 4, 6, 8, 10]

// Example 4: Immediately Invoked Function Expression (IIFE)
(function() {
    console.log("This function runs immediately!");
})(); // Logs: "This function runs immediately!"

// Example 5: Function expression used in an object method
const mathOperations = {
    add: function(a, b) {
        return a + b;
    },
    subtract: function(a, b) {
        return a - b;
    }
};
console.log(mathOperations.add(10, 5)); // Logs: 15
console.log(mathOperations.subtract(10, 5)); // Logs: 5

// Example 6: Function expression used as an event handler
document.getElementById("myButton").addEventListener("click", function() {
    console.log("Button clicked!");
}); // Logs: "Button clicked!" when the button is clicked

// Example 7: Function expression to filter an array
const isEven = function(num) {
    return num % 2 === 0;
};
const evens = numbers.filter(isEven);
console.log(evens); // Logs: [2, 4]

// Example 8: Function expression to find the maximum in an array
const max = function(arr) {
    return Math.max.apply(null, arr);
};
console.log(max([1, 2, 3, 4, 5])); // Logs: 5

// Example 9: Function expression to sort an array
const sorted = numbers.sort(function(a, b) {
    return b - a;
});
console.log(sorted); // Logs: [5, 4, 3, 2, 1]

// Example 10: Function expression to convert an array of strings to uppercase
const upperCaseStrings = ["hello", "world"].map(function(str) {
    return str.toUpperCase();
});
console.log(upperCaseStrings); // Logs: ["HELLO", "WORLD"]

            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-arrow', event)">
              arrow functions
            </td>
          </tr>
          <tr id="detail-tag-arrow" class="expandable-row-content">
            <td>
              <h3>arrow functions</h3>
              <p>Arrow functions in JavaScript, introduced in ES6, provide a concise syntax for writing functions. Unlike traditional function expressions, arrow functions do not have their own `this`, `arguments`, `super`, or `new.target` bindings. Instead, they lexically inherit `this` from the surrounding function or scope, which makes them particularly useful for maintaining the correct `this` context inside callbacks and other nested functions. The syntax of arrow functions is shorter: parameters are enclosed in parentheses (which can be omitted if there's only one parameter), followed by the `=>` symbol, and the function body. For single expression functions, curly braces and the `return` keyword can be omitted, resulting in even more compact code. For example, `const add = (a, b) => a + b;` defines a simple arrow function that adds two numbers. Arrow functions enhance code readability and are often used in array methods like `map`, `filter`, and `reduce` due to their brevity and automatic binding of `this`. However, they are not suitable for all situations, such as methods in an object, where traditional function expressions are more appropriate.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Simple arrow function to add two numbers
const add = (a, b) => a + b;
console.log(add(5, 3)); // Logs: 8

// Example 2: Arrow function with a single parameter
const square = x => x * x;
console.log(square(4)); // Logs: 16

// Example 3: Arrow function returning an object
const createUser = (name, age) => ({ name, age });
console.log(createUser("Alice", 30)); // Logs: { name: 'Alice', age: 30 }

// Example 4: Arrow function with no parameters
const greet = () => "Hello, world!";
console.log(greet()); // Logs: "Hello, world!"

// Example 5: Arrow function used as a callback in array map method
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(num => num * 2);
console.log(doubled); // Logs: [2, 4, 6, 8, 10]

// Example 6: Arrow function used in array filter method
const evens = numbers.filter(num => num % 2 === 0);
console.log(evens); // Logs: [2, 4]

// Example 7: Arrow function used in array reduce method
const sum = numbers.reduce((total, num) => total + num, 0);
console.log(sum); // Logs: 15

// Example 8: Arrow function with implicit return
const multiply = (a, b) => a * b;
console.log(multiply(6, 7)); // Logs: 42

// Example 9: Arrow function with explicit return
const isEven = num => {
    return num % 2 === 0;
};
console.log(isEven(10)); // Logs: true

// Example 10: Arrow function used inside a setTimeout
setTimeout(() => {
    console.log("This runs after 1 second");
}, 1000); // Logs: "This runs after 1 second" (after 1 second)

            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-concise', event)">
              concise body arrow functions
            </td>
          </tr>
          <tr id="detail-tag-concise" class="expandable-row-content">
            <td>
              <h3>concise body arrow functions</h3>
              <p>Concise body arrow functions in JavaScript are a streamlined way to write functions, allowing for more readable and compact code. These functions omit the curly braces and the `return` keyword when the function body contains a single expression. The value of this expression is implicitly returned, making the syntax much shorter and more convenient for simple operations. For instance, `const add = (a, b) => a + b;` is a concise body arrow function that adds two numbers and returns the result. This format is particularly useful for inline functions, such as those passed to array methods like `map`, `filter`, and `reduce`. Concise body arrow functions improve code clarity and reduce boilerplate, enabling developers to write succinct and expressive functions, especially for straightforward computations and transformations. However, for more complex logic that requires multiple statements, curly braces and an explicit `return` statement must be used.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Concise body arrow function to add two numbers
const add = (a, b) => a + b;
console.log(add(5, 3)); // Logs: 8

// Example 2: Concise body arrow function to square a number
const square = x => x * x;
console.log(square(4)); // Logs: 16

// Example 3: Concise body arrow function to return a greeting message
const greet = () => "Hello, world!";
console.log(greet()); // Logs: "Hello, world!"

// Example 4: Concise body arrow function to check if a number is even
const isEven = num => num % 2 === 0;
console.log(isEven(10)); // Logs: true

// Example 5: Concise body arrow function to get the length of a string
const getLength = str => str.length;
console.log(getLength("Hello")); // Logs: 5

// Example 6: Concise body arrow function to convert an array of numbers to their squares
const squares = numbers => numbers.map(num => num * num);
console.log(squares([1, 2, 3, 4])); // Logs: [1, 4, 9, 16]

// Example 7: Concise body arrow function to filter out odd numbers from an array
const filterOdds = numbers => numbers.filter(num => num % 2 === 0);
console.log(filterOdds([1, 2, 3, 4, 5])); // Logs: [2, 4]
          
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-bpf', event)">
              best practices
            </td>
          </tr>
          <tr id="detail-tag-bpf" class="expandable-row-content">
            <td>
              <h3>best practices</h3>
              <p>When writing functions in JavaScript, adhering to best practices is crucial for creating clean, maintainable, and efficient code. One key practice is to keep functions small and focused, adhering to the single responsibility principle, which states that a function should accomplish only one task. This approach enhances readability and makes the function easier to test and debug. Naming functions descriptively is also important; a function's name should clearly describe what it does, making the code self-documenting and understandable at a glance. Using default parameters can help handle edge cases gracefully, ensuring functions behave predictably even when called with missing arguments. Additionally, leveraging function expressions and arrow functions can improve code conciseness and maintain the correct this context, especially in callbacks. Properly using return statements is essential to avoid unintended side effects and to clearly define what a function outputs. When dealing with asynchronous operations, utilizing promises and async/await syntax helps manage code flow more effectively and avoid callback hell. It is also a good practice to avoid using global variables within functions to prevent side effects and potential conflicts in larger codebases. Instead, functions should rely on parameters and return values to pass data in and out. Documenting functions with comments or JSDoc annotations can be beneficial, especially for complex logic, providing clear explanations of the function's purpose, parameters, and return values. Testing functions thoroughly, including edge cases, ensures robustness and reliability.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Single Responsibility Principle - Function to add two numbers
function add(a, b) {
    return a + b;
}
console.log(add(5, 3)); // Logs: 8

// Example 2: Descriptive Function Name - Function to greet a user by name
function greetUser(name) {
    return `Hello, ${name}!`;
}
console.log(greetUser("Alice")); // Logs: "Hello, Alice!"

// Example 3: Using Default Parameters - Function to multiply two numbers with a default value
function multiply(a, b = 1) {
    return a * b;
}
console.log(multiply(5)); // Logs: 5
console.log(multiply(5, 3)); // Logs: 15

// Example 4: Using Arrow Functions - Function to check if a number is even
const isEven = num => num % 2 === 0;
console.log(isEven(4)); // Logs: true

// Example 5: Properly Using Return Statements - Function to find the maximum of two numbers
function max(a, b) {
    return a > b ? a : b;
}
console.log(max(10, 15)); // Logs: 15

// Example 6: Avoiding Global Variables - Function to calculate area of a rectangle
function calculateArea(width, height) {
    return width * height;
}
console.log(calculateArea(5, 10)); // Logs: 50

// Example 7: Using Async/Await - Function to fetch data from an API
async function fetchData(url) {
    try {
        let response = await fetch(url);
        let data = await response.json();
        return data;
    } catch (error) {
        console.error("Error fetching data:", error);
    }
}
fetchData('https://api.example.com/data').then(data => console.log(data));

// Example 8: Thorough Testing - Function to calculate factorial
function factorial(n) {
    if (n < 0) return undefined;
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
console.log(factorial(5)); // Logs: 120
console.log(factorial(-1)); // Logs: undefined

// Example 9: Using Function Expressions - Function to filter odd numbers from an array
const filterOdds = function(numbers) {
    return numbers.filter(num => num % 2 === 0);
};
console.log(filterOdds([1, 2, 3, 4, 5])); // Logs: [2, 4]

// Example 10: Documenting Functions - Function to reverse a string
/**
 * Reverses a given string.
 * @param {string} str - The string to be reversed.
 * @returns {string} - The reversed string.
 */
function reverseString(str) {
    return str.split('').reverse().join('');
}
console.log(reverseString("hello")); // Logs: "olleh"
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td id="scope" class="tableletters">Scope</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-blocks', event)">
              blocks
            </td>
          </tr>
          <tr id="detail-tag-blocks" class="expandable-row-content">
            <td>
              <h3>blocks</h3>
              <p>Blocks in JavaScript are fundamental structures used to group statements together, enclosed within curly braces `{}`. They are typically used in control flow statements such as `if`, `for`, `while`, and `switch`, as well as in defining the bodies of functions. Blocks create a new scope for variables declared with `let` and `const`, meaning these variables are confined to the block and cannot be accessed outside of it, thus preventing potential conflicts and unintended behavior in the broader program. This scoping behavior, known as block-level scoping, is a key feature introduced in ES6 that enhances the management and predictability of variables within code. Blocks also play a crucial role in the organization and readability of code, allowing developers to structure and nest operations logically and hierarchically. They ensure that related statements are executed together, maintaining the integrity of the logic and control flow within the program. Understanding and utilizing blocks effectively is essential for writing clean, efficient, and maintainable JavaScript code.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Block in an if statement
if (true) {
    let message = "This is inside the block";
    console.log(message); // Logs: "This is inside the block"
}
// console.log(message); // Uncaught ReferenceError: message is not defined

// Example 2: Block in a for loop
for (let i = 0; i < 3; i++) {
    let message = `Iteration ${i}`;
    console.log(message); // Logs: "Iteration 0", "Iteration 1", "Iteration 2"
}
// console.log(i); // Uncaught ReferenceError: i is not defined

// Example 3: Block in a while loop
let count = 0;
while (count < 3) {
    let message = `Count is ${count}`;
    console.log(message); // Logs: "Count is 0", "Count is 1", "Count is 2"
    count++;
}

// Example 4: Block in a function
function greet(name) {
    {
        let message = `Hello, ${name}!`;
        console.log(message); // Logs: "Hello, [name]!"
    }
    // console.log(message); // Uncaught ReferenceError: message is not defined
}
greet("Alice"); // Logs: "Hello, Alice!"

// Example 5: Block in a switch statement
let fruit = "apple";
switch (fruit) {
    case "apple": {
        let message = "This is an apple";
        console.log(message); // Logs: "This is an apple"
        break;
    }
    case "banana": {
        let message = "This is a banana";
        console.log(message);
        break;
    }
    default: {
        let message = "Unknown fruit";
        console.log(message);
    }
}
// console.log(message); // Uncaught ReferenceError: message is not defined
          
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-global', event)">
              global scope and global variables
            </td>
          </tr>
          <tr id="detail-tag-global" class="expandable-row-content">
            <td>
              <h3>global scope and global variables</h3>
              <p>In JavaScript, the global scope is the outermost scope in the execution context, where global variables reside. Global variables are those declared outside of any function or block, making them accessible from any part of the code. When a variable is defined in the global scope, it becomes a property of the global object, which is `window` in browsers and `global` in Node.js. While global variables can be convenient for sharing data across different parts of a program, they come with significant risks, such as potential naming conflicts and unintended side effects. Because global variables can be modified from anywhere in the code, they can lead to bugs that are difficult to trace and debug. Furthermore, excessive use of global variables can reduce the modularity and maintainability of the code. Best practices suggest minimizing the use of global variables and, instead, encapsulating variables within functions or blocks to limit their scope and improve the reliability of the code. Understanding and managing the global scope is crucial for writing efficient and error-free JavaScript applications.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Declaring a global variable
let globalVar = "I am a global variable";
function showGlobalVar() {
    console.log(globalVar); // Logs: "I am a global variable"
}
showGlobalVar();

// Example 2: Modifying a global variable within a function
let globalCounter = 0;
function incrementCounter() {
    globalCounter++;
}
incrementCounter();
console.log(globalCounter); // Logs: 1

// Example 3: Accessing a global variable inside a block
const globalMessage = "Hello, world!";
{
    console.log(globalMessage); // Logs: "Hello, world!"
}

// Example 4: Declaring a global variable with let
let globalLetVar = "I am a global let variable";
function showGlobalLetVar() {
    console.log(globalLetVar); // Logs: "I am a global let variable"
}
showGlobalLetVar();

// Example 5: Creating a global variable without let or const (not recommended)
function createGlobalVar() {
    window.accidentalGlobalVar = "I am an accidental global variable";
}
createGlobalVar();
console.log(window.accidentalGlobalVar); // Logs: "I am an accidental global variable"

// Example 6: Using a global variable in multiple functions
let sharedVar = "Shared variable";
function firstFunction() {
    console.log(sharedVar); // Logs: "Shared variable"
}
function secondFunction() {
    sharedVar = "Modified shared variable";
    console.log(sharedVar); // Logs: "Modified shared variable"
}
firstFunction();
secondFunction();
console.log(sharedVar); // Logs: "Modified shared variable"

// Example 7: Potential conflict with global variables
let name = "Alice";
function setName() {
    name = "Bob"; // Modifies the global variable
}
setName();
console.log(name); // Logs: "Bob"
          
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-block', event)">
              block scope and local variables
            </td>
          </tr>
          <tr id="detail-tag-block" class="expandable-row-content">
            <td>
              <h3>block scope and local variables</h3>
              <p>Block scope in JavaScript refers to the visibility and accessibility of variables declared within a specific block of code, which is defined by curly braces `{}`. Variables declared with `let` and `const` inside a block are confined to that block and cannot be accessed outside of it. This scoping behavior contrasts with variables declared using `var`, which are function-scoped and can be accessed outside the block they are defined in, provided they are within the same function. Block scope enhances code maintainability and readability by preventing variables from leaking into the outer scope, reducing the likelihood of naming conflicts and unintended interactions. This feature is particularly useful in control flow statements like `if`, `for`, and `while`, as well as in function definitions, where you want to limit the variable's lifespan and accessibility to a specific section of code. By using block-scoped variables, developers can write more predictable and error-free code, as it is clear where each variable is accessible and where it is not.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Block scope with let in an if statement
if (true) {
    let message = "This is inside the block";
    console.log(message); // Logs: "This is inside the block"
}
// console.log(message); // Uncaught ReferenceError: message is not defined

// Example 2: Block scope with const in a for loop
for (let i = 0; i < 3; i++) {
    const message = `Iteration ${i}`;
    console.log(message); // Logs: "Iteration 0", "Iteration 1", "Iteration 2"
}
// console.log(i); // Uncaught ReferenceError: i is not defined

// Example 3: Block scope with let in a while loop
let count = 0;
while (count < 3) {
    let message = `Count is ${count}`;
    console.log(message); // Logs: "Count is 0", "Count is 1", "Count is 2"
    count++;
}
// console.log(message); // Uncaught ReferenceError: message is not defined

// Example 4: Block scope with const in a function
function greet(name) {
    {
        const message = `Hello, ${name}!`;
        console.log(message); // Logs: "Hello, Alice!"
    }
    // console.log(message); // Uncaught ReferenceError: message is not defined
}
greet("Alice");

// Example 5: Block scope with let in a switch statement
let fruit = "apple";
switch (fruit) {
    case "apple": {
        let message = "This is an apple";
        console.log(message); // Logs: "This is an apple"
        break;
    }
    case "banana": {
        let message = "This is a banana";
        console.log(message);
        break;
    }
    default: {
        let message = "Unknown fruit";
        console.log(message);
    }
}
// console.log(message); // Uncaught ReferenceError: message is not defined

// Example 6: Block scope with const in nested blocks
{
    const outerMessage = "Outer block";
    {
        const innerMessage = "Inner block";
        console.log(outerMessage); // Logs: "Outer block"
        console.log(innerMessage); // Logs: "Inner block"
    }
    // console.log(innerMessage); // Uncaught ReferenceError: innerMessage is not defined
}
// console.log(outerMessage); // Uncaught ReferenceError: outerMessage is not defined

// Example 7: Block scope with let in a try-catch block
try {
    let message = "Trying something";
    console.log(message); // Logs: "Trying something"
} catch (error) {
    let errorMessage = "An error occurred";
    console.log(errorMessage); // Only logs if an error occurs
}
// console.log(message); // Uncaught ReferenceError: message is not defined
// console.log(errorMessage); // Uncaught ReferenceError: errorMessage is not defined
          
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-scopep', event)">
              scope pollution
            </td>
          </tr>
          <tr id="detail-tag-scopep" class="expandable-row-content">
            <td>
              <h3>scope pollution</h3>
              <p>Scope pollution, often referred to as namespace pollution, in JavaScript occurs when too many variables, functions, or objects are declared in the global scope, leading to potential conflicts and maintainability issues. This happens when variables are unnecessarily declared globally rather than locally within functions or blocks, making them accessible from any part of the program. Such global declarations can cause name collisions, where multiple variables with the same name overwrite each other's values, resulting in unpredictable behavior and hard-to-debug errors. Namespace pollution makes the codebase more difficult to read and maintain because it becomes challenging to track the origin and usage of each variable. Additionally, it increases the risk of inadvertently affecting other parts of the code, leading to unintended side effects. To mitigate scope pollution, it is essential to declare variables within the narrowest possible scope, such as inside functions or blocks, and use `let` and `const` instead of `var` to leverage block scoping. Encapsulating code within functions, modules, or immediately invoked function expressions (IIFEs) can further help manage variable scope effectively, ensuring that variables do not leak into the global scope and reducing the risk of scope pollution.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Global variable affecting functions
let globalVar = "I am global";

function showGlobalVar() {
    console.log(globalVar); // Logs: "I am global"
}

function changeGlobalVar() {
    globalVar = "I am changed globally";
}

showGlobalVar(); // Logs: "I am global"
changeGlobalVar();
showGlobalVar(); // Logs: "I am changed globally"

// Example 2: Overwriting global variable
let counter = 1;

function incrementCounter() {
    counter++;
}

function resetCounter() {
    counter = 0; // This affects the global counter
}

console.log(counter); // Logs: 1
incrementCounter();
console.log(counter); // Logs: 2
resetCounter();
console.log(counter); // Logs: 0

// Example 3: Function variable leaking to global scope
function createGlobalVariable() {
    leakedVar = "I am leaked"; // No let or const, becomes global
}

createGlobalVariable();
console.log(leakedVar); // Logs: "I am leaked"

// Example 4: Global variable name collision
let name = "Alice";

function setName() {
    name = "Bob"; // Overwrites the global variable
}

console.log(name); // Logs: "Alice"
setName();
console.log(name); // Logs: "Bob"

// Example 5: Using var in loops causing scope pollution
for (var i = 0; i < 5; i++) {
    // i is declared globally due to var
    console.log(i); // Logs: 0, 1, 2, 3, 4
}
console.log(i); // Logs: 5, i is accessible outside the loop
          
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-bpscope', event)">
              best practices
            </td>
          </tr>
          <tr id="detail-tag-bpscope" class="expandable-row-content">
            <td>
              <h3>best practices</h3>
              <p>Best practices regarding scope in JavaScript emphasize the importance of minimizing the use of global variables to prevent scope pollution and potential conflicts. Variables should be declared within the narrowest possible scope, such as inside functions or blocks, to limit their visibility and impact. Using `let` and `const` instead of `var` is recommended, as they provide block-level scoping, reducing the likelihood of unintended variable leakage and overwriting. Encapsulating code within functions, modules, or immediately invoked function expressions (IIFEs) can further isolate variables and functions, ensuring they do not interfere with other parts of the program. Consistently using descriptive and unique variable names helps avoid naming collisions and makes the code more readable and maintainable. Additionally, understanding and leveraging closures can help manage scope effectively, allowing functions to access variables from their containing scope in a controlled manner. By adhering to these practices, developers can write more robust, maintainable, and error-free JavaScript code.</p>
              <br />
            </td>
          </tr>
          <tr>
            <td id="arrays" class="tableletters">Arrays</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-arrayover', event)">
              syntax & purpose
            </td>
          </tr>
          <tr id="detail-tag-arrayover" class="expandable-row-content">
            <td>
              <h3>syntax & purpose</h3>
              <p>In JavaScript, arrays are a powerful data structure used to store multiple values in a single variable, allowing developers to manage collections of data efficiently. The syntax for creating an array involves using square brackets `[]`, with elements separated by commas. For instance, an array of numbers can be created with the syntax `let numbers = [1, 2, 3, 4, 5];`. Arrays in JavaScript can contain elements of various data types, such as numbers, strings, objects, or even other arrays, which makes them extremely flexible. To create an array, you can use the array literal notation, as shown above, or the `Array` constructor, like `let fruits = new Array('apple', 'banana', 'cherry');`. However, using the array literal notation is generally preferred for its simplicity and readability. Elements within an array are accessed via their index, starting from 0, meaning `numbers[0]` would access the first element of the `numbers` array. JavaScript arrays come with numerous built-in methods to facilitate manipulation, such as `push()` to add elements, `pop()` to remove the last element, and `shift()` and `unshift()` to add or remove elements from the beginning. Arrays are essential for tasks involving data organization, iteration, and implementing complex data structures like stacks and queues. This makes arrays a fundamental part of JavaScript programming, allowing developers to handle data collections effectively.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Creating an array using array literal notation
let fruits = ['apple', 'banana', 'cherry'];

// Example 2: Creating an array using the Array constructor
let numbers = new Array(1, 2, 3, 4, 5);

// Example 3: Accessing elements in an array by index
console.log(fruits[0]); // Output: 'apple'

// Example 4: Modifying an element in an array
fruits[1] = 'blueberry';
console.log(fruits); // Output: ['apple', 'blueberry', 'cherry']

// Example 5: Adding elements to the end of an array using push()
fruits.push('orange');
console.log(fruits); // Output: ['apple', 'blueberry', 'cherry', 'orange']

// Example 6: Removing the last element of an array using pop()
let lastFruit = fruits.pop();
console.log(lastFruit); // Output: 'orange'
console.log(fruits); // Output: ['apple', 'blueberry', 'cherry']

// Example 7: Adding elements to the beginning of an array using unshift()
fruits.unshift('kiwi');
console.log(fruits); // Output: ['kiwi', 'apple', 'blueberry', 'cherry']  
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-literal', event)">
              literal notation
            </td>
          </tr>
          <tr id="detail-tag-literal" class="expandable-row-content">
            <td>
              <h3>literal notation</h3>
              <p>The literal notation of JavaScript arrays is a straightforward and efficient way to create arrays by directly specifying the elements within square brackets, separated by commas. This method is concise and widely used due to its simplicity and readability, allowing developers to initialize arrays without needing to invoke a constructor. For example, an array of fruits can be created with the syntax `let fruits = ['apple', 'banana', 'cherry'];`, where each string represents an element within the array. This notation supports elements of various data types, including numbers, strings, objects, and even nested arrays, which can all be mixed within a single array. The flexibility of array literal notation makes it a popular choice for defining arrays quickly, especially when the initial content is known. Accessing elements is done using zero-based indexing, allowing developers to easily retrieve, modify, or iterate over the data. Literal notation also supports empty arrays, represented by simply using empty brackets `[]`, which can be filled with elements dynamically as needed. This approach not only enhances code readability but also improves maintainability by presenting a clear structure of the array's contents at a glance. Overall, array literal notation is an essential feature in JavaScript that simplifies the process of working with collections of data.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Creating an array of numbers
let numbers = [1, 2, 3, 4, 5];
console.log(numbers); // Output: [1, 2, 3, 4, 5]

// Example 2: Creating an array of strings
let fruits = ['apple', 'banana', 'cherry'];
console.log(fruits); // Output: ['apple', 'banana', 'cherry']

// Example 3: Creating an array with mixed data types
let mixedArray = [42, 'hello', true, null];
console.log(mixedArray); // Output: [42, 'hello', true, null]

// Example 4: Creating an array with nested arrays
let nestedArray = [[1, 2], [3, 4], [5, 6]];
console.log(nestedArray); // Output: [[1, 2], [3, 4], [5, 6]]

// Example 5: Creating an array of objects
let users = [{name: 'Alice', age: 30}, {name: 'Bob', age: 25}];
console.log(users); // Output: [{name: 'Alice', age: 30}, {name: 'Bob', age: 25}]

// Example 6: Creating an empty array
let emptyArray = [];
console.log(emptyArray); // Output: []

// Example 7: Using literal notation to create a sparse array
let sparseArray = [1, , 3]; // The second element is missing, creating a hole
console.log(sparseArray);
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-constructor', event)">
              constructor notation
            </td>
          </tr>
          <tr id="detail-tag-constructor" class="expandable-row-content">
            <td>
              <h3>constructor notation</h3>
              <p>The constructor notation of JavaScript arrays involves using the `Array` constructor to create a new array instance, providing more explicit control over the array's creation process. This method uses the `new Array()` syntax, where you can optionally pass arguments to specify the elements or the length of the array. For example, `let numbers = new Array(5);` creates an array with a length of five, filled with empty slots, while `let fruits = new Array('apple', 'banana', 'cherry');` initializes an array with the specified elements. The constructor notation is particularly useful when creating arrays with a predetermined size or when you need to create an array without initializing it with specific elements immediately. However, this method can sometimes lead to confusion, especially when a single numerical argument is passed to the constructor, as it is interpreted as the array's length rather than a single element. Despite this potential pitfall, using the `Array` constructor provides a more explicit way to define arrays, allowing for flexibility in certain programming scenarios, especially when handling array-like objects or creating arrays dynamically. Overall, while the literal notation is often preferred for its simplicity, the constructor notation remains a valuable tool in a JavaScript developer's arsenal, offering an alternative method for creating and managing arrays.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Creating an empty array with a specific length
let emptyArray = new Array(5);
console.log(emptyArray); // Output: [undefined, undefined, undefined, undefined, undefined]

// Example 2: Creating an array with initial elements
let fruits = new Array('apple', 'banana', 'cherry');
console.log(fruits); // Output: ['apple', 'banana', 'cherry']

// Example 3: Creating an array with a single numeric element
let singleNumber = new Array(7);
console.log(singleNumber); // Output: [undefined, undefined, undefined, undefined, undefined, undefined, undefined]

// Example 4: Creating an array with a single string element
let singleString = new Array('hello');
console.log(singleString); // Output: ['hello']

// Example 5: Creating an array with mixed data types
let mixedArray = new Array(42, 'hello', true, null);
console.log(mixedArray); // Output: [42, 'hello', true, null]

// Example 6: Creating a two-dimensional array
let matrix = new Array(
  new Array(1, 2, 3),
  new Array(4, 5, 6),
  new Array(7, 8, 9)
);
console.log(matrix); // Output: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

// Example 7: Creating an array using the Array.of method (alternative to constructor)
let arrayOf = Array.of(10, 20, 30);
console.log(arrayOf); // Output: [10, 20, 30]
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-indexing', event)">
              zero-based indexing
            </td>
          </tr>
          <tr id="detail-tag-indexing" class="expandable-row-content">
            <td>
              <h3>zero-based indexing</h3>
              <p>In JavaScript, arrays are indexed collections of elements, where each element is accessed by a numerical index that starts at zero. This means the first element in an array is at index 0, the second element at index 1, and so on, which is known as zero-based indexing. This indexing system allows developers to iterate over arrays efficiently and perform operations on specific elements by referencing their positions. The index serves as a key to access the corresponding value within the array, enabling quick data retrieval and manipulation. For example, given an array `let colors = ['red', 'green', 'blue'];`, accessing the first element is done using `colors[0]`, which would return `'red'`. JavaScript also allows negative indexing using methods like `Array.prototype.at()`, where `colors.at(-1)` returns the last element of the array. Additionally, arrays in JavaScript can be sparse, meaning they can have empty slots without defined values if elements are omitted during initialization or removed later. This feature can lead to indices that do not have associated values, which can be handled carefully during iterations and data manipulations. Overall, understanding and utilizing array indexing in JavaScript is crucial for effectively managing and manipulating collections of data in various programming scenarios.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Accessing the first element using zero-based index
let colors = ['red', 'green', 'blue'];
console.log(colors[0]); // Output: 'red'

// Example 2: Accessing the last element using length property
console.log(colors[colors.length - 1]); // Output: 'blue'

// Example 3: Accessing an element in a nested array
let matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
console.log(matrix[1][1]); // Output: 5 (second row, second column)

// Example 4: Modifying an element at a specific index
colors[1] = 'yellow';
console.log(colors); // Output: ['red', 'yellow', 'blue']

// Example 5: Adding a new element at a specific index
colors[3] = 'purple';
console.log(colors); // Output: ['red', 'yellow', 'blue', 'purple']

// Example 6: Accessing an index that doesn't exist (returns undefined)
console.log(colors[10]); // Output: undefined

// Example 7: Iterating over an array using index
for (let i = 0; i < colors.length; i++) {
  console.log(colors[i]); // Output: 'red', 'yellow', 'blue', 'purple'
}

// Example 8: Using negative indexing with Array.prototype.at()
console.log(colors.at(-1)); // Output: 'purple'

// Example 9: Finding the index of an element using indexOf
let index = colors.indexOf('blue');
console.log(index); // Output: 2

// Example 10: Using the index to remove an element
let removedElement = colors.splice(1, 1); // Removes 'yellow'
console.log(colors); // Output: ['red', 'blue', 'purple']
console.log(removedElement); // Output: ['yellow']
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-access', event)">
              accessing & updating elements
            </td>
          </tr>
          <tr id="detail-tag-access" class="expandable-row-content">
            <td>
              <h3>accessing & updating elements</h3>
              <p>In JavaScript, accessing and updating arrays is a fundamental operation that allows developers to manipulate data collections effectively. Arrays use zero-based indexing, which means each element can be accessed by its numerical index, starting from 0 for the first element. For example, given an array `let fruits = ['apple', 'banana', 'cherry'];`, you can access the second element by using `fruits[1]`, which would return `'banana'`. To update an element at a specific index, you simply assign a new value to that index, such as `fruits[1] = 'orange';`, which changes the second element to `'orange'`. This direct access and modification capability make arrays very versatile for a wide range of tasks, including data processing and manipulation. In addition to numeric indices, JavaScript provides various methods for accessing and updating arrays, such as `push()` to add elements to the end, `pop()` to remove the last element, and `splice()` to insert or remove elements at specific positions. By leveraging these array methods, developers can efficiently perform complex operations, such as sorting, filtering, and transforming data, making arrays an essential part of JavaScript programming.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Accessing the first element of an array
let numbers = [10, 20, 30, 40, 50];
console.log(numbers[0]); // Output: 10

// Example 2: Accessing the last element of an array using the length property
console.log(numbers[numbers.length - 1]); // Output: 50

// Example 3: Updating the first element of an array
numbers[0] = 100;
console.log(numbers); // Output: [100, 20, 30, 40, 50]

// Example 4: Updating the last element of an array
numbers[numbers.length - 1] = 500;
console.log(numbers); // Output: [100, 20, 30, 40, 500]

// Example 5: Accessing a middle element of an array
console.log(numbers[2]); // Output: 30

// Example 6: Updating a middle element of an array
numbers[2] = 300;
console.log(numbers); // Output: [100, 20, 300, 40, 500]

// Example 7: Adding a new element at the end of an array
numbers[numbers.length] = 60;
console.log(numbers); // Output: [100, 20, 300, 40, 500, 60]

// Example 8: Adding a new element at a specific index
numbers[6] = 70;
console.log(numbers); // Output: [100, 20, 300, 40, 500, 60, 70]

// Example 9: Accessing an element using a negative index (manually calculated)
console.log(numbers[numbers.length - 2]); // Output: 60

// Example 10: Accessing elements in a loop (read-only)
for (let i = 0; i < numbers.length; i++) {
  console.log(numbers[i]); // Output: 100, 20, 300, 40, 500, 60, 70
}

// Example 11: Updating all elements in a loop
for (let i = 0; i < numbers.length; i++) {
  numbers[i] *= 2; // Doubling each element
}
console.log(numbers); // Output: [200, 40, 600, 80, 1000, 120, 140]

// Example 12: Resetting an entire array
numbers = [1, 2, 3, 4, 5];
console.log(numbers); // Output: [1, 2, 3, 4, 5]
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-arrayvar', event)">
              let & const for arrays
            </td>
          </tr>
          <tr id="detail-tag-arrayvar" class="expandable-row-content">
            <td>
              <h3>let & const for arrays</h3>
              <p>In JavaScript, the use of `let` and `const` for arrays involves specific considerations related to variable scope and mutability. Both `let` and `const` are block-scoped, meaning they are accessible only within the block where they are declared, unlike `var`, which is function-scoped. When using `let` to declare an array, you can reassign the entire array to a new array later, allowing for flexibility in scenarios where the reference to the array itself may need to change. In contrast, `const` is used to declare arrays when you want to ensure that the reference to the array remains constant and cannot be reassigned. However, it is important to note that `const` does not make the array immutable; the contents of the array can still be modified, meaning you can add, remove, or change elements within the array. This distinction is crucial because it highlights that `const` only prevents reassignment of the variable itself, not the modification of the array's content. This behavior makes `const` ideal for situations where the array structure is intended to remain consistent throughout the code's execution, thereby reducing the risk of accidental reassignment and enhancing code reliability and clarity.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Declaring an array with let and modifying an element
let numbers = [1, 2, 3];
numbers[0] = 10; // Modifying the first element
console.log(numbers); // Output: [10, 2, 3]

// Example 2: Reassigning an array declared with let
numbers = [4, 5, 6]; // Reassigning to a new array
console.log(numbers); // Output: [4, 5, 6]

// Example 3: Declaring an array with const and modifying an element
const fruits = ['apple', 'banana', 'cherry'];
fruits[1] = 'orange'; // Modifying the second element
console.log(fruits); // Output: ['apple', 'orange', 'cherry']

// Example 4: Attempting to reassign a const array (will throw an error)
try {
    fruits = ['kiwi', 'mango']; // Attempting to reassign the entire array
} catch (error) {
    console.log(error.message); // Output: Assignment to constant variable.
}

// Example 5: Adding an element to a let array
let animals = ['dog', 'cat'];
animals[2] = 'rabbit'; // Adding a new element at index 2
console.log(animals); // Output: ['dog', 'cat', 'rabbit']

// Example 6: Adding an element to a const array
const cities = ['New York', 'Los Angeles'];
cities[2] = 'Chicago'; // Adding a new element at index 2
console.log(cities); // Output: ['New York', 'Los Angeles', 'Chicago']

// Example 7: Removing an element from a let array
let colors = ['red', 'green', 'blue'];
colors[2] = undefined; // Removing the element at index 2
console.log(colors); // Output: ['red', 'green', undefined]

// Example 8: Removing an element from a const array
const shapes = ['circle', 'square', 'triangle'];
shapes[2] = null; // Removing the element at index 2 (set to null for clarity)
console.log(shapes); // Output: ['circle', 'square', null]

// Example 9: Let allows for reassignment, replacing the array entirely
let scores = [10, 20, 30];
scores = [100, 200]; // Replacing with a new array
console.log(scores); // Output: [100, 200]

// Example 10: Const does not allow for reassignment of the entire array
const points = [5, 10, 15];
try {
    points = [50, 100]; // Attempting to reassign will throw an error
} catch (error) {
    console.log(error.message); // Output: Assignment to constant variable.
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-length', event)">
              .length property
            </td>
          </tr>
          <tr id="detail-tag-length" class="expandable-row-content">
            <td>
              <h3>.length property</h3>
              <p>The `.length` property in JavaScript arrays is a built-in property that returns or sets the number of elements in an array. It provides a simple way to determine the size of an array, which is particularly useful for iterating over elements, performing operations based on the array's size, or dynamically managing data collections. The value of `.length` is always one greater than the highest index in the array because arrays in JavaScript are zero-based. Interestingly, the `.length` property is mutable, meaning it can be set explicitly to change the size of the array. For example, setting `.length` to a smaller value than the current length truncates the array, removing elements from the end, while setting it to a larger value than the current length adds undefined elements to the array, effectively expanding it. This ability to adjust the length makes the `.length` property a powerful tool for managing arrays efficiently. However, it's important to note that while `.length` provides a count of elements, it does not account for any undefined or empty slots in sparse arrays, which can lead to situations where the reported length doesn't correspond to the number of initialized elements. Overall, the `.length` property is a fundamental feature in JavaScript that plays a critical role in array manipulation and management.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Accessing the length of an array
let fruits = ['apple', 'banana', 'cherry'];
console.log(fruits.length); // Output: 3

// Example 2: Using length to iterate over an array
let colors = ['red', 'green', 'blue', 'yellow'];
for (let i = 0; i < colors.length; i++) {
  console.log(colors[i]); // Output: 'red', 'green', 'blue', 'yellow'
}

// Example 3: Truncating an array by setting a smaller length
let animals = ['dog', 'cat', 'rabbit', 'elephant'];
animals.length = 2; // Truncate to the first two elements
console.log(animals); // Output: ['dog', 'cat']

// Example 4: Extending an array by setting a larger length
let numbers = [1, 2, 3];
numbers.length = 5; // Extend with undefined elements
console.log(numbers); // Output: [1, 2, 3, <2 empty items>]

// Example 5: Adding an element at the end using length
let cities = ['New York', 'Los Angeles'];
cities[cities.length] = 'Chicago'; // Add element at the next available index
console.log(cities); // Output: ['New York', 'Los Angeles', 'Chicago']

// Example 6: Removing the last element using length
let sports = ['soccer', 'basketball', 'tennis'];
sports.length = sports.length - 1; // Remove the last element
console.log(sports); // Output: ['soccer', 'basketball']

// Example 7: Creating an empty array by setting length to zero
let flowers = ['rose', 'tulip', 'daisy'];
flowers.length = 0; // Clear the entire array
console.log(flowers); // Output: []

// Example 8: Using length to find the index of the last element
let cars = ['Toyota', 'Honda', 'Ford', 'BMW'];
let lastIndex = cars.length - 1; // Calculate the index of the last element
console.log(cars[lastIndex]); // Output: 'BMW'
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-ainf', event)">
              scope of arrays in functions
            </td>
          </tr>
          <tr id="detail-tag-ainf" class="expandable-row-content">
            <td>
              <h3>scope of arrays in functions</h3>
              <p>In JavaScript, the scope of arrays within functions is governed by the principles of variable scope and how they are declared. Arrays declared inside a function using `var` are function-scoped, meaning they are accessible only within that function and are not available outside of it. If arrays are declared with `let` or `const` inside a function, they are block-scoped, which means they are confined to the block they are declared in, but within the same function, they act similarly to `var` regarding overall function scope. This encapsulation ensures that the array cannot be accessed or modified outside of its intended context, preventing potential conflicts and unintended side effects in larger codebases. When arrays are declared outside of functions and then accessed within, they fall under the category of global scope, unless a function redefines them with a local declaration. Passing arrays as arguments into functions does not alter their scope; the function simply receives a reference to the original array. This reference allows the function to modify the array's content, reflecting changes in the global or parent scope unless reassigned locally within the function. Thus, understanding how arrays interact with function scope is crucial for effective data manipulation and avoiding common pitfalls related to variable scope, such as accidental overwrites or unintended global state mutations.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Function-scoped array with var
function arrayWithVar() {
    var fruits = ['apple', 'banana', 'cherry'];
    console.log(fruits); // Output: ['apple', 'banana', 'cherry']
}
arrayWithVar();
// console.log(fruits); // ReferenceError: fruits is not defined

// Example 2: Block-scoped array with let
function arrayWithLet() {
    if (true) {
        let vegetables = ['carrot', 'broccoli', 'lettuce'];
        console.log(vegetables); // Output: ['carrot', 'broccoli', 'lettuce']
    }
    // console.log(vegetables); // ReferenceError: vegetables is not defined
}
arrayWithLet();

// Example 3: Block-scoped array with const
function arrayWithConst() {
    const animals = ['dog', 'cat', 'rabbit'];
    console.log(animals); // Output: ['dog', 'cat', 'rabbit']
    if (true) {
        const birds = ['sparrow', 'eagle'];
        console.log(birds); // Output: ['sparrow', 'eagle']
    }
    // console.log(birds); // ReferenceError: birds is not defined
}
arrayWithConst();

// Example 4: Global array accessed in a function
let colors = ['red', 'green', 'blue'];
function modifyColors() {
    colors.push('yellow');
    console.log(colors); // Output: ['red', 'green', 'blue', 'yellow']
}
modifyColors();
console.log(colors); // Output: ['red', 'green', 'blue', 'yellow']

// Example 5: Local array shadows global array
let numbers = [1, 2, 3];
function shadowGlobalArray() {
    let numbers = [4, 5, 6];
    console.log(numbers); // Output: [4, 5, 6]
}
shadowGlobalArray();
console.log(numbers); // Output: [1, 2, 3]

// Example 6: Modifying a global array inside a function
let scores = [10, 20, 30];
function updateScores() {
    for (let i = 0; i < scores.length; i++) {
        scores[i] += 10;
    }
    console.log(scores); // Output: [20, 30, 40]
}
updateScores();
console.log(scores); // Output: [20, 30, 40]

// Example 7: Passing an array as a function argument
function addElement(arr) {
    arr.push('newElement');
    console.log(arr); // Output will depend on the passed array
}
let items = ['item1', 'item2'];
addElement(items); // Output: ['item1', 'item2', 'newElement']
console.log(items); // Output: ['item1', 'item2', 'newElement']

// Example 8: Returning an array from a function
function createArray() {
    let newArray = ['a', 'b', 'c'];
    return newArray;
}
let returnedArray = createArray();
console.log(returnedArray); // Output: ['a', 'b', 'c']
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-nested', event)">
              nested arrays
            </td>
          </tr>
          <tr id="detail-tag-nested" class="expandable-row-content">
            <td>
              <h3>nested arrays</h3>
              <p>Nested arrays in JavaScript, often referred to as multidimensional arrays, are arrays that contain other arrays as their elements. This structure allows developers to create complex data models, such as matrices, grids, or any hierarchical data that require multiple levels of grouping. Each element in a nested array can be accessed using a pair of indices: the first index specifies the outer array, and the second index specifies the element within the nested array. For example, in a two-dimensional array `let matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];`, `matrix[1][2]` would access the element `6`. Nested arrays provide a flexible way to handle data that is naturally organized in layers, such as a table with rows and columns. However, working with nested arrays can become complex as the number of dimensions increases, requiring careful index management to navigate through the levels. JavaScript offers various methods to manipulate nested arrays, such as `.map()`, `.reduce()`, and `.forEach()`, allowing developers to iterate and transform data effectively. Despite the complexity, nested arrays are invaluable for representing and processing structured data, making them an essential concept in JavaScript programming for handling multi-level data scenarios.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Creating a simple nested array
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];
console.log(matrix); // Output: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

// Example 2: Accessing elements in a nested array
let element = matrix[1][2];
console.log(element); // Output: 6 (second row, third column)

// Example 3: Modifying an element in a nested array
matrix[2][1] = 10;
console.log(matrix); // Output: [[1, 2, 3], [4, 5, 6], [7, 10, 9]]

// Example 4: Iterating over a nested array with nested loops
for (let i = 0; i < matrix.length; i++) {
    for (let j = 0; j < matrix[i].length; j++) {
        console.log(matrix[i][j]); // Output: 1, 2, 3, 4, 5, 6, 7, 10, 9
    }
}

// Example 5: Creating a 3D array
let cube = [
    [
        [1, 2], [3, 4]
    ],
    [
        [5, 6], [7, 8]
    ]
];
console.log(cube[1][0][1]); // Output: 6 (second block, first row, second column)

// Example 6: Using nested arrays to represent a tic-tac-toe board
let ticTacToeBoard = [
    ['X', 'O', 'X'],
    ['O', 'X', 'O'],
    ['X', 'O', 'X']
];
console.log(ticTacToeBoard[0][1]); // Output: 'O' (first row, second column)

// Example 7: Flattening a nested array
let nested = [[1, 2], [3, 4], [5, 6]];
let flat = nested.reduce((acc, curr) => acc.concat(curr), []);
console.log(flat); // Output: [1, 2, 3, 4, 5, 6]

// Example 8: Nesting arrays with mixed data types
let mixedNested = [
    [1, 'a', true],
    [2, 'b', false],
    [3, 'c', true]
];
console.log(mixedNested[1][2]); // Output: false (second row, third column)

// Example 9: Adding a new row to a nested array
let newRow = [10, 11, 12];
matrix.push(newRow);
console.log(matrix); // Output: [[1, 2, 3], [4, 5, 6], [7, 10, 9], [10, 11, 12]]

// Example 10: Removing a specific element from a nested array
let removedElement = matrix[0].pop(); // Removes the last element of the first row
console.log(removedElement); // Output: 3
console.log(matrix); // Output: [[1, 2], [4, 5, 6], [7, 10, 9], [10, 11, 12]]
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td id="array-access" class="tableletters">Array Access/Inspection Methods</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-at', event)" >.at() method</td>
          </tr>
          <tr id="detail-tag-at" class="expandable-row-content">
            <td>
              <h3>.at() method</h3>
              <p>The `at()` method in JavaScript provides a way to access elements of an array using a specific index, including negative indices, which count from the end of the array. Unlike traditional bracket notation, where negative numbers are treated as non-existent, `at()` allows you to easily retrieve elements from the end of an array. For instance, `array.at(-1)` would return the last element. This method enhances code readability and reduces errors in accessing elements near the ends of arrays, especially in contexts where the array length might not be known beforehand.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Accessing the first element
const array1 = [10, 20, 30];
console.log(array1.at(0)); // Output: 10

// 2. Accessing the last element using a negative index
console.log(array1.at(-1)); // Output: 30

// 3. Accessing the second-to-last element
console.log(array1.at(-2)); // Output: 20

// 4. Using .at() on an empty array
const emptyArray = [];
console.log(emptyArray.at(0)); // Output: undefined

// 5. Accessing an element beyond the array length
console.log(array1.at(5)); // Output: undefined

// 6. Accessing an element using a negative index greater than array length
console.log(array1.at(-4)); // Output: undefined

// 7. Accessing the first element in a string array
const fruits = ["apple", "banana", "cherry"];
console.log(fruits.at(0)); // Output: "apple"

// 8. Accessing the last character of a string using .at()
const str = "hello";
console.log(str.at(-1)); // Output: "o"

// 9. Using .at() on a TypedArray
const intArray = new Int8Array([1, 2, 3]);
console.log(intArray.at(1)); // Output: 2

// 10. Accessing the first element in an array-like object
const arrayLike = { 0: 'a', 1: 'b', length: 2 };
console.log(Array.prototype.at.call(arrayLike, 0)); // Output: "a"
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-indexof', event)" >.indexOf() method</td>
          </tr>
          <tr id="detail-tag-indexof" class="expandable-row-content">
            <td>
              <h3>.indexOf() method</h3>
              <p>The `.indexOf()` method in JavaScript is used to determine the first occurrence of a specified value within a string or an array, returning the index of that value. If the value is found, the method returns the index (a zero-based integer) where the specified value first appears. If the value is not found, `.indexOf()` returns `-1`. This method is case-sensitive when used on strings, meaning that it distinguishes between uppercase and lowercase characters. Additionally, an optional second parameter can be provided to specify the position in the string or array from which the search should begin. This method is particularly useful for checking the existence and position of elements or substrings, facilitating tasks like validation, search operations, or conditional logic in JavaScript programs.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Find the index of a string in an array of strings
let fruits = ["apple", "banana", "cherry"];
let indexBanana = fruits.indexOf("banana"); // returns 1

// 2. Find the index of a number in an array of numbers
let numbers = [10, 20, 30, 40];
let indexThirty = numbers.indexOf(30); // returns 2

// 3. Case-sensitive search in a string
let phrase = "Hello World";
let indexHello = phrase.indexOf("Hello"); // returns 0

// 4. Search for a substring that is not present
let sentence = "The quick brown fox";
let indexCat = sentence.indexOf("cat"); // returns -1

// 5. Using indexOf to find the first occurrence of a character in a string
let text = "banana";
let indexFirstA = text.indexOf("a"); // returns 1

// 6. Search for an element in an array of objects by string property
let users = [{name: "Alice"}, {name: "Bob"}, {name: "Charlie"}];
let indexBob = users.map(user => user.name).indexOf("Bob"); // returns 1

// 7. Using indexOf to find the index of the first whitespace in a string
let sentenceWithSpaces = "Find the space";
let indexSpace = sentenceWithSpaces.indexOf(" "); // returns 4

// 8. Using indexOf with the second parameter to start search at a specific position
let repeatedText = "ababcabc";
let indexSecondB = repeatedText.indexOf("b", 3); // returns 4

// 9. Find the index of an element in a sparse array
let sparseArray = [1, , , 4, 5];
let indexFour = sparseArray.indexOf(4); // returns 3

// 10. Search for the first occurrence of an array element that exists more than once
let animals = ["dog", "cat", "dog", "bird"];
let indexDog = animals.indexOf("dog"); // returns 0    
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-lastindexof', event)" >.lastIndexOf() method</td>
          </tr>
          <tr id="detail-tag-lastindexof" class="expandable-row-content">
            <td>
              <h3>.lastIndexOf() method</h3>
              <p>The `.lastIndexOf()` method in JavaScript is used to find the last occurrence of a specified value within a string or an array, returning the index of that value. Unlike the `.indexOf()` method, which searches from the beginning, `.lastIndexOf()` searches from the end of the string or array towards the beginning. If the specified value is found, the method returns the index (a zero-based integer) where the value last appears; if the value is not found, it returns `-1`. This method is case-sensitive when dealing with strings, meaning it distinguishes between uppercase and lowercase characters. An optional second parameter can be provided, which indicates the position within the string or array at which to start the search backwards. This method is particularly useful when you need to find the last occurrence of an element or substring, allowing for more flexible search and manipulation operations in JavaScript. </p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Find the last occurrence of a string in an array of strings
let fruits = ["apple", "banana", "cherry", "banana"];
let lastIndexBanana = fruits.lastIndexOf("banana"); // returns 3

// 2. Find the last occurrence of a number in an array of numbers
let numbers = [10, 20, 30, 20, 40];
let lastIndexTwenty = numbers.lastIndexOf(20); // returns 3

// 3. Find the last occurrence of a character in a string
let text = "hello world";
let lastIndexL = text.lastIndexOf("l"); // returns 9

// 4. Search for the last occurrence of a substring that is not present
let sentence = "The quick brown fox";
let lastIndexCat = sentence.lastIndexOf("cat"); // returns -1

// 5. Using lastIndexOf to find the last occurrence of a whitespace in a string
let sentenceWithSpaces = "Find the space";
let lastIndexSpace = sentenceWithSpaces.lastIndexOf(" "); // returns 9

// 6. Using lastIndexOf with a specific starting position
let phrase = "ababcabc";
let lastIndexBBefore3 = phrase.lastIndexOf("b", 3); // returns 1

// 7. Find the last occurrence of an element in a sparse array
let sparseArray = [1, , , 4, 5, 4];
let lastIndexFour = sparseArray.lastIndexOf(4); // returns 5

// 8. Search for the last occurrence of an array element that exists more than once
let animals = ["dog", "cat", "dog", "bird"];
let lastIndexDog = animals.lastIndexOf("dog"); // returns 2

// 9. Using lastIndexOf with an array of mixed data types
let mixedArray = [10, "10", 10, "ten"];
let lastIndexOf10 = mixedArray.lastIndexOf(10); // returns 2

// 10. Find the last occurrence of a substring within a larger string
let longText = "The rain in Spain stays mainly in the plain";
let lastIndexIn = longText.lastIndexOf("in"); // returns 36        
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-includes', event)" >.includes() method</td>
          </tr>
          <tr id="detail-tag-includes" class="expandable-row-content">
            <td>
              <h3>.includes() method</h3>
              <p>The `.includes()` method in JavaScript is used to determine whether a specific value exists within a string or an array, returning a boolean value (`true` or `false`). When used on a string, it checks if a particular substring is present within that string, while in an array, it checks if a particular element is included among the array's elements. The method is case-sensitive for strings, meaning it differentiates between uppercase and lowercase characters. Additionally, an optional second parameter can be provided to specify the index at which the search should start. If the value is found anywhere within the specified portion of the string or array, the method returns `true`; otherwise, it returns `false`. This method is especially useful for quickly checking the presence of a value without needing to know its exact position, making it a convenient tool for validation and conditional logic in JavaScript programming. </p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Check if an array includes a specific string
let fruits = ["apple", "banana", "cherry"];
let includesBanana = fruits.includes("banana"); // returns true

// 2. Check if an array includes a specific number
let numbers = [10, 20, 30, 40];
let includesTwenty = numbers.includes(20); // returns true

// 3. Case-sensitive check for a substring in a string
let phrase = "Hello World";
let includesHello = phrase.includes("Hello"); // returns true

// 4. Check if a string does not include a specific substring
let sentence = "The quick brown fox";
let includesCat = sentence.includes("cat"); // returns false

// 5. Check if an array includes an element, starting the search at a specific index
let colors = ["red", "green", "blue", "green"];
let includesGreenAfter2 = colors.includes("green", 2); // returns true

// 6. Check if an array includes a value in a sparse array
let sparseArray = [1, , , 4, 5];
let includesFour = sparseArray.includes(4); // returns true

// 7. Using includes to check for a boolean value in an array
let boolArray = [true, false, false, true];
let includesTrue = boolArray.includes(true); // returns true

// 8. Check if a string includes a character at a specific position
let word = "javascript";
let includesJAfter3 = word.includes("j", 3); // returns false

// 9. Check if an array includes a NaN value
let mixedArray = [10, "10", NaN, "ten"];
let includesNaN = mixedArray.includes(NaN); // returns true

// 10. Check if an array includes an object reference
let obj1 = {name: "Alice"};
let obj2 = {name: "Bob"};
let objArray = [obj1, obj2];
let includesObj1 = objArray.includes(obj1); // returns true    
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-find', event)" >.find() method</td>
          </tr>
          <tr id="detail-tag-find" class="expandable-row-content">
            <td>
              <h3>.find() method</h3>
              <p>The `.find()` method in JavaScript is used to locate the first element in an array that satisfies a provided testing function, returning the value of that element. If no elements meet the condition specified by the function, the method returns `undefined`. The testing function is executed for each element in the array in index order until a match is found, at which point the search stops. The function itself takes three arguments: the current element being processed, the index of that element, and the array being traversed. The `.find()` method is particularly useful when you need to retrieve a specific item from an array based on a dynamic condition, such as finding an object with a certain property or a number that meets a particular criterion. Unlike methods that return indices, `.find()` returns the actual element, making it a powerful tool for filtering and searching through arrays in JavaScript.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Find the first number greater than 20 in an array
let numbers = [10, 20, 30, 40];
let firstGreaterThanTwenty = numbers.find(num => num > 20); // returns 30

// 2. Find the first even number in an array
let mixedNumbers = [1, 3, 7, 8, 10];
let firstEvenNumber = mixedNumbers.find(num => num % 2 === 0); // returns 8

// 3. Find the first string with length greater than 5
let words = ["apple", "banana", "cherry", "date"];
let longWord = words.find(word => word.length > 5); // returns "banana"

// 4. Find the first object with a specific property value
let users = [
    {name: "Alice", age: 25},
    {name: "Bob", age: 30},
    {name: "Charlie", age: 35}
];
let userBob = users.find(user => user.name === "Bob"); // returns {name: "Bob", age: 30}

// 5. Find the first number less than 10 in a descending sorted array
let descendingNumbers = [50, 40, 30, 20, 10, 5];
let firstLessThanTen = descendingNumbers.find(num => num < 10); // returns 5

// 6. Find the first string that includes a specific substring
let phrases = ["The quick brown fox", "jumps over", "the lazy dog"];
let phraseWithFox = phrases.find(phrase => phrase.includes("fox")); // returns "The quick brown fox"

// 7. Find the first negative number in an array
let mixedValues = [10, -20, 30, -40];
let firstNegative = mixedValues.find(num => num < 0); // returns -20

// 8. Find the first element in an array that is an instance of a specific class
class Car {
    constructor(make, model) {
        this.make = make;
        this.model = model;
    }
}
let vehicles = [
    new Car("Toyota", "Camry"),
    {make: "Ford", model: "F-150"},
    new Car("Honda", "Civic")
];
let firstCar = vehicles.find(vehicle => vehicle instanceof Car); // returns Car {make: "Toyota", model: "Camry"}

// 9. Find the first array element that is greater than 100 in a multi-dimensional array
let multiArray = [[10, 20], [100, 150], [200, 250]];
let firstGreaterThan100 = multiArray.flat().find(num => num > 100); // returns 150

// 10. Find the first element in a string array that starts with a specific letter
let names = ["Alice", "Bob", "Charlie", "David"];
let nameStartingWithC = names.find(name => name.startsWith("C")); // returns "Charlie"     
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-findindex', event)" >.findIndex() method</td>
          </tr>
          <tr id="detail-tag-findindex" class="expandable-row-content">
            <td>
              <h3>.findIndex() method</h3>
              <p>The `.findIndex()` method in JavaScript is used to identify the index of the first element in an array that satisfies a given testing function. It returns the index of this element as a zero-based integer. If no element passes the test, the method returns `-1`. The testing function is applied to each element in the array, starting from the first, and continues until it finds an element that meets the specified condition. The function provided to `.findIndex()` receives three arguments: the current element, its index, and the array itself. This method is particularly useful when you need to know the position of an element that meets certain criteria within an array, such as finding the index of an object with a specific property or identifying the location of a value that matches a particular condition. Unlike `.find()`, which returns the element itself, `.findIndex()` is focused on retrieving the index, making it essential for tasks that require knowledge of an element's position in an array.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Find the index of the first number greater than 20 in an array
let numbers = [10, 20, 30, 40];
let indexGreaterThanTwenty = numbers.findIndex(num => num > 20); // returns 2

// 2. Find the index of the first even number in an array
let mixedNumbers = [1, 3, 7, 8, 10];
let indexFirstEven = mixedNumbers.findIndex(num => num % 2 === 0); // returns 3

// 3. Find the index of the first string with length greater than 5
let words = ["apple", "banana", "cherry", "date"];
let indexLongWord = words.findIndex(word => word.length > 5); // returns 1

// 4. Find the index of the first object with a specific property value
let users = [
    {name: "Alice", age: 25},
    {name: "Bob", age: 30},
    {name: "Charlie", age: 35}
];
let indexBob = users.findIndex(user => user.name === "Bob"); // returns 1

// 5. Find the index of the first number less than 10 in a descending sorted array
let descendingNumbers = [50, 40, 30, 20, 10, 5];
let indexFirstLessThanTen = descendingNumbers.findIndex(num => num < 10); // returns 5

// 6. Find the index of the first string that includes a specific substring
let phrases = ["The quick brown fox", "jumps over", "the lazy dog"];
let indexPhraseWithFox = phrases.findIndex(phrase => phrase.includes("fox")); // returns 0

// 7. Find the index of the first negative number in an array
let mixedValues = [10, -20, 30, -40];
let indexFirstNegative = mixedValues.findIndex(num => num < 0); // returns 1

// 8. Find the index of the first element that is an instance of a specific class
class Car {
    constructor(make, model) {
        this.make = make;
        this.model = model;
    }
}
let vehicles = [
    new Car("Toyota", "Camry"),
    {make: "Ford", model: "F-150"},
    new Car("Honda", "Civic")
];
let indexFirstCar = vehicles.findIndex(vehicle => vehicle instanceof Car); // returns 0

// 9. Find the index of the first array element that is greater than 100 in a multi-dimensional array
let multiArray = [[10, 20], [100, 150], [200, 250]];
let indexFirstGreaterThan100 = multiArray.flat().findIndex(num => num > 100); // returns 3

// 10. Find the index of the first element in a string array that starts with a specific letter
let names = ["Alice", "Bob", "Charlie", "David"];
let indexNameStartingWithC = names.findIndex(name => name.startsWith("C")); // returns 2      
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-findlast', event)" >.findLast() method</td>
          </tr>
          <tr id="detail-tag-findlast" class="expandable-row-content">
            <td>
              <h3>.findLast() method</h3>
              <p>The `.findLast()` method in JavaScript is a relatively newer addition that allows you to locate the last element in an array that satisfies a specified testing function, returning the value of that element. If no elements in the array match the condition set by the testing function, the method returns `undefined`. Unlike the `.find()` method, which searches from the beginning of the array, `.findLast()` searches from the end towards the beginning, making it useful when you need the most recent element that meets a particular criterion. The testing function provided to `.findLast()` is called with three arguments: the current element, its index, and the array itself. This method is particularly useful in scenarios where the most recent or last occurrence of an element matching a condition is more relevant than the first, such as when searching through historical data or logs.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Find the last number greater than 20 in an array
let numbers = [10, 20, 30, 40];
let lastGreaterThanTwenty = numbers.findLast(num => num > 20); // returns 40

// 2. Find the last even number in an array
let mixedNumbers = [1, 3, 7, 8, 10];
let lastEvenNumber = mixedNumbers.findLast(num => num % 2 === 0); // returns 10

// 3. Find the last string with length greater than 5
let words = ["apple", "banana", "cherry", "date"];
let lastLongWord = words.findLast(word => word.length > 5); // returns "banana"

// 4. Find the last object with a specific property value
let users = [
    {name: "Alice", age: 25},
    {name: "Bob", age: 30},
    {name: "Charlie", age: 35},
    {name: "Bob", age: 40}
];
let lastUserBob = users.findLast(user => user.name === "Bob"); // returns {name: "Bob", age: 40}

// 5. Find the last number less than 10 in an array
let mixedNumbers2 = [50, 5, 40, 10, 3];
let lastLessThanTen = mixedNumbers2.findLast(num => num < 10); // returns 3

// 6. Find the last string that includes a specific substring
let phrases = ["The quick brown fox", "jumps over", "the lazy dog", "over the moon"];
let lastPhraseWithOver = phrases.findLast(phrase => phrase.includes("over")); // returns "over the moon"

// 7. Find the last negative number in an array
let mixedValues = [10, -20, 30, -40, 50];
let lastNegative = mixedValues.findLast(num => num < 0); // returns -40

// 8. Find the last element in an array that is an instance of a specific class
class Animal {
    constructor(type) {
        this.type = type;
    }
}
let creatures = [
    new Animal("Dog"),
    {type: "Cat"},
    new Animal("Bird"),
    {type: "Fish"}
];
let lastAnimal = creatures.findLast(creature => creature instanceof Animal); // returns Animal {type: "Bird"}

// 9. Find the last array element that is greater than 100 in a multi-dimensional array
let multiArray = [[10, 20], [100, 150], [200, 250]];
let lastGreaterThan100 = multiArray.flat().findLast(num => num > 100); // returns 250

// 10. Find the last element in a string array that starts with a specific letter
let names = ["Alice", "Bob", "Charlie", "David", "Charles"];
let lastNameStartingWithC = names.findLast(name => name.startsWith("C")); // returns "Charles"   
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-findlastindex', event)" >.findLastIndex() method</td>
          </tr>
          <tr id="detail-tag-findlastindex" class="expandable-row-content">
            <td>
              <h3>.findLastIndex() method</h3>
              <p>The `.findLastIndex()` method in JavaScript is designed to return the index of the last element in an array that satisfies a given testing function. It searches the array from the end towards the beginning, returning the index of the first (in reverse order) element that meets the specified condition. If no such element is found, the method returns `-1`. The testing function passed to `.findLastIndex()` is invoked with three arguments: the current element, its index, and the array itself. This method is particularly useful when the position of the last matching element in an array is needed, such as when dealing with data that is ordered by time or priority, where the latest or most significant occurrence is more relevant. By providing the index of this element, `.findLastIndex()` allows for efficient access and manipulation based on the location of elements that meet specific criteria.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Find the last index of a number greater than 20 in an array
let numbers = [10, 20, 30, 40];
let lastIndexGreaterThanTwenty = numbers.findLastIndex(num => num > 20); // returns 3

// 2. Find the last index of an even number in an array
let mixedNumbers = [1, 3, 7, 8, 10];
let lastIndexEvenNumber = mixedNumbers.findLastIndex(num => num % 2 === 0); // returns 4

// 3. Find the last index of a string with length greater than 5
let words = ["apple", "banana", "cherry", "date"];
let lastIndexLongWord = words.findLastIndex(word => word.length > 5); // returns 1

// 4. Find the last index of an object with a specific property value
let users = [
    {name: "Alice", age: 25},
    {name: "Bob", age: 30},
    {name: "Charlie", age: 35},
    {name: "Bob", age: 40}
];
let lastIndexUserBob = users.findLastIndex(user => user.name === "Bob"); // returns 3

// 5. Find the last index of a number less than 10 in an array
let mixedNumbers2 = [50, 5, 40, 10, 3];
let lastIndexLessThanTen = mixedNumbers2.findLastIndex(num => num < 10); // returns 4

// 6. Find the last index of a string that includes a specific substring
let phrases = ["The quick brown fox", "jumps over", "the lazy dog", "over the moon"];
let lastIndexPhraseWithOver = phrases.findLastIndex(phrase => phrase.includes("over")); // returns 3

// 7. Find the last index of a negative number in an array
let mixedValues = [10, -20, 30, -40, 50];
let lastIndexNegative = mixedValues.findLastIndex(num => num < 0); // returns 3

// 8. Find the last index of an element in an array that is an instance of a specific class
class Animal {
    constructor(type) {
        this.type = type;
    }
}
let creatures = [
    new Animal("Dog"),
    {type: "Cat"},
    new Animal("Bird"),
    {type: "Fish"}
];
let lastIndexAnimal = creatures.findLastIndex(creature => creature instanceof Animal); // returns 2

// 9. Find the last index of an array element that is greater than 100 in a multi-dimensional array
let multiArray = [[10, 20], [100, 150], [200, 250]];
let lastIndexGreaterThan100 = multiArray.flat().findLastIndex(num => num > 100); // returns 5

// 10. Find the last index of an element in a string array that starts with a specific letter
let names = ["Alice", "Bob", "Charlie", "David", "Charles"];
let lastIndexNameStartingWithC = names.findLastIndex(name => name.startsWith("C")); // returns 4 
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-entries', event)" >.entries() method</td>
          </tr>
          <tr id="detail-tag-entries" class="expandable-row-content">
            <td>
              <h3>.entries() method</h3>
              <p>The `.entries()` method in JavaScript is used to create an iterator object that contains key/value pairs for each index in an array. Each key/value pair is represented as an array, where the first element is the index (the key) and the second element is the value at that index. When called on an array, the `.entries()` method returns a new Array Iterator object that can be used in loops or with iteration methods like `for...of` to access both the index and the value simultaneously. This method is particularly useful when you need to process or manipulate both the indices and the values of an array, such as when performing operations that require knowledge of an element's position within the array. By providing a structured way to access both parts, `.entries()` enhances the flexibility and functionality of array iteration in JavaScript.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Get entries of an array of numbers and iterate through them
let numbers = [10, 20, 30];
let entriesNumbers = numbers.entries();
for (let [index, value] of entriesNumbers) {
  console.log(`Index: ${index}, Value: ${value}`);
}
// Output:
// Index: 0, Value: 10
// Index: 1, Value: 20
// Index: 2, Value: 30

// 2. Get entries of a string array
let fruits = ["apple", "banana", "cherry"];
let entriesFruits = fruits.entries();
for (let [index, value] of entriesFruits) {
  console.log(`Index: ${index}, Value: ${value}`);
}
// Output:
// Index: 0, Value: apple
// Index: 1, Value: banana
// Index: 2, Value: cherry

// 3. Get entries of a mixed array (numbers and strings)
let mixedArray = [1, "two", 3];
let entriesMixedArray = mixedArray.entries();
for (let [index, value] of entriesMixedArray) {
  console.log(`Index: ${index}, Value: ${value}`);
}
// Output:
// Index: 0, Value: 1
// Index: 1, Value: two
// Index: 2, Value: 3

// 4. Use entries to iterate over an array of objects
let users = [
  {name: "Alice", age: 25},
  {name: "Bob", age: 30},
  {name: "Charlie", age: 35}
];
let entriesUsers = users.entries();
for (let [index, user] of entriesUsers) {
  console.log(`Index: ${index}, Name: ${user.name}, Age: ${user.age}`);
}
// Output:
// Index: 0, Name: Alice, Age: 25
// Index: 1, Name: Bob, Age: 30
// Index: 2, Name: Charlie, Age: 35

// 5. Use entries to iterate over an array and modify values
let letters = ["a", "b", "c"];
let entriesLetters = letters.entries();
for (let [index, value] of entriesLetters) {
  letters[index] = value.toUpperCase();
}
console.log(letters); // Output: ["A", "B", "C"]

// 6. Get entries of an array with sparse elements
let sparseArray = [10, , 30];
let entriesSparse = sparseArray.entries();
for (let [index, value] of entriesSparse) {
  console.log(`Index: ${index}, Value: ${value}`);
}
// Output:
// Index: 0, Value: 10
// Index: 1, Value: undefined
// Index: 2, Value: 30

// 7. Convert an entries iterator into an array
let colors = ["red", "green", "blue"];
let entriesColors = colors.entries();
let entriesArray = Array.from(entriesColors);
console.log(entriesArray);
// Output: [[0, "red"], [1, "green"], [2, "blue"]]

// 8. Iterate over a nested array using entries
let nestedArray = [["a", "b"], ["c", "d"]];
let entriesNested = nestedArray.entries();
for (let [index, value] of entriesNested) {
  console.log(`Index: ${index}, Value: ${value}`);
}
// Output:
// Index: 0, Value: a,b
// Index: 1, Value: c,d

// 9. Use entries with a for...of loop to iterate through an array of booleans
let boolArray = [true, false, true];
let entriesBoolArray = boolArray.entries();
for (let [index, value] of entriesBoolArray) {
  console.log(`Index: ${index}, Value: ${value}`);
}
// Output:
// Index: 0, Value: true
// Index: 1, Value: false
// Index: 2, Value: true

// 10. Get entries of an array and map them to a new array with modified values
let scores = [100, 200, 300];
let entriesScores = scores.entries();
let modifiedScores = Array.from(entriesScores, ([index, value]) => [index, value + 10]);
console.log(modifiedScores);
// Output: [[0, 110], [1, 210], [2, 310]]  
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-keys', event)" >.keys() method</td>
          </tr>
          <tr id="detail-tag-keys" class="expandable-row-content">
            <td>
              <h3>.keys() method</h3>
              <p>The `.keys()` method in JavaScript is used to create an iterator object that contains the keys (or indices) for each element in an array. When invoked on an array, the method returns a new Array Iterator object that allows you to iterate over the array's indices. This can be particularly useful when you are only interested in the positions of elements within the array, rather than the values themselves. The `.keys()` method is often used in conjunction with looping constructs like `for...of` or in other scenarios where you need to access or manipulate the indices directly, such as when tracking element positions or performing operations that depend on the order of elements. By focusing on the indices alone, `.keys()` provides a streamlined way to work with the structure of an array without involving the array's values.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Get the keys (indices) of an array of numbers and iterate through them
let numbers = [10, 20, 30];
let keysNumbers = numbers.keys();
for (let key of keysNumbers) {
  console.log(`Key: ${key}`);
}
// Output:
// Key: 0
// Key: 1
// Key: 2

// 2. Get the keys of an array of strings
let fruits = ["apple", "banana", "cherry"];
let keysFruits = fruits.keys();
for (let key of keysFruits) {
  console.log(`Key: ${key}`);
}
// Output:
// Key: 0
// Key: 1
// Key: 2

// 3. Get the keys of a mixed array (numbers and strings)
let mixedArray = [1, "two", 3];
let keysMixedArray = mixedArray.keys();
for (let key of keysMixedArray) {
  console.log(`Key: ${key}`);
}
// Output:
// Key: 0
// Key: 1
// Key: 2

// 4. Use keys to iterate over the indices of an array of objects
let users = [
  {name: "Alice", age: 25},
  {name: "Bob", age: 30},
  {name: "Charlie", age: 35}
];
let keysUsers = users.keys();
for (let key of keysUsers) {
  console.log(`Key: ${key}`);
}
// Output:
// Key: 0
// Key: 1
// Key: 2

// 5. Use keys to iterate over the indices of a sparse array
let sparseArray = [10, , 30];
let keysSparse = sparseArray.keys();
for (let key of keysSparse) {
  console.log(`Key: ${key}`);
}
// Output:
// Key: 0
// Key: 1
// Key: 2

// 6. Get the keys of an array and convert them to an array using Array.from()
let colors = ["red", "green", "blue"];
let keysColors = colors.keys();
let keysArray = Array.from(keysColors);
console.log(keysArray);
// Output: [0, 1, 2]

// 7. Iterate over the keys of a nested array
let nestedArray = [["a", "b"], ["c", "d"]];
let keysNested = nestedArray.keys();
for (let key of keysNested) {
  console.log(`Key: ${key}`);
}
// Output:
// Key: 0
// Key: 1

// 8. Use keys with a for...of loop to iterate through the indices of an array of booleans
let boolArray = [true, false, true];
let keysBoolArray = boolArray.keys();
for (let key of keysBoolArray) {
  console.log(`Key: ${key}`);
}
// Output:
// Key: 0
// Key: 1
// Key: 2

// 9. Get the keys of an array and map them to a new array of doubled indices
let scores = [100, 200, 300];
let keysScores = scores.keys();
let doubledKeys = Array.from(keysScores, key => key * 2);
console.log(doubledKeys);
// Output: [0, 2, 4]

// 10. Get the keys of an empty array
let emptyArray = [];
let keysEmpty = emptyArray.keys();
for (let key of keysEmpty) {
  console.log(`Key: ${key}`);
}
// Output: (No output as the array is empty)
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-values', event)" >.values() method</td>
          </tr>
          <tr id="detail-tag-values" class="expandable-row-content">
            <td>
              <h3>.values() method</h3>
              <p>The `.values()` method in JavaScript is used to create an iterator object that contains the values for each element in an array. When called on an array, this method returns a new Array Iterator object that can be used to iterate through the array's values in the order they appear. This method is particularly useful when you need to process or examine the values of an array without concern for their corresponding indices. By using `.values()` in conjunction with a `for...of` loop or other iteration constructs, you can efficiently access and manipulate each element's value. This method provides a clear and straightforward way to work with the contents of an array, making it a handy tool for scenarios where the focus is solely on the data within the array, rather than its structure or order.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Get the values of an array of numbers and iterate through them
let numbers = [10, 20, 30];
let valuesNumbers = numbers.values();
for (let value of valuesNumbers) {
  console.log(`Value: ${value}`);
}
// Output:
// Value: 10
// Value: 20
// Value: 30

// 2. Get the values of an array of strings
let fruits = ["apple", "banana", "cherry"];
let valuesFruits = fruits.values();
for (let value of valuesFruits) {
  console.log(`Value: ${value}`);
}
// Output:
// Value: apple
// Value: banana
// Value: cherry

// 3. Get the values of a mixed array (numbers and strings)
let mixedArray = [1, "two", 3];
let valuesMixedArray = mixedArray.values();
for (let value of valuesMixedArray) {
  console.log(`Value: ${value}`);
}
// Output:
// Value: 1
// Value: two
// Value: 3

// 4. Use values to iterate over an array of objects
let users = [
  {name: "Alice", age: 25},
  {name: "Bob", age: 30},
  {name: "Charlie", age: 35}
];
let valuesUsers = users.values();
for (let value of valuesUsers) {
  console.log(`Name: ${value.name}, Age: ${value.age}`);
}
// Output:
// Name: Alice, Age: 25
// Name: Bob, Age: 30
// Name: Charlie, Age: 35

// 5. Use values to iterate over a sparse array
let sparseArray = [10, , 30];
let valuesSparse = sparseArray.values();
for (let value of valuesSparse) {
  console.log(`Value: ${value}`);
}
// Output:
// Value: 10
// Value: undefined
// Value: 30

// 6. Get the values of an array and convert them to an array using Array.from()
let colors = ["red", "green", "blue"];
let valuesColors = colors.values();
let valuesArray = Array.from(valuesColors);
console.log(valuesArray);
// Output: ["red", "green", "blue"]

// 7. Iterate over the values of a nested array
let nestedArray = [["a", "b"], ["c", "d"]];
let valuesNested = nestedArray.values();
for (let value of valuesNested) {
  console.log(`Value: ${value}`);
}
// Output:
// Value: a,b
// Value: c,d

// 8. Use values with a for...of loop to iterate through the values of an array of booleans
let boolArray = [true, false, true];
let valuesBoolArray = boolArray.values();
for (let value of valuesBoolArray) {
  console.log(`Value: ${value}`);
}
// Output:
// Value: true
// Value: false
// Value: true

// 9. Get the values of an array and map them to a new array of doubled values
let scores = [100, 200, 300];
let valuesScores = scores.values();
let doubledValues = Array.from(valuesScores, value => value * 2);
console.log(doubledValues);
// Output: [200, 400, 600]

// 10. Get the values of an empty array
let emptyArray = [];
let valuesEmpty = emptyArray.values();
for (let value of valuesEmpty) {
  console.log(`Value: ${value}`);
}
// Output: (No output as the array is empty)   
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td id="array-transformation" class="tableletters">Array Transformation Methods</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-concat', event)" >.concat() method</td>
          </tr>
          <tr id="detail-tag-concat" class="expandable-row-content">
            <td>
              <h3>.concat() method</h3>
              <p>The `.concat()` method in JavaScript is used to merge two or more arrays into a single new array. When called on an array, the method takes one or more arrays or values as arguments and appends them to the end of the original array, creating a new array that contains all the elements from the original and the provided arrays or values in the order they were passed. Importantly, `.concat()` does not alter the original array but instead returns a new array with the combined elements, ensuring that the original data remains unchanged. This method is particularly useful for combining datasets, adding elements to an array without mutating the original, or creating a composite array from multiple sources. Because `.concat()` can accept both arrays and individual values as arguments, it provides a flexible and powerful way to build and manipulate arrays in JavaScript.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Concatenate two arrays of numbers
let array1 = [1, 2, 3];
let array2 = [4, 5, 6];
let concatenatedArray = array1.concat(array2);
console.log(concatenatedArray); 
// Output: [1, 2, 3, 4, 5, 6]

// 2. Concatenate multiple arrays of strings
let fruits1 = ["apple", "banana"];
let fruits2 = ["cherry", "date"];
let fruits3 = ["elderberry", "fig"];
let allFruits = fruits1.concat(fruits2, fruits3);
console.log(allFruits); 
// Output: ["apple", "banana", "cherry", "date", "elderberry", "fig"]

// 3. Concatenate an array with additional elements
let numbers = [10, 20, 30];
let moreNumbers = numbers.concat(40, 50);
console.log(moreNumbers); 
// Output: [10, 20, 30, 40, 50]

// 4. Concatenate nested arrays
let nestedArray1 = [[1], [2]];
let nestedArray2 = [[3], [4]];
let concatenatedNestedArray = nestedArray1.concat(nestedArray2);
console.log(concatenatedNestedArray); 
// Output: [[1], [2], [3], [4]]

// 5. Concatenate arrays with different types of elements
let mixedArray1 = [1, "two"];
let mixedArray2 = [true, {name: "Alice"}];
let concatenatedMixedArray = mixedArray1.concat(mixedArray2);
console.log(concatenatedMixedArray); 
// Output: [1, "two", true, {name: "Alice"}]

// 6. Concatenate arrays with empty arrays
let arrayWithEmpty = [1, 2, 3];
let emptyArray = [];
let resultArray = arrayWithEmpty.concat(emptyArray);
console.log(resultArray); 
// Output: [1, 2, 3]

// 7. Concatenate an array with itself
let letters = ["a", "b", "c"];
let repeatedLetters = letters.concat(letters);
console.log(repeatedLetters); 
// Output: ["a", "b", "c", "a", "b", "c"]

// 8. Concatenate arrays and non-array values
let values = [100, 200];
let moreValues = values.concat(300, [400, 500]);
console.log(moreValues); 
// Output: [100, 200, 300, 400, 500]

// 9. Concatenate arrays with undefined values
let numbersWithUndefined = [1, 2, undefined];
let moreNumbersWithUndefined = [undefined, 3, 4];
let concatenatedWithUndefined = numbersWithUndefined.concat(moreNumbersWithUndefined);
console.log(concatenatedWithUndefined); 
// Output: [1, 2, undefined, undefined, 3, 4]

// 10. Concatenate arrays of objects
let objects1 = [{name: "Alice"}, {name: "Bob"}];
let objects2 = [{name: "Charlie"}, {name: "David"}];
let concatenatedObjects = objects1.concat(objects2);
console.log(concatenatedObjects); 
// Output: [{name: "Alice"}, {name: "Bob"}, {name: "Charlie"}, {name: "David"}]  
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-copywithin', event)" >.copyWithin() method</td>
          </tr>
          <tr id="detail-tag-copywithin" class="expandable-row-content">
            <td>
              <h3>.copyWithin() method</h3>
              <p>The `.copyWithin()` method in JavaScript is used to shallowly copy a portion of an array to another location within the same array, modifying the array in place. This method takes three arguments: the target index where the copy will begin, the start index of the source data to be copied, and an optional end index which specifies the end of the source data (the end index is non-inclusive). If the end index is not provided, it defaults to the length of the array. The method does not add any new elements but rather overwrites existing ones with the copied values. Since `.copyWithin()` modifies the array directly, it can be useful for rearranging elements within an array quickly without the need for additional memory or new arrays. However, because it mutates the original array, it should be used with care when the preservation of the original array structure is important.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Copy elements within the same array (starting from index 0 to index 2) to index 3
let array1 = [1, 2, 3, 4, 5];
array1.copyWithin(3, 0, 2);
console.log(array1); 
// Output: [1, 2, 3, 1, 2]

// 2. Copy elements to the beginning of the array
let array2 = [10, 20, 30, 40, 50];
array2.copyWithin(0, 3);
console.log(array2); 
// Output: [40, 50, 30, 40, 50]

// 3. Copy elements to a specific index in the array
let array3 = ["a", "b", "c", "d", "e"];
array3.copyWithin(1, 3, 4);
console.log(array3); 
// Output: ["a", "d", "c", "d", "e"]

// 4. Copy elements within the array using negative indices
let array4 = [1, 2, 3, 4, 5];
array4.copyWithin(-2, 0, 2);
console.log(array4); 
// Output: [1, 2, 3, 1, 2]

// 5. Copy the entire array starting from index 2 to the start of the array
let array5 = ["x", "y", "z"];
array5.copyWithin(0, 2);
console.log(array5); 
// Output: ["z", "y", "z"]

// 6. Copy a part of the array to overwrite itself
let array6 = [1, 2, 3, 4, 5];
array6.copyWithin(2, 1, 4);
console.log(array6); 
// Output: [1, 2, 2, 3, 4]

// 7. Copy elements to the same position (no changes to the array)
let array7 = [10, 20, 30, 40];
array7.copyWithin(1, 1);
console.log(array7); 
// Output: [10, 20, 30, 40]

// 8. Use copyWithin with no end parameter (copies from index 2 to end)
let array8 = ["a", "b", "c", "d"];
array8.copyWithin(1, 2);
console.log(array8); 
// Output: ["a", "c", "d", "d"]

// 9. Copy the first two elements to the end of the array
let array9 = [5, 10, 15, 20];
array9.copyWithin(-2, 0, 2);
console.log(array9); 
// Output: [5, 10, 5, 10]

// 10. Copy elements within an array of objects
let array10 = [{a: 1}, {b: 2}, {c: 3}, {d: 4}];
array10.copyWithin(2, 0, 2);
console.log(array10); 
// Output: [{a: 1}, {b: 2}, {a: 1}, {b: 2}]
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-fill', event)" >.fill() method</td>
          </tr>
          <tr id="detail-tag-fill" class="expandable-row-content">
            <td>
              <h3>.fill() method</h3>
              <p>The `.fill()` method in JavaScript is used to replace all or part of the elements in an array with a static value, modifying the array in place. This method allows you to specify a value that will be used to fill the array and can target specific portions of the array by providing optional start and end indices. The start index determines where the filling begins, and the end index (non-inclusive) determines where it stops. If no start and end indices are provided, the entire array is filled with the specified value. The `.fill()` method is particularly useful for quickly populating an array with a single value, resetting array elements, or initializing arrays with a default value. Since `.fill()` changes the original array, it’s important to use it in contexts where mutating the array is desired, as it does not create a new array but directly alters the existing one.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Fill the entire array with a single value
let array1 = [1, 2, 3, 4, 5];
array1.fill(0);
console.log(array1); 
// Output: [0, 0, 0, 0, 0]

// 2. Fill the array with a value starting from a specific index
let array2 = [1, 2, 3, 4, 5];
array2.fill(9, 2);
console.log(array2); 
// Output: [1, 2, 9, 9, 9]

// 3. Fill the array with a value between two specific indices
let array3 = [1, 2, 3, 4, 5];
array3.fill(7, 1, 3);
console.log(array3); 
// Output: [1, 7, 7, 4, 5]

// 4. Fill the array with a string value
let array4 = [1, 2, 3, 4, 5];
array4.fill("x");
console.log(array4); 
// Output: ["x", "x", "x", "x", "x"]

// 5. Fill the array with an object reference
let array5 = [1, 2, 3];
array5.fill({a: 1});
console.log(array5); 
// Output: [{a: 1}, {a: 1}, {a: 1}]

// 6. Fill only the last two elements of the array
let array6 = [1, 2, 3, 4, 5];
array6.fill(8, -2);
console.log(array6); 
// Output: [1, 2, 3, 8, 8]

// 7. Fill the array using a negative start index and end index
let array7 = [1, 2, 3, 4, 5];
array7.fill(6, -3, -1);
console.log(array7); 
// Output: [1, 2, 6, 6, 5]

// 8. Fill a sparse array
let array8 = new Array(5);
array8.fill(4);
console.log(array8); 
// Output: [4, 4, 4, 4, 4]

// 9. Fill the array with boolean values
let array9 = [0, 1, 2, 3];
array9.fill(true, 1, 3);
console.log(array9); 
// Output: [0, true, true, 3]

// 10. Fill an array with null values
let array10 = [5, 10, 15, 20];
array10.fill(null);
console.log(array10); 
// Output: [null, null, null, null]   
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-filter', event)" >.filter() method</td>
          </tr>
          <tr id="detail-tag-filter" class="expandable-row-content">
            <td>
              <h3>.filter() method</h3>
              <p>The `.filter()` method in JavaScript is used to create a new array containing all the elements of an existing array that meet a specified condition, leaving the original array unchanged. This method takes a callback function as an argument, which is applied to each element of the array. The callback function returns a boolean value—`true` for elements that should be included in the new array and `false` for those that should be excluded. The `.filter()` method is particularly powerful for extracting a subset of data from an array based on specific criteria, such as filtering out unwanted items, selecting elements that match a certain property, or processing arrays in a way that removes irrelevant data. Since `.filter()` does not modify the original array but instead returns a new array with only the elements that pass the test, it is a safe and effective tool for refining and manipulating data sets in JavaScript.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Filter out numbers greater than 10
let numbers = [5, 10, 15, 20];
let filteredNumbers = numbers.filter(num => num > 10);
console.log(filteredNumbers); 
// Output: [15, 20]

// 2. Filter out odd numbers
let mixedNumbers = [1, 2, 3, 4, 5];
let evenNumbers = mixedNumbers.filter(num => num % 2 === 0);
console.log(evenNumbers); 
// Output: [2, 4]

// 3. Filter strings with length greater than 3
let strings = ["a", "abc", "abcd", "abcde"];
let longStrings = strings.filter(str => str.length > 3);
console.log(longStrings); 
// Output: ["abcd", "abcde"]

// 4. Filter out falsy values from an array
let values = [0, "hello", false, 42, "", null];
let truthyValues = values.filter(Boolean);
console.log(truthyValues); 
// Output: ["hello", 42]

// 5. Filter an array of objects by a property value
let users = [
    {name: "Alice", age: 25},
    {name: "Bob", age: 20},
    {name: "Charlie", age: 30}
];
let adults = users.filter(user => user.age >= 21);
console.log(adults); 
// Output: [{name: "Alice", age: 25}, {name: "Charlie", age: 30}]

// 6. Filter elements in an array that are strings
let mixedArray = [1, "two", 3, "four", 5];
let stringsOnly = mixedArray.filter(item => typeof item === "string");
console.log(stringsOnly); 
// Output: ["two", "four"]

// 7. Filter array elements that contain a specific substring
let phrases = ["apple pie", "banana split", "cherry tart"];
let withApple = phrases.filter(phrase => phrase.includes("apple"));
console.log(withApple); 
// Output: ["apple pie"]

// 8. Filter elements that are instances of a specific class
class Animal {
    constructor(name) {
        this.name = name;
    }
}
let animals = [new Animal("Dog"), {type: "Cat"}, new Animal("Bird")];
let onlyAnimals = animals.filter(item => item instanceof Animal);
console.log(onlyAnimals); 
// Output: [Animal {name: "Dog"}, Animal {name: "Bird"}]

// 9. Filter numbers in an array that are prime
let primes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].filter(num => {
    for (let i = 2; i < num; i++) {
        if (num % i === 0) return false;
    }
    return num > 1;
});
console.log(primes); 
// Output: [2, 3, 5, 7]

// 10. Filter an array of nested arrays to only include arrays with a specific length
let nestedArrays = [[1, 2], [3, 4, 5], [6]];
let lengthTwo = nestedArrays.filter(arr => arr.length === 2);
console.log(lengthTwo); 
// Output: [[1, 2]]
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-map', event)" >.map() method</td>
          </tr>
          <tr id="detail-tag-map" class="expandable-row-content">
            <td>
              <h3>.map() method</h3>
              <p>The `.map()` method in JavaScript is used to create a new array by applying a specified function to each element of an existing array. This method takes a callback function as an argument, which is executed on every element in the array, producing a new value for each element. The result is a new array of the same length, with each element transformed according to the logic defined in the callback function. The original array remains unchanged, as `.map()` does not alter the source array but rather generates a new one based on the transformations. This method is particularly useful for scenarios where you need to perform consistent operations on every element of an array, such as converting data formats, computing new values, or extracting specific properties from objects. By providing a flexible and efficient way to transform arrays, `.map()` is a fundamental tool in functional programming within JavaScript.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Double each number in an array
let numbers = [1, 2, 3, 4];
let doubled = numbers.map(num => num * 2);
console.log(doubled); 
// Output: [2, 4, 6, 8]

// 2. Convert an array of strings to uppercase
let strings = ["hello", "world"];
let uppercased = strings.map(str => str.toUpperCase());
console.log(uppercased); 
// Output: ["HELLO", "WORLD"]

// 3. Extract a specific property from an array of objects
let users = [
    {name: "Alice", age: 25},
    {name: "Bob", age: 30},
    {name: "Charlie", age: 35}
];
let names = users.map(user => user.name);
console.log(names); 
// Output: ["Alice", "Bob", "Charlie"]

// 4. Add a suffix to each string in an array
let fruits = ["apple", "banana", "cherry"];
let suffixedFruits = fruits.map(fruit => fruit + " pie");
console.log(suffixedFruits); 
// Output: ["apple pie", "banana pie", "cherry pie"]

// 5. Create an array of object keys as an array of arrays
let objArray = [{a: 1}, {b: 2}, {c: 3}];
let keysArray = objArray.map(obj => Object.keys(obj));
console.log(keysArray); 
// Output: [["a"], ["b"], ["c"]]

// 6. Calculate the square of each number in an array
let nums = [1, 2, 3, 4];
let squares = nums.map(num => num ** 2);
console.log(squares); 
// Output: [1, 4, 9, 16]

// 7. Format an array of numbers as currency strings
let amounts = [100, 200, 300];
let formattedAmounts = amounts.map(amount => `$${amount.toFixed(2)}`);
console.log(formattedAmounts); 
// Output: ["$100.00", "$200.00", "$300.00"]

// 8. Convert an array of boolean values to their opposite
let booleans = [true, false, true, false];
let opposites = booleans.map(bool => !bool);
console.log(opposites); 
// Output: [false, true, false, true]

// 9. Create an array of lengths of strings
let words = ["cat", "elephant", "giraffe"];
let lengths = words.map(word => word.length);
console.log(lengths); 
// Output: [3, 8, 7]

// 10. Generate an array of HTML list items from an array of strings
let items = ["item1", "item2", "item3"];
let htmlListItems = items.map(item => `<li>${item}</li>`);
console.log(htmlListItems); 
// Output: ["<li>item1</li>", "<li>item2</li>", "<li>item3</li>"]       
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-flat', event)" >.flat() method</td>
          </tr>
          <tr id="detail-tag-flat" class="expandable-row-content">
            <td>
              <h3>.flat() method</h3>
              <p>The `.flat()` method in JavaScript is used to create a new array by flattening nested arrays up to a specified depth, effectively reducing the dimensionality of the array structure. When called on an array, `.flat()` returns a new array where sub-arrays are concatenated into the main array, based on the depth level provided as an argument. If no depth is specified, `.flat()` defaults to a depth of 1, meaning it will only flatten one level of nested arrays. For example, it will turn `[1, [2, [3]]]` into `[1, 2, [3]]`. If you provide a greater depth, it will continue flattening deeper levels of nested arrays. This method is particularly useful for simplifying complex, multi-dimensional arrays into more manageable, single-level arrays, especially when dealing with data that has been nested multiple times. By creating a new, flattened array without altering the original, `.flat()` provides a straightforward way to handle and manipulate deeply nested data structures in JavaScript.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Flatten a simple nested array by one level
let array1 = [1, [2, 3], [4, 5]];
let flatArray1 = array1.flat();
console.log(flatArray1); 
// Output: [1, 2, 3, 4, 5]

// 2. Flatten a deeply nested array by one level
let array2 = [1, [2, [3, 4]], 5];
let flatArray2 = array2.flat();
console.log(flatArray2); 
// Output: [1, 2, [3, 4], 5]

// 3. Flatten a deeply nested array completely (using Infinity)
let array3 = [1, [2, [3, [4, 5]]]];
let flatArray3 = array3.flat(Infinity);
console.log(flatArray3); 
// Output: [1, 2, 3, 4, 5]

// 4. Flatten an array with empty slots (sparse array)
let array4 = [1, , 3, [4, 5]];
let flatArray4 = array4.flat();
console.log(flatArray4); 
// Output: [1, 3, 4, 5]

// 5. Flatten an array of arrays and filter out `null` values
let array5 = [[1, 2], [3, null], [4, 5]];
let flatArray5 = array5.flat().filter(x => x !== null);
console.log(flatArray5); 
// Output: [1, 2, 3, 4, 5]

// 6. Flatten a 3-level nested array by two levels
let array6 = [1, [2, [3, 4]], 5];
let flatArray6 = array6.flat(2);
console.log(flatArray6); 
// Output: [1, 2, 3, 4, 5]

// 7. Flatten an array of objects with arrays as properties
let array7 = [{a: [1, 2]}, {b: [3, 4]}, {c: [5]}];
let flatArray7 = array7.map(obj => Object.values(obj).flat());
console.log(flatArray7); 
// Output: [[1, 2], [3, 4], [5]]

// 8. Flatten an array with a mix of strings and nested arrays
let array8 = ["a", ["b", "c"], ["d", ["e", "f"]]];
let flatArray8 = array8.flat(2);
console.log(flatArray8); 
// Output: ["a", "b", "c", "d", "e", "f"]

// 9. Flatten an array containing boolean values and nested arrays
let array9 = [true, [false, [true, false]]];
let flatArray9 = array9.flat(Infinity);
console.log(flatArray9); 
// Output: [true, false, true, false]

// 10. Flatten an array of arrays where each sub-array has different depths
let array10 = [[1, 2, [3]], [[4, 5]], 6];
let flatArray10 = array10.flat(2);
console.log(flatArray10); 
// Output: [1, 2, 3, 4, 5, 6]  
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-flatmap', event)" >.flatMap() method</td>
          </tr>
          <tr id="detail-tag-flatmap" class="expandable-row-content">
            <td>
              <h3>.flatMap() method</h3>
              <p>The `.flatMap()` method in JavaScript is a versatile and powerful array method that combines the operations of `.map()` and `.flat()` into a single step. It first applies a mapping function to each element of the array, which can return an array itself, and then flattens the result by one level. This means that for each element, the mapping function can produce multiple elements that will be included in the final flattened array. The `.flatMap()` method is particularly useful when you need to transform and flatten an array in one go, such as when you want to process an array of strings into an array of words or when dealing with arrays that require both transformation and reduction in nesting. Like `.map()`, it does not modify the original array but instead returns a new array. By combining these two operations efficiently, `.flatMap()` simplifies scenarios where mapping and flattening are commonly needed together, making code cleaner and more concise.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Map each element to an array and flatten the result by one level
let numbers = [1, 2, 3];
let doubledAndFlattened = numbers.flatMap(num => [num, num * 2]);
console.log(doubledAndFlattened);
// Output: [1, 2, 2, 4, 3, 6]

// 2. Split each string in an array into characters and flatten the result
let words = ["hello", "world"];
let chars = words.flatMap(word => word.split(''));
console.log(chars);
// Output: ["h", "e", "l", "l", "o", "w", "o", "r", "l", "d"]

// 3. Map and remove `null` values in a single step
let numbersWithNull = [1, null, 2, null, 3];
let noNulls = numbersWithNull.flatMap(num => num !== null ? [num] : []);
console.log(noNulls);
// Output: [1, 2, 3]

// 4. Map and add extra elements
let nums = [1, 2, 3];
let withExtraZeros = nums.flatMap(num => [num, 0]);
console.log(withExtraZeros);
// Output: [1, 0, 2, 0, 3, 0]

// 5. Flatten an array of arrays and double each number
let arrayOfArrays = [[1, 2], [3, 4], [5, 6]];
let doubledNumbers = arrayOfArrays.flatMap(arr => arr.map(num => num * 2));
console.log(doubledNumbers);
// Output: [2, 4, 6, 8, 10, 12]

// 6. Extract and flatten values from objects within an array
let people = [{name: "Alice", skills: ["JS", "React"]}, {name: "Bob", skills: ["Python", "Django"]}];
let allSkills = people.flatMap(person => person.skills);
console.log(allSkills);
// Output: ["JS", "React", "Python", "Django"]

// 7. Flatten arrays and add indices as extra elements
let items = ["a", "b", "c"];
let itemsWithIndex = items.flatMap((item, index) => [item, index]);
console.log(itemsWithIndex);
// Output: ["a", 0, "b", 1, "c", 2]

// 8. Map and flatten nested objects
let nestedObjects = [{a: {x: 1}}, {b: {y: 2}}, {c: {z: 3}}];
let flattenedObjects = nestedObjects.flatMap(obj => Object.values(obj));
console.log(flattenedObjects);
// Output: [{x: 1}, {y: 2}, {z: 3}]

// 9. Create pairs of elements from two arrays
let arr1 = [1, 2];
let arr2 = ["a", "b"];
let pairs = arr1.flatMap(num => arr2.map(letter => [num, letter]));
console.log(pairs);
// Output: [[1, "a"], [1, "b"], [2, "a"], [2, "b"]]

// 10. Map and flatten numbers by converting them to ranges
let ranges = [1, 4, 7];
let expandedRanges = ranges.flatMap(num => [num, num + 1, num + 2]);
console.log(expandedRanges);
// Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-slice', event)" >.slice() method</td>
          </tr>
          <tr id="detail-tag-slice" class="expandable-row-content">
            <td>
              <h3>.slice() method</h3>
              <p>The `.slice()` method in JavaScript is used to create a shallow copy of a portion of an array or string, without modifying the original array or string. When called on an array or string, it takes two arguments: the start index, which is the beginning of the section to be copied, and the optional end index, which is non-inclusive and defines where the section ends. If the end index is not provided, `.slice()` will include all elements from the start index to the end of the array or string. This method is particularly useful for extracting specific segments, creating sub-arrays or substrings, or duplicating parts of data while leaving the original intact. Since `.slice()` returns a new array or string, it is a non-destructive operation that allows for flexible data manipulation and extraction in JavaScript, making it a valuable tool for working with sequences of elements.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Extract a portion of an array
let numbers = [1, 2, 3, 4, 5];
let slicedNumbers = numbers.slice(1, 4);
console.log(slicedNumbers); 
// Output: [2, 3, 4]

// 2. Slice the first two elements of an array
let fruits = ["apple", "banana", "cherry", "date"];
let firstTwoFruits = fruits.slice(0, 2);
console.log(firstTwoFruits); 
// Output: ["apple", "banana"]

// 3. Slice from a specific index to the end of the array
let letters = ["a", "b", "c", "d", "e"];
let slicedFromC = letters.slice(2);
console.log(slicedFromC); 
// Output: ["c", "d", "e"]

// 4. Slice the last two elements of an array using negative indices
let colors = ["red", "green", "blue", "yellow"];
let lastTwoColors = colors.slice(-2);
console.log(lastTwoColors); 
// Output: ["blue", "yellow"]

// 5. Create a shallow copy of an array using slice
let originalArray = [1, 2, 3];
let copiedArray = originalArray.slice();
console.log(copiedArray); 
// Output: [1, 2, 3]

// 6. Slice an array without the first and last elements
let arrayWithBounds = [10, 20, 30, 40, 50];
let middleElements = arrayWithBounds.slice(1, -1);
console.log(middleElements); 
// Output: [20, 30, 40]

// 7. Slice a string into an array of characters
let str = "JavaScript";
let slicedStr = str.split("").slice(4);
console.log(slicedStr); 
// Output: ["S", "c", "r", "i", "p", "t"]

// 8. Slice a portion of a nested array
let nestedArray = [[1, 2], [3, 4], [5, 6], [7, 8]];
let slicedNested = nestedArray.slice(1, 3);
console.log(slicedNested); 
// Output: [[3, 4], [5, 6]]

// 9. Slice an array of objects based on indices
let users = [
    {name: "Alice", age: 25},
    {name: "Bob", age: 30},
    {name: "Charlie", age: 35},
    {name: "David", age: 40}
];
let slicedUsers = users.slice(1, 3);
console.log(slicedUsers); 
// Output: [{name: "Bob", age: 30}, {name: "Charlie", age: 35}]

// 10. Use slice to reverse a portion of an array
let numArray = [10, 20, 30, 40, 50];
let reversedSlice = numArray.slice(1, 4).reverse();
console.log(reversedSlice); 
// Output: [40, 30, 20]
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-splice', event)" >.splice() method</td>
          </tr>
          <tr id="detail-tag-splice" class="expandable-row-content">
            <td>
              <h3>.splice() method</h3>
              <p>The `.splice()` method in JavaScript is a powerful tool used to modify the contents of an array by adding, removing, or replacing elements. Unlike `.slice()`, which creates a new array without altering the original, `.splice()` directly mutates the original array. The method takes at least two arguments: the start index, where the changes will begin, and the number of elements to be removed. Additional arguments can be provided to specify the elements to be added at the start index. For example, `.splice(2, 1, 'newItem')` would remove one element at index 2 and insert `'newItem'` in its place. The method returns an array containing the removed elements, if any. This versatility makes `.splice()` particularly useful for tasks like inserting elements at specific positions, deleting parts of an array, or replacing elements, allowing for dynamic and flexible array manipulation. However, because it alters the original array, it's important to use `.splice()` carefully when array preservation is necessary.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Remove elements from an array
let numbers = [1, 2, 3, 4, 5];
let removedElements = numbers.splice(2, 2);
console.log(numbers); 
// Output: [1, 2, 5]
console.log(removedElements); 
// Output: [3, 4]

// 2. Add elements to an array
let fruits = ["apple", "banana", "cherry"];
fruits.splice(1, 0, "blueberry", "kiwi");
console.log(fruits); 
// Output: ["apple", "blueberry", "kiwi", "banana", "cherry"]

// 3. Replace elements in an array
let letters = ["a", "b", "c", "d"];
letters.splice(1, 2, "x", "y");
console.log(letters); 
// Output: ["a", "x", "y", "d"]

// 4. Remove all elements from a specific index onwards
let colors = ["red", "green", "blue", "yellow"];
colors.splice(2);
console.log(colors); 
// Output: ["red", "green"]

// 5. Insert elements at the beginning of an array
let numbers2 = [4, 5, 6];
numbers2.splice(0, 0, 1, 2, 3);
console.log(numbers2); 
// Output: [1, 2, 3, 4, 5, 6]

// 6. Remove the first element from an array
let animals = ["cat", "dog", "rabbit"];
animals.splice(0, 1);
console.log(animals); 
// Output: ["dog", "rabbit"]

// 7. Remove and replace all elements in an array
let items = ["item1", "item2", "item3"];
items.splice(0, items.length, "newItem1", "newItem2");
console.log(items); 
// Output: ["newItem1", "newItem2"]

// 8. Remove the last element from an array
let numbers3 = [10, 20, 30, 40];
numbers3.splice(-1);
console.log(numbers3); 
// Output: [10, 20, 30]

// 9. Insert elements into an empty array
let emptyArray = [];
emptyArray.splice(0, 0, "first", "second");
console.log(emptyArray); 
// Output: ["first", "second"]

// 10. Replace elements in the middle of an array
let months = ["January", "February", "April", "May"];
months.splice(2, 1, "March");
console.log(months); 
// Output: ["January", "February", "March", "May"]  
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td id="array-iteration" class="tableletters">Array Iteration Methods</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-foreach', event)" >.forEach() method</td>
          </tr>
          <tr id="detail-tag-foreach" class="expandable-row-content">
            <td>
              <h3>.forEach() method</h3>
              <p>The `.forEach()` method in JavaScript is used to execute a provided function once for each element in an array. Unlike some other iteration methods, such as `.map()` or `.filter()`, `.forEach()` does not return a new array or any other value; instead, it simply performs the specified operation on each element of the array in the order they appear. The method takes a callback function as its argument, and this function can access the current element, its index, and the array itself. `.forEach()` is particularly useful for tasks that involve side effects, such as logging, modifying external variables, or interacting with DOM elements, where you need to perform an action for each array item but do not need to transform or filter the array. Because it does not alter the array or produce a new one, `.forEach()` is best suited for scenarios where you are interested in performing an operation on each element without needing a resulting value or array.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Log each element of an array to the console
let numbers = [1, 2, 3, 4, 5];
numbers.forEach(num => console.log(num));
// Output: 1, 2, 3, 4, 5 (each on a new line)

// 2. Calculate the sum of an array
let sum = 0;
numbers.forEach(num => sum += num);
console.log(sum); 
// Output: 15

// 3. Modify each element in an array of objects
let users = [
    {name: "Alice", age: 25},
    {name: "Bob", age: 30},
    {name: "Charlie", age: 35}
];
users.forEach(user => user.age += 1);
console.log(users); 
// Output: [{name: "Alice", age: 26}, {name: "Bob", age: 31}, {name: "Charlie", age: 36}]

// 4. Convert each string in an array to uppercase
let fruits = ["apple", "banana", "cherry"];
fruits.forEach((fruit, index, arr) => arr[index] = fruit.toUpperCase());
console.log(fruits); 
// Output: ["APPLE", "BANANA", "CHERRY"]

// 5. Log the index of each element in an array
let letters = ["a", "b", "c", "d"];
letters.forEach((letter, index) => console.log(`Index: ${index}, Letter: ${letter}`));
// Output: "Index: 0, Letter: a", "Index: 1, Letter: b", "Index: 2, Letter: c", "Index: 3, Letter: d" (each on a new line)

// 6. Append elements to another array
let numbers2 = [10, 20, 30];
let results = [];
numbers2.forEach(num => results.push(num * 2));
console.log(results); 
// Output: [20, 40, 60]

// 7. Count occurrences of a specific value in an array
let items = ["apple", "banana", "apple", "orange", "banana", "apple"];
let count = 0;
items.forEach(item => {
    if (item === "apple") count++;
});
console.log(count); 
// Output: 3

// 8. Add properties to an array of objects
let products = [{name: "Shirt"}, {name: "Pants"}, {name: "Shoes"}];
products.forEach(product => product.price = 20);
console.log(products); 
// Output: [{name: "Shirt", price: 20}, {name: "Pants", price: 20}, {name: "Shoes", price: 20}]

// 9. Chain with other array methods
let numbers3 = [1, 2, 3, 4, 5];
numbers3.filter(num => num > 2).forEach(num => console.log(num));
// Output: 3, 4, 5 (each on a new line)

// 10. Print a message for each item in an array
let animals = ["cat", "dog", "bird"];
animals.forEach(animal => console.log(`I love my ${animal}!`));
// Output: "I love my cat!", "I love my dog!", "I love my bird!" (each on a new line)      
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-every', event)" >.every() method</td>
          </tr>
          <tr id="detail-tag-every" class="expandable-row-content">
            <td>
              <h3>.every() method</h3>
              <p>The `.every()` method in JavaScript is used to test whether all elements in an array pass a specified test implemented by a provided function. This method takes a callback function as an argument, which is executed for each element of the array. If the callback function returns `true` for every element, `.every()` returns `true`; if the function returns `false` for any element, the method immediately returns `false` and stops further iteration. This makes `.every()` particularly useful for validating that all items in an array meet a certain condition, such as checking if all numbers in an array are positive, or if all objects in a list have a required property. Since `.every()` stops evaluating as soon as it encounters a `false` result, it can be efficient for large arrays where a failure condition might occur early. It does not modify the original array and is a valuable tool when a boolean assessment across an entire dataset is needed.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Check if all numbers in an array are greater than 10
let numbers = [12, 15, 20, 25];
let allGreaterThanTen = numbers.every(num => num > 10);
console.log(allGreaterThanTen); 
// Output: true

// 2. Check if all elements in an array are strings
let mixedArray = ["apple", "banana", "cherry"];
let allStrings = mixedArray.every(item => typeof item === "string");
console.log(allStrings); 
// Output: true

// 3. Check if all elements in an array are even numbers
let nums = [2, 4, 6, 8];
let allEven = nums.every(num => num % 2 === 0);
console.log(allEven); 
// Output: true

// 4. Check if all elements in an array are positive
let values = [1, 2, 3, 4, 5];
let allPositive = values.every(num => num > 0);
console.log(allPositive); 
// Output: true

// 5. Check if all elements in an array are objects
let objectsArray = [{}, {}, {}];
let allObjects = objectsArray.every(item => typeof item === "object");
console.log(allObjects); 
// Output: true

// 6. Check if all users in an array are adults (age 18 or older)
let users = [
    {name: "Alice", age: 25},
    {name: "Bob", age: 30},
    {name: "Charlie", age: 35}
];
let allAdults = users.every(user => user.age >= 18);
console.log(allAdults); 
// Output: true

// 7. Check if all elements in an array are less than 100
let numbers2 = [50, 60, 70, 80];
let allLessThanHundred = numbers2.every(num => num < 100);
console.log(allLessThanHundred); 
// Output: true

// 8. Check if all strings in an array have a length greater than 3
let strings = ["hello", "world", "JavaScript"];
let allLongerThanThree = strings.every(str => str.length > 3);
console.log(allLongerThanThree); 
// Output: true

// 9. Check if all elements in an array are truthy
let bools = [true, true, true];
let allTruthy = bools.every(bool => Boolean(bool));
console.log(allTruthy); 
// Output: true

// 10. Check if all elements in an array of arrays have length greater than 2
let nestedArrays = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
let allLengthGreaterThanTwo = nestedArrays.every(arr => arr.length > 2);
console.log(allLengthGreaterThanTwo); 
// Output: true    
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-some', event)" >.some() method</td>
          </tr>
          <tr id="detail-tag-some" class="expandable-row-content">
            <td>
              <h3>.some() method</h3>
              <p>The `.some()` method in JavaScript is used to test whether at least one element in an array passes a specified test implemented by a provided function. This method takes a callback function as an argument, which is executed for each element in the array. If the callback function returns `true` for any one of the elements, `.some()` immediately returns `true` and stops further iteration. If the function returns `false` for all elements, the method returns `false`. This makes `.some()` particularly useful for scenarios where you need to check if any element in an array meets a certain condition, such as determining if any numbers in an array are negative, or if any objects in a list contain a specific property. Since `.some()` stops processing as soon as it finds a matching element, it can be more efficient than methods that need to evaluate every element. Like other array methods, `.some()` does not modify the original array, making it a convenient tool for quick, conditional checks across arrays in JavaScript.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Check if some numbers in an array are greater than 10
let numbers = [5, 8, 12, 3];
let someGreaterThanTen = numbers.some(num => num > 10);
console.log(someGreaterThanTen); 
// Output: true

// 2. Check if some elements in an array are strings
let mixedArray = [1, "banana", 3, 4];
let someStrings = mixedArray.some(item => typeof item === "string");
console.log(someStrings); 
// Output: true

// 3. Check if some elements in an array are odd numbers
let nums = [2, 4, 6, 7];
let someOdd = nums.some(num => num % 2 !== 0);
console.log(someOdd); 
// Output: true

// 4. Check if some elements in an array are negative
let values = [1, -2, 3, -4, 5];
let someNegative = values.some(num => num < 0);
console.log(someNegative); 
// Output: true

// 5. Check if some elements in an array are objects
let objectsArray = [1, "string", {}, 3];
let someObjects = objectsArray.some(item => typeof item === "object");
console.log(someObjects); 
// Output: true

// 6. Check if some users in an array are minors (under 18)
let users = [
    {name: "Alice", age: 25},
    {name: "Bob", age: 17},
    {name: "Charlie", age: 35}
];
let someMinors = users.some(user => user.age < 18);
console.log(someMinors); 
// Output: true

// 7. Check if some elements in an array are greater than 100
let numbers2 = [50, 60, 120, 80];
let someGreaterThanHundred = numbers2.some(num => num > 100);
console.log(someGreaterThanHundred); 
// Output: true

// 8. Check if some strings in an array have a length greater than 5
let strings = ["hello", "world", "JavaScript"];
let someLongerThanFive = strings.some(str => str.length > 5);
console.log(someLongerThanFive); 
// Output: true

// 9. Check if some elements in an array are falsy
let bools = [true, false, true];
let someFalsy = bools.some(bool => !Boolean(bool));
console.log(someFalsy); 
// Output: true

// 10. Check if some elements in a nested array are arrays themselves
let nestedArrays = [1, [2, 3], 4, [5, 6]];
let someArrays = nestedArrays.some(arr => Array.isArray(arr));
console.log(someArrays); 
// Output: true    
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-reduce', event)" >.reduce() method</td>
          </tr>
          <tr id="detail-tag-reduce" class="expandable-row-content">
            <td>
              <h3>.reduce() method</h3>
              <p>The `.reduce()` method in JavaScript is a powerful array method used to accumulate a single value from an array by applying a reducer function to each element, moving through the array from left to right. The method takes two arguments: a callback function (the reducer) and an optional initial value. The reducer function itself takes four arguments: the accumulator (which holds the accumulated result), the current element, the current index, and the array being processed. On each iteration, the reducer function processes the current element and updates the accumulator, which eventually holds the final result after all elements have been processed. If no initial value is provided, `.reduce()` uses the first element of the array as the initial accumulator value and starts the iteration from the second element. The `.reduce()` method is particularly useful for tasks such as summing numbers, concatenating strings, or flattening arrays, where a single output value is derived from the entire array. It is a versatile tool for transforming and combining array data into a single result, making it essential for more complex data processing in JavaScript.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Sum all numbers in an array
let numbers = [1, 2, 3, 4, 5];
let sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(sum); 
// Output: 15

// 2. Multiply all numbers in an array
let product = numbers.reduce((acc, num) => acc * num, 1);
console.log(product); 
// Output: 120

// 3. Find the maximum value in an array
let max = numbers.reduce((acc, num) => (num > acc ? num : acc), numbers[0]);
console.log(max); 
// Output: 5

// 4. Flatten a nested array
let nestedArray = [[1, 2], [3, 4], [5, 6]];
let flatArray = nestedArray.reduce((acc, arr) => acc.concat(arr), []);
console.log(flatArray); 
// Output: [1, 2, 3, 4, 5, 6]

// 5. Count the occurrences of each element in an array
let fruits = ["apple", "banana", "apple", "orange", "banana", "apple"];
let fruitCount = fruits.reduce((acc, fruit) => {
  acc[fruit] = (acc[fruit] || 0) + 1;
  return acc;
}, {});
console.log(fruitCount); 
// Output: {apple: 3, banana: 2, orange: 1}

// 6. Create an object from an array of key-value pairs
let keyValuePairs = [["name", "Alice"], ["age", 25], ["city", "Wonderland"]];
let obj = keyValuePairs.reduce((acc, [key, value]) => {
  acc[key] = value;
  return acc;
}, {});
console.log(obj); 
// Output: {name: "Alice", age: 25, city: "Wonderland"}

// 7. Calculate the total price of items in a shopping cart
let cart = [
  {name: "Shirt", price: 20},
  {name: "Pants", price: 30},
  {name: "Shoes", price: 50}
];
let totalPrice = cart.reduce((acc, item) => acc + item.price, 0);
console.log(totalPrice); 
// Output: 100

// 8. Group objects by a property
let people = [
  {name: "Alice", age: 25},
  {name: "Bob", age: 30},
  {name: "Charlie", age: 25}
];
let groupedByAge = people.reduce((acc, person) => {
  if (!acc[person.age]) {
    acc[person.age] = [];
  }
  acc[person.age].push(person);
  return acc;
}, {});
console.log(groupedByAge); 
// Output: {25: [{name: "Alice", age: 25}, {name: "Charlie", age: 25}], 30: [{name: "Bob", age: 30}]}

// 9. Reverse a string
let str = "JavaScript";
let reversedStr = str.split("").reduce((acc, char) => char + acc, "");
console.log(reversedStr); 
// Output: "tpircSavaJ"

// 10. Calculate the factorial of a number
let factorial = [1, 2, 3, 4, 5].reduce((acc, num) => acc * num, 1);
console.log(factorial); 
// Output: 120
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-reduceright', event)" >.reduceRight() method</td>
          </tr>
          <tr id="detail-tag-reduceright" class="expandable-row-content">
            <td>
              <h3>.reduceRight() method</h3>
              <p>The `.reduceRight()` method in JavaScript is similar to the `.reduce()` method, but it processes the elements of an array from right to left, rather than from left to right. This means that the accumulation of the array’s elements starts from the last element and moves towards the first. Like `.reduce()`, it takes a reducer function as its primary argument, along with an optional initial value. The reducer function receives four arguments: the accumulator, the current element, the current index, and the array itself. If no initial value is provided, `.reduceRight()` uses the last element of the array as the initial accumulator value and starts the iteration from the second-to-last element. This method is particularly useful in situations where the order of operations matters, such as when dealing with right-associative operations or when you need to reverse the direction of processing, like when constructing or evaluating expressions in reverse order. By processing elements from the end of the array to the beginning, `.reduceRight()` offers a flexible approach to complex data transformations where the direction of accumulation is significant.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Reverse a string using reduceRight
let str = "JavaScript";
let reversedStr = str.split("").reduceRight((acc, char) => acc + char, "");
console.log(reversedStr); 
// Output: "tpircSavaJ"

// 2. Flatten a nested array in reverse order
let nestedArray = [[1, 2], [3, 4], [5, 6]];
let flatArray = nestedArray.reduceRight((acc, arr) => acc.concat(arr), []);
console.log(flatArray); 
// Output: [5, 6, 3, 4, 1, 2]

// 3. Concatenate an array of strings in reverse order
let words = ["world", "hello"];
let sentence = words.reduceRight((acc, word) => acc + " " + word);
console.log(sentence); 
// Output: "hello world"

// 4. Subtract numbers in reverse order
let numbers = [1, 2, 3, 4];
let reverseSubtraction = numbers.reduceRight((acc, num) => acc - num);
console.log(reverseSubtraction); 
// Output: -2  (1 - (2 - (3 - 4)) = -2)

// 5. Create a nested object structure from an array of keys
let keys = ["level1", "level2", "level3"];
let nestedObject = keys.reduceRight((acc, key) => ({ [key]: acc }), {});
console.log(nestedObject); 
// Output: { level1: { level2: { level3: {} } } }

// 6. Calculate the product of numbers in reverse order
let numbers2 = [2, 3, 4];
let reverseProduct = numbers2.reduceRight((acc, num) => acc * num, 1);
console.log(reverseProduct); 
// Output: 24  (4 * 3 * 2)

// 7. Build an HTML string in reverse order
let elements = ["div", "span", "a"];
let htmlString = elements.reduceRight((acc, el) => `<${el}>${acc}</${el}>`, "content");
console.log(htmlString); 
// Output: "<div><span><a>content</a></span></div>"

// 8. Combine objects from right to left
let objectsArray = [{ a: 1 }, { b: 2 }, { c: 3 }];
let combinedObject = objectsArray.reduceRight((acc, obj) => Object.assign(acc, obj), {});
console.log(combinedObject); 
// Output: { c: 3, b: 2, a: 1 }

// 9. Calculate cumulative sum in reverse order
let nums = [10, 20, 30, 40];
let reverseCumulativeSum = nums.reduceRight((acc, num, i) => {
  acc[i] = (acc[i + 1] || 0) + num;
  return acc;
}, []);
console.log(reverseCumulativeSum); 
// Output: [100, 90, 70, 40]

// 10. Decode a base64 string by reversing the operations
let encoded = ["W", "X", "Y", "Z"];
let decoded = encoded.reduceRight((acc, char) => acc + atob(char), "");
console.log(decoded);
// Output: Decoded string in reverse order (assuming `atob` was encoding in reverse)       
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td id="array-mutation" class="tableletters">Array Mutation Methods</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-pop', event)" >.pop() method</td>
          </tr>
          <tr id="detail-tag-pop" class="expandable-row-content">
            <td>
              <h3>.pop() method</h3>
              <p>The `.pop()` method in JavaScript is used to remove the last element from an array, reducing its length by one, and returns the removed element. This method directly modifies the original array, making it shorter by one element each time it is called. If the array is empty, `.pop()` returns `undefined` and does not alter the array. The `.pop()` method is particularly useful when you need to manage data structures like stacks, where the last-in, first-out (LIFO) principle is important. It allows for efficient removal and retrieval of the most recently added elements. Since `.pop()` is a mutative method, it should be used with care when preserving the original array is necessary, as it permanently alters the array's content and length.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Remove the last element from an array of numbers
let numbers = [1, 2, 3, 4, 5];
let lastNumber = numbers.pop();
console.log(numbers); 
// Output: [1, 2, 3, 4]
console.log(lastNumber); 
// Output: 5

// 2. Remove the last element from an array of strings
let fruits = ["apple", "banana", "cherry"];
let lastFruit = fruits.pop();
console.log(fruits); 
// Output: ["apple", "banana"]
console.log(lastFruit); 
// Output: "cherry"

// 3. Use pop in a loop to empty an array
let letters = ["a", "b", "c", "d"];
while (letters.length > 0) {
    letters.pop();
}
console.log(letters); 
// Output: []

// 4. Pop elements from an array until a condition is met
let values = [10, 20, 30, 40, 50];
while (values.length && values[values.length - 1] > 30) {
    values.pop();
}
console.log(values); 
// Output: [10, 20, 30]

// 5. Track removed elements from an array
let items = ["item1", "item2", "item3"];
let removedItems = [];
while (items.length > 0) {
    removedItems.push(items.pop());
}
console.log(removedItems); 
// Output: ["item3", "item2", "item1"]

// 6. Pop from an array of objects
let users = [{name: "Alice"}, {name: "Bob"}, {name: "Charlie"}];
let lastUser = users.pop();
console.log(users); 
// Output: [{name: "Alice"}, {name: "Bob"}]
console.log(lastUser); 
// Output: {name: "Charlie"}

// 7. Pop an element from an array and use it immediately
let tasks = ["task1", "task2", "task3"];
let taskToDo = tasks.pop();
console.log(`Doing ${taskToDo}`); 
// Output: "Doing task3"

// 8. Remove and log elements until an array is empty
let logs = ["log1", "log2", "log3"];
while (logs.length > 0) {
    console.log(logs.pop());
}
// Output: "log3", "log2", "log1" (each on a new line)

// 9. Pop elements from a nested array
let nestedArray = [[1, 2], [3, 4], [5, 6]];
let lastSubArray = nestedArray.pop();
console.log(nestedArray); 
// Output: [[1, 2], [3, 4]]
console.log(lastSubArray); 
// Output: [5, 6]

// 10. Use pop on an empty array (returns undefined)
let emptyArray = [];
let result = emptyArray.pop();
console.log(result); 
// Output: undefined
console.log(emptyArray); 
// Output: []   
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-push', event)" >.push() method</td>
          </tr>
          <tr id="detail-tag-push" class="expandable-row-content">
            <td>
              <h3>.push() method</h3>
              <p>The `.push()` method in JavaScript is used to add one or more elements to the end of an array, expanding its length accordingly. This method directly modifies the original array by appending the new elements and returns the new length of the array after the elements have been added. The `.push()` method is particularly useful for managing data in arrays where you need to dynamically add items, such as building lists or stacking elements in a last-in, first-out (LIFO) manner. Because it alters the array in place, `.push()` is a mutative method, which means the original array is changed, and no new array is created. This makes `.push()` efficient for adding elements but requires caution if the original array needs to remain unchanged.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Add a single element to the end of an array
let numbers = [1, 2, 3];
numbers.push(4);
console.log(numbers); 
// Output: [1, 2, 3, 4]

// 2. Add multiple elements to the end of an array
let fruits = ["apple", "banana"];
fruits.push("cherry", "date");
console.log(fruits); 
// Output: ["apple", "banana", "cherry", "date"]

// 3. Push elements to an empty array
let emptyArray = [];
emptyArray.push(1, 2, 3);
console.log(emptyArray); 
// Output: [1, 2, 3]

// 4. Use push in a loop to add elements dynamically
let letters = [];
for (let i = 0; i < 5; i++) {
    letters.push(String.fromCharCode(97 + i)); // adds "a", "b", "c", "d", "e"
}
console.log(letters); 
// Output: ["a", "b", "c", "d", "e"]

// 5. Push objects into an array
let users = [];
users.push({name: "Alice"});
users.push({name: "Bob"});
console.log(users); 
// Output: [{name: "Alice"}, {name: "Bob"}]

// 6. Combine two arrays using push and spread operator
let array1 = [1, 2, 3];
let array2 = [4, 5, 6];
array1.push(...array2);
console.log(array1); 
// Output: [1, 2, 3, 4, 5, 6]

// 7. Push a nested array into an array
let nestedArray = [];
nestedArray.push([1, 2]);
nestedArray.push([3, 4]);
console.log(nestedArray); 
// Output: [[1, 2], [3, 4]]

// 8. Push elements and get the new length of the array
let items = ["item1", "item2"];
let newLength = items.push("item3");
console.log(items); 
// Output: ["item1", "item2", "item3"]
console.log(newLength); 
// Output: 3

// 9. Push elements conditionally based on a check
let values = [10, 20, 30];
if (values[values.length - 1] < 50) {
    values.push(40);
}
console.log(values); 
// Output: [10, 20, 30, 40]

// 10. Use push to add elements to an array stored in an object property
let obj = { numbers: [1, 2, 3] };
obj.numbers.push(4);
console.log(obj.numbers); 
// Output: [1, 2, 3, 4]  
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-shift', event)" >.shift() method</td>
          </tr>
          <tr id="detail-tag-shift" class="expandable-row-content">
            <td>
              <h3>.shift() method</h3>
              <p>The `.shift()` method in JavaScript is used to remove the first element from an array and returns that removed element. This method directly modifies the original array by reducing its length by one and shifting all remaining elements one position forward, effectively decreasing their indices by one. If the array is empty, `.shift()` returns `undefined` and does not alter the array. The `.shift()` method is particularly useful in scenarios where you need to process or dequeue elements in a first-in, first-out (FIFO) manner, such as when handling tasks in a queue. Since `.shift()` alters the original array, it is considered a mutative method, meaning that it changes the array in place without creating a new one. This makes it efficient for removing the first element but requires caution if the original order of elements needs to be preserved elsewhere in your program.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Remove the first element from an array of numbers
let numbers = [10, 20, 30, 40];
let firstNumber = numbers.shift();
console.log(numbers); 
// Output: [20, 30, 40]
console.log(firstNumber); 
// Output: 10

// 2. Remove the first element from an array of strings
let fruits = ["apple", "banana", "cherry"];
let firstFruit = fruits.shift();
console.log(fruits); 
// Output: ["banana", "cherry"]
console.log(firstFruit); 
// Output: "apple"

// 3. Use shift in a loop to empty an array
let letters = ["a", "b", "c", "d"];
while (letters.length > 0) {
    letters.shift();
}
console.log(letters); 
// Output: []

// 4. Remove and log each element until the array is empty
let items = ["item1", "item2", "item3"];
while (items.length > 0) {
    console.log(items.shift());
}
// Output: "item1", "item2", "item3" (each on a new line)

// 5. Use shift to remove the first object from an array of objects
let users = [
    {name: "Alice", age: 25},
    {name: "Bob", age: 30},
    {name: "Charlie", age: 35}
];
let firstUser = users.shift();
console.log(users); 
// Output: [{name: "Bob", age: 30}, {name: "Charlie", age: 35}]
console.log(firstUser); 
// Output: {name: "Alice", age: 25}

// 6. Remove elements from an array of arrays
let nestedArray = [[1, 2], [3, 4], [5, 6]];
let firstSubArray = nestedArray.shift();
console.log(nestedArray); 
// Output: [[3, 4], [5, 6]]
console.log(firstSubArray); 
// Output: [1, 2]

// 7. Use shift to process a queue of tasks
let tasks = ["task1", "task2", "task3"];
let currentTask = tasks.shift();
console.log(`Processing ${currentTask}`); 
// Output: "Processing task1"
console.log(tasks); 
// Output: ["task2", "task3"]

// 8. Use shift on an array of mixed data types
let mixedArray = [1, "two", true, null];
let firstElement = mixedArray.shift();
console.log(mixedArray); 
// Output: ["two", true, null]
console.log(firstElement); 
// Output: 1

// 9. Remove and use elements conditionally
let values = [5, 10, 15];
let removedValue;
if (values[0] < 10) {
    removedValue = values.shift();
}
console.log(values); 
// Output: [10, 15]
console.log(removedValue); 
// Output: 5

// 10. Use shift on an empty array (returns undefined)
let emptyArray = [];
let result = emptyArray.shift();
console.log(result); 
// Output: undefined
console.log(emptyArray); 
// Output: []    
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-unshift', event)" >.unshift() method</td>
          </tr>
          <tr id="detail-tag-unshift" class="expandable-row-content">
            <td>
              <h3>.unshift() method</h3>
              <p>The `.unshift()` method in JavaScript is used to add one or more elements to the beginning of an array, increasing its length and shifting all existing elements to higher indices to make room for the new elements. This method modifies the original array in place and returns the new length of the array after the elements have been added. The `.unshift()` method is particularly useful when you need to prepend items to an array, such as adding new data at the start of a list or managing a queue where elements are added in a first-in, first-out (FIFO) order. Since `.unshift()` directly alters the array by shifting all elements and extending its length, it is a mutative operation. This means that the original array is changed, and no new array is created, so it should be used when you want to modify the array directly while keeping the original sequence of elements intact but expanded at the beginning.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Add a single element to the beginning of an array
let numbers = [2, 3, 4];
numbers.unshift(1);
console.log(numbers); 
// Output: [1, 2, 3, 4]

// 2. Add multiple elements to the beginning of an array
let fruits = ["banana", "cherry"];
fruits.unshift("apple", "orange");
console.log(fruits); 
// Output: ["apple", "orange", "banana", "cherry"]

// 3. Unshift elements into an empty array
let emptyArray = [];
emptyArray.unshift(5, 10, 15);
console.log(emptyArray); 
// Output: [5, 10, 15]

// 4. Use unshift to add elements in reverse order
let letters = ["c", "d"];
letters.unshift("a", "b");
console.log(letters); 
// Output: ["a", "b", "c", "d"]

// 5. Add objects to the beginning of an array
let users = [{name: "Charlie"}];
users.unshift({name: "Alice"}, {name: "Bob"});
console.log(users); 
// Output: [{name: "Alice"}, {name: "Bob"}, {name: "Charlie"}]

// 6. Combine two arrays using unshift and spread operator
let array1 = [3, 4];
let array2 = [1, 2];
array1.unshift(...array2);
console.log(array1); 
// Output: [1, 2, 3, 4]

// 7. Add nested arrays to the beginning of an array
let nestedArray = [[3, 4]];
nestedArray.unshift([1, 2]);
console.log(nestedArray); 
// Output: [[1, 2], [3, 4]]

// 8. Add elements and get the new length of the array
let items = ["item2", "item3"];
let newLength = items.unshift("item1");
console.log(items); 
// Output: ["item1", "item2", "item3"]
console.log(newLength); 
// Output: 3

// 9. Use unshift to add elements conditionally
let values = [20, 30];
if (values[0] > 10) {
    values.unshift(10);
}
console.log(values); 
// Output: [10, 20, 30]

// 10. Add elements to an array stored in an object property
let obj = { numbers: [2, 3, 4] };
obj.numbers.unshift(1);
console.log(obj.numbers); 
// Output: [1, 2, 3, 4] 
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-reverse', event)" >.reverse() method</td>
          </tr>
          <tr id="detail-tag-reverse" class="expandable-row-content">
            <td>
              <h3>.reverse() method</h3>
              <p>The `.reverse()` method in JavaScript is used to reverse the order of the elements in an array, effectively flipping the array so that the last element becomes the first and the first element becomes the last. This method modifies the original array in place, meaning it changes the array itself rather than creating a new one. The `.reverse()` method is particularly useful when you need to invert the order of elements for tasks like displaying data in a different sequence or when implementing algorithms that require a reversed array order. Because it is a mutative method, using `.reverse()` should be done with care if you need to preserve the original order of the array for other operations, as the original array is permanently altered. The method returns the array itself after reversing, allowing for further chaining of methods if needed.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Reverse an array of numbers
let numbers = [1, 2, 3, 4, 5];
numbers.reverse();
console.log(numbers); 
// Output: [5, 4, 3, 2, 1]

// 2. Reverse an array of strings
let fruits = ["apple", "banana", "cherry"];
fruits.reverse();
console.log(fruits); 
// Output: ["cherry", "banana", "apple"]

// 3. Reverse an array of mixed data types
let mixedArray = [1, "two", true, null];
mixedArray.reverse();
console.log(mixedArray); 
// Output: [null, true, "two", 1]

// 4. Reverse an array of objects
let users = [
    {name: "Alice", age: 25},
    {name: "Bob", age: 30},
    {name: "Charlie", age: 35}
];
users.reverse();
console.log(users); 
// Output: [{name: "Charlie", age: 35}, {name: "Bob", age: 30}, {name: "Alice", age: 25}]

// 5. Reverse a nested array
let nestedArray = [[1, 2], [3, 4], [5, 6]];
nestedArray.reverse();
console.log(nestedArray); 
// Output: [[5, 6], [3, 4], [1, 2]]

// 6. Reverse an array and join it into a string
let letters = ["a", "b", "c", "d"];
let reversedString = letters.reverse().join("");
console.log(reversedString); 
// Output: "dcba"

// 7. Reverse an array of booleans
let booleans = [true, false, false, true];
booleans.reverse();
console.log(booleans); 
// Output: [true, false, false, true]

// 8. Reverse a sparse array
let sparseArray = [1, , 3, , 5];
sparseArray.reverse();
console.log(sparseArray); 
// Output: [5, empty, 3, empty, 1]

// 9. Reverse an array of numbers and calculate the sum of the reversed array
let nums = [1, 2, 3, 4, 5];
let sum = nums.reverse().reduce((acc, num) => acc + num, 0);
console.log(nums); 
// Output: [5, 4, 3, 2, 1]
console.log(sum); 
// Output: 15

// 10. Reverse an array of strings and convert to uppercase
let words = ["one", "two", "three"];
let reversedUppercase = words.reverse().map(word => word.toUpperCase());
console.log(reversedUppercase); 
// Output: ["THREE", "TWO", "ONE"]
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-sort', event)" >.sort() method</td>
          </tr>
          <tr id="detail-tag-sort" class="expandable-row-content">
            <td>
              <h3>.sort() method</h3>
              <p>The `.sort()` method in JavaScript is used to arrange the elements of an array in place, modifying the original array based on a specific order. By default, `.sort()` converts the elements to strings and sorts them in ascending lexicographical order, which means that numbers, letters, and symbols are sorted according to Unicode values. This can lead to unexpected results when sorting numbers unless a custom comparator function is provided. The comparator function allows you to define your own sorting logic, such as sorting numbers in numerical order or arranging objects based on a specific property. Since `.sort()` directly alters the original array, it is considered a mutative method, meaning the array is changed permanently, and no new array is created. The method returns the sorted array, enabling method chaining if further operations are needed. The `.sort()` method is highly useful for organizing data in a specific sequence, whether alphabetically, numerically, or according to custom criteria, but it should be used carefully when preserving the original array order is important.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Sort an array of numbers in ascending order
let numbers = [5, 3, 8, 1, 2];
numbers.sort((a, b) => a - b);
console.log(numbers); 
// Output: [1, 2, 3, 5, 8]

// 2. Sort an array of numbers in descending order
numbers.sort((a, b) => b - a);
console.log(numbers); 
// Output: [8, 5, 3, 2, 1]

// 3. Sort an array of strings in alphabetical order
let fruits = ["banana", "apple", "cherry"];
fruits.sort();
console.log(fruits); 
// Output: ["apple", "banana", "cherry"]

// 4. Sort an array of strings in reverse alphabetical order
fruits.sort((a, b) => b.localeCompare(a));
console.log(fruits); 
// Output: ["cherry", "banana", "apple"]

// 5. Sort an array of objects by a numeric property
let users = [
    {name: "Alice", age: 25},
    {name: "Bob", age: 30},
    {name: "Charlie", age: 20}
];
users.sort((a, b) => a.age - b.age);
console.log(users); 
// Output: [{name: "Charlie", age: 20}, {name: "Alice", age: 25}, {name: "Bob", age: 30}]

// 6. Sort an array of objects by a string property
users.sort((a, b) => a.name.localeCompare(b.name));
console.log(users); 
// Output: [{name: "Alice", age: 25}, {name: "Bob", age: 30}, {name: "Charlie", age: 20}]

// 7. Sort an array of mixed case strings, case-insensitive
let mixedCaseStrings = ["Banana", "apple", "Cherry"];
mixedCaseStrings.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
console.log(mixedCaseStrings); 
// Output: ["apple", "Banana", "Cherry"]

// 8. Sort an array of numbers as strings
let numberStrings = ["10", "2", "30", "1"];
numberStrings.sort();
console.log(numberStrings); 
// Output: ["1", "10", "2", "30"] // String comparison sorts "10" before "2"

// 9. Sort an array of dates in ascending order
let dates = [
    new Date(2023, 11, 24),
    new Date(2022, 5, 12),
    new Date(2023, 0, 1)
];
dates.sort((a, b) => a - b);
console.log(dates); 
// Output: [Date 2022-06-12, Date 2023-01-01, Date 2023-12-24]

// 10. Sort an array of arrays based on the first element of each sub-array
let arrayOfArrays = [[3, "c"], [1, "a"], [2, "b"]];
arrayOfArrays.sort((a, b) => a[0] - b[0]);
console.log(arrayOfArrays); 
// Output: [[1, "a"], [2, "b"], [3, "c"]]  
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td id="array-utility" class="tableletters">Array Utility Methods</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-join', event)" >.join() method</td>
          </tr>
          <tr id="detail-tag-join" class="expandable-row-content">
            <td>
              <h3>.join() method</h3>
              <p>The `.join()` method in JavaScript is used to concatenate all the elements of an array into a single string, with each element separated by a specified separator. When you call `.join()` on an array, you can provide an optional string argument that serves as the separator between the array elements in the resulting string. If no separator is specified, the method defaults to using a comma. This method is particularly useful for creating strings from arrays, such as converting a list of words into a sentence or formatting data for display or storage. Since `.join()` returns a new string and does not alter the original array, it is a non-mutative method, allowing the array to remain unchanged. The `.join()` method is a convenient and efficient way to combine array elements into a cohesive string, especially when you need to represent the contents of an array in a readable or specific format.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Join an array of strings into a single string with commas
let fruits = ["apple", "banana", "cherry"];
let fruitString = fruits.join(", ");
console.log(fruitString); 
// Output: "apple, banana, cherry"

// 2. Join an array of numbers into a single string
let numbers = [1, 2, 3, 4];
let numberString = numbers.join("-");
console.log(numberString); 
// Output: "1-2-3-4"

// 3. Join an array of words into a sentence
let words = ["Hello", "world", "this", "is", "JavaScript"];
let sentence = words.join(" ");
console.log(sentence); 
// Output: "Hello world this is JavaScript"

// 4. Join an array of letters with no separator
let letters = ["a", "b", "c", "d"];
let joinedLetters = letters.join("");
console.log(joinedLetters); 
// Output: "abcd"

// 5. Join an array with a custom separator (e.g., "|")
let items = ["item1", "item2", "item3"];
let joinedItems = items.join(" | ");
console.log(joinedItems); 
// Output: "item1 | item2 | item3"

// 6. Join an array of objects' properties into a string
let users = [{name: "Alice"}, {name: "Bob"}, {name: "Charlie"}];
let userNames = users.map(user => user.name).join(", ");
console.log(userNames); 
// Output: "Alice, Bob, Charlie"

// 7. Join an array of booleans into a string
let booleans = [true, false, true];
let booleanString = booleans.join(" and ");
console.log(booleanString); 
// Output: "true and false and true"

// 8. Join an array of mixed data types into a string
let mixedArray = [1, "two", 3, "four"];
let mixedString = mixedArray.join(" + ");
console.log(mixedString); 
// Output: "1 + two + 3 + four"

// 9. Join an array of nested arrays into a string
let nestedArray = [[1, 2], [3, 4], [5, 6]];
let nestedString = nestedArray.join(" | ");
console.log(nestedString); 
// Output: "1,2 | 3,4 | 5,6"

// 10. Join an array of numbers into a string with a fixed format
let prices = [10, 20, 30];
let priceString = prices.join("$, $");
console.log("$" + priceString + "$"); 
// Output: "$10$, $20$, $30$"
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-tostring', event)" >.toString() method</td>
          </tr>
          <tr id="detail-tag-tostring" class="expandable-row-content">
            <td>
              <h3>.toString() method</h3>
              <p>The `.toString()` method in JavaScript is used to convert an array or other objects into a string representation. When called on an array, the `.toString()` method joins all the elements of the array into a single string, separated by commas, similar to using the `.join()` method without specifying a separator. This method is particularly useful when you need to quickly convert an array into a string for display, logging, or other purposes where a textual representation of the array is required. The `.toString()` method does not alter the original array, making it a non-mutative operation. Additionally, `.toString()` can be invoked on other types of objects, like numbers and dates, to convert them into strings based on their specific format rules. Overall, `.toString()` provides a simple and effective way to obtain a string version of various data types, especially arrays, in JavaScript.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Convert an array of numbers to a string
let numbers = [1, 2, 3, 4];
let numberString = numbers.toString();
console.log(numberString); 
// Output: "1,2,3,4"

// 2. Convert an array of strings to a single string
let fruits = ["apple", "banana", "cherry"];
let fruitString = fruits.toString();
console.log(fruitString); 
// Output: "apple,banana,cherry"

// 3. Convert an array of mixed data types to a string
let mixedArray = [1, "two", true, null];
let mixedString = mixedArray.toString();
console.log(mixedString); 
// Output: "1,two,true,"

// 4. Convert a nested array to a string
let nestedArray = [[1, 2], [3, 4]];
let nestedString = nestedArray.toString();
console.log(nestedString); 
// Output: "1,2,3,4"

// 5. Convert an object to a string (using Object's toString method)
let obj = {name: "Alice", age: 25};
let objString = obj.toString();
console.log(objString); 
// Output: "[object Object]"

// 6. Convert a date object to a string
let date = new Date(2023, 11, 24);
let dateString = date.toString();
console.log(dateString); 
// Output: "Sun Dec 24 2023 00:00:00 GMT+0000 (Coordinated Universal Time)"

// 7. Convert a function to a string
function greet() {
  return "Hello, world!";
}
let functionString = greet.toString();
console.log(functionString); 
// Output: "function greet() {\n  return \"Hello, world!\";\n}"

// 8. Convert a boolean value to a string
let boolValue = true;
let boolString = boolValue.toString();
console.log(boolString); 
// Output: "true"

// 9. Convert a number to a string
let num = 123;
let numString = num.toString();
console.log(numString); 
// Output: "123"

// 10. Convert an array with undefined and null values to a string
let arrayWithUndefined = [undefined, null, 1];
let undefinedString = arrayWithUndefined.toString();
console.log(undefinedString); 
// Output: ",,1"   
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-tolocalstring', event)" >.toLocalString() method</td>
          </tr>
          <tr id="detail-tag-tolocalstring" class="expandable-row-content">
            <td>
              <h3>.tolocalstring() method</h3>
              <p>The `.toLocaleString()` method in JavaScript is used to convert an array or other objects, such as numbers and dates, into a string that represents the elements or values in a locale-sensitive format. When called on an array, each element is converted to a string using its own `.toLocaleString()` method, and then the array elements are joined together with a locale-specific separator, usually a comma. This method is particularly useful when you need to display data in a format that is tailored to the conventions of a particular locale, such as formatting dates, times, currencies, or numbers according to regional standards. For instance, a date might be formatted differently depending on whether the locale is set to the United States, Europe, or Japan. The `.toLocaleString()` method is non-mutative, meaning it does not alter the original array or object but instead returns a new string with the localized formatting. This makes it a valuable tool for creating user interfaces and applications that need to be adaptable to different cultural and regional settings.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Convert a number to a string with localized formatting
let number = 1234567.89;
let localizedNumber = number.toLocaleString();
console.log(localizedNumber); 
// Output: "1,234,567.89" (depending on the locale)

// 2. Convert a number to a string with a specific locale (German)
let germanNumber = number.toLocaleString('de-DE');
console.log(germanNumber); 
// Output: "1.234.567,89" (German locale)

// 3. Format a date object using the default locale
let date = new Date(2023, 11, 24);
let localizedDate = date.toLocaleString();
console.log(localizedDate); 
// Output: "12/24/2023, 12:00:00 AM" (depending on the locale)

// 4. Format a date object with a specific locale and options
let options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
let formattedDate = date.toLocaleString('en-US', options);
console.log(formattedDate); 
// Output: "Sunday, December 24, 2023" (English, US locale)

// 5. Format a currency value in US dollars
let currencyValue = 123456.789;
let formattedCurrency = currencyValue.toLocaleString('en-US', { style: 'currency', currency: 'USD' });
console.log(formattedCurrency); 
// Output: "$123,456.79"

// 6. Format a currency value in Japanese Yen
let yenCurrency = currencyValue.toLocaleString('ja-JP', { style: 'currency', currency: 'JPY' });
console.log(yenCurrency); 
// Output: "￥123,457"

// 7. Format a percentage value
let percentage = 0.5678;
let formattedPercentage = percentage.toLocaleString('en-US', { style: 'percent' });
console.log(formattedPercentage); 
// Output: "56.78%"

// 8. Format a number with specific digit options
let preciseNumber = 1234.56789;
let formattedPreciseNumber = preciseNumber.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 4 });
console.log(formattedPreciseNumber); 
// Output: "1,234.5679"

// 9. Format a large number in Indian numbering system
let indianNumber = 123456789;
let formattedIndianNumber = indianNumber.toLocaleString('en-IN');
console.log(formattedIndianNumber); 
// Output: "12,34,56,789" (Indian locale)

// 10. Format a date and time with a specific timezone
let timezoneDate = date.toLocaleString('en-US', { timeZone: 'Asia/Tokyo' });
console.log(timezoneDate); 
// Output: "12/24/2023, 2:00:00 PM" (Tokyo time)
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-toreversed', event)" >.toReversed() method</td>
          </tr>
          <tr id="detail-tag-toreversed" class="expandable-row-content">
            <td>
              <h3>.toReversed() method</h3>
              <p>The `.toReversed()` method in JavaScript is a relatively new addition that allows you to create a reversed copy of an array without modifying the original array. When you call `.toReversed()` on an array, it returns a new array with the elements in the opposite order, starting from the last element and ending with the first. This method is non-mutative, meaning the original array remains unchanged, which is particularly useful when you need to preserve the original data while working with a reversed version of it. The introduction of `.toReversed()` provides a more convenient and expressive way to reverse an array compared to using `.slice().reverse()`, which was a common practice before this method was available. It enhances code readability and reduces the risk of unintended side effects, making it a valuable tool for handling arrays in situations where both the original and reversed versions of the data are needed.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Reverse an array of numbers without mutating the original array
let numbers = [1, 2, 3, 4, 5];
let reversedNumbers = numbers.toReversed();
console.log(reversedNumbers); 
// Output: [5, 4, 3, 2, 1]
console.log(numbers); 
// Output: [1, 2, 3, 4, 5] (original array remains unchanged)

// 2. Reverse an array of strings without mutating the original array
let fruits = ["apple", "banana", "cherry"];
let reversedFruits = fruits.toReversed();
console.log(reversedFruits); 
// Output: ["cherry", "banana", "apple"]
console.log(fruits); 
// Output: ["apple", "banana", "cherry"] (original array remains unchanged)

// 3. Reverse an array of mixed data types
let mixedArray = [1, "two", true, null];
let reversedMixedArray = mixedArray.toReversed();
console.log(reversedMixedArray); 
// Output: [null, true, "two", 1]

// 4. Reverse a nested array
let nestedArray = [[1, 2], [3, 4], [5, 6]];
let reversedNestedArray = nestedArray.toReversed();
console.log(reversedNestedArray); 
// Output: [[5, 6], [3, 4], [1, 2]]

// 5. Reverse an array and join it into a string
let letters = ["a", "b", "c", "d"];
let reversedString = letters.toReversed().join("");
console.log(reversedString); 
// Output: "dcba"

// 6. Reverse an array of booleans
let booleans = [true, false, false, true];
let reversedBooleans = booleans.toReversed();
console.log(reversedBooleans); 
// Output: [true, false, false, true]

// 7. Reverse a sparse array (array with empty slots)
let sparseArray = [1, , 3, , 5];
let reversedSparseArray = sparseArray.toReversed();
console.log(reversedSparseArray); 
// Output: [5, empty, 3, empty, 1]

// 8. Reverse an array of numbers and calculate the sum of the reversed array
let nums = [1, 2, 3, 4, 5];
let reversedSum = nums.toReversed().reduce((acc, num) => acc + num, 0);
console.log(reversedSum); 
// Output: 15

// 9. Reverse an array of strings and convert them to uppercase
let words = ["one", "two", "three"];
let reversedUppercaseWords = words.toReversed().map(word => word.toUpperCase());
console.log(reversedUppercaseWords); 
// Output: ["THREE", "TWO", "ONE"]

// 10. Reverse an array of objects by a specific property without mutating the original
let users = [
    {name: "Alice", age: 25},
    {name: "Bob", age: 30},
    {name: "Charlie", age: 35}
];
let reversedUsers = users.toReversed();
console.log(reversedUsers); 
// Output: [{name: "Charlie", age: 35}, {name: "Bob", age: 30}, {name: "Alice", age: 25}]
console.log(users); 
// Output: [{name: "Alice", age: 25}, {name: "Bob", age: 30}, {name: "Charlie", age: 35}] (original array remains unchanged)
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-tosorted', event)" >.toSorted() method</td>
          </tr>
          <tr id="detail-tag-tosorted" class="expandable-row-content">
            <td>
              <h3>.toSorted() method</h3>
              <p>The `.toSorted()` method in JavaScript is a modern array method that returns a new array with the elements sorted in a specified order, without altering the original array. When you call `.toSorted()` on an array, you can optionally pass a comparator function that defines how the elements should be compared and ordered. If no comparator is provided, the method sorts the elements in ascending order based on their string Unicode values, similar to the behavior of the `.sort()` method. The key difference between `.toSorted()` and `.sort()` is that `.toSorted()` is non-mutative—it does not modify the original array, instead creating and returning a sorted copy. This makes `.toSorted()` particularly useful when you need to sort data without affecting the original dataset, preserving its integrity for other operations. The introduction of `.toSorted()` enhances code clarity and safety, reducing the chances of accidental data mutation while providing a straightforward way to work with sorted data.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Sort an array of numbers in ascending order without mutating the original array
let numbers = [5, 3, 8, 1, 2];
let sortedNumbers = numbers.toSorted((a, b) => a - b);
console.log(sortedNumbers); 
// Output: [1, 2, 3, 5, 8]
console.log(numbers); 
// Output: [5, 3, 8, 1, 2] (original array remains unchanged)

// 2. Sort an array of numbers in descending order
let sortedNumbersDesc = numbers.toSorted((a, b) => b - a);
console.log(sortedNumbersDesc); 
// Output: [8, 5, 3, 2, 1]

// 3. Sort an array of strings alphabetically
let fruits = ["banana", "apple", "cherry"];
let sortedFruits = fruits.toSorted();
console.log(sortedFruits); 
// Output: ["apple", "banana", "cherry"]
console.log(fruits); 
// Output: ["banana", "apple", "cherry"] (original array remains unchanged)

// 4. Sort an array of strings in reverse alphabetical order
let sortedFruitsDesc = fruits.toSorted((a, b) => b.localeCompare(a));
console.log(sortedFruitsDesc); 
// Output: ["cherry", "banana", "apple"]

// 5. Sort an array of objects by a numeric property
let users = [
    {name: "Alice", age: 25},
    {name: "Bob", age: 30},
    {name: "Charlie", age: 20}
];
let sortedByAge = users.toSorted((a, b) => a.age - b.age);
console.log(sortedByAge); 
// Output: [{name: "Charlie", age: 20}, {name: "Alice", age: 25}, {name: "Bob", age: 30}]
console.log(users); 
// Output: [{name: "Alice", age: 25}, {name: "Bob", age: 30}, {name: "Charlie", age: 20}] (original array remains unchanged)

// 6. Sort an array of objects by a string property
let sortedByName = users.toSorted((a, b) => a.name.localeCompare(b.name));
console.log(sortedByName); 
// Output: [{name: "Alice", age: 25}, {name: "Bob", age: 30}, {name: "Charlie", age: 20}]

// 7. Sort an array of mixed-case strings, case-insensitive
let mixedCaseStrings = ["Banana", "apple", "Cherry"];
let sortedMixedCaseStrings = mixedCaseStrings.toSorted((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
console.log(sortedMixedCaseStrings); 
// Output: ["apple", "Banana", "Cherry"]

// 8. Sort an array of numbers represented as strings
let numberStrings = ["10", "2", "30", "1"];
let sortedNumberStrings = numberStrings.toSorted((a, b) => parseInt(a) - parseInt(b));
console.log(sortedNumberStrings); 
// Output: ["1", "2", "10", "30"]

// 9. Sort an array of dates in ascending order
let dates = [
    new Date(2023, 11, 24),
    new Date(2022, 5, 12),
    new Date(2023, 0, 1)
];
let sortedDates = dates.toSorted((a, b) => a - b);
console.log(sortedDates); 
// Output: [Date 2022-06-12, Date 2023-01-01, Date 2023-12-24]

// 10. Sort an array of arrays based on the first element of each sub-array
let arrayOfArrays = [[3, "c"], [1, "a"], [2, "b"]];
let sortedArrayOfArrays = arrayOfArrays.toSorted((a, b) => a[0] - b[0]);
console.log(sortedArrayOfArrays); 
// Output: [[1, "a"], [2, "b"], [3, "c"]]
console.log(arrayOfArrays); 
// Output: [[3, "c"], [1, "a"], [2, "b"]] (original array remains unchanged)
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-toSpliced', event)" >.toSpliced() method</td>
          </tr>
          <tr id="detail-tag-toSpliced" class="expandable-row-content">
            <td>
              <h3>.toSpliced() method</h3>
              <p>The `.toSpliced()` method in JavaScript is a recent addition that allows you to create a modified copy of an array by inserting, removing, or replacing elements, without altering the original array. When you call `.toSpliced()`, you specify a start index where the changes should begin, the number of elements to remove, and optionally, the elements to add at that position. Unlike the traditional `.splice()` method, which mutates the original array, `.toSpliced()` returns a new array with the modifications applied, leaving the original array untouched. This non-mutative approach is particularly useful when you need to perform complex modifications on an array while preserving the original data for other operations or references. The introduction of `.toSpliced()` provides a safer and more predictable way to work with array modifications, especially in functional programming contexts where immutability is often preferred.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Remove elements from an array without mutating the original array
let numbers = [1, 2, 3, 4, 5];
let splicedNumbers = numbers.toSpliced(2, 2); // Removes 2 elements starting at index 2
console.log(splicedNumbers); 
// Output: [1, 2, 5]
console.log(numbers); 
// Output: [1, 2, 3, 4, 5] (original array remains unchanged)

// 2. Add elements to an array without mutating the original array
let fruits = ["apple", "banana", "cherry"];
let newFruits = fruits.toSpliced(1, 0, "orange", "grape");
console.log(newFruits); 
// Output: ["apple", "orange", "grape", "banana", "cherry"]
console.log(fruits); 
// Output: ["apple", "banana", "cherry"] (original array remains unchanged)

// 3. Replace elements in an array without mutating the original array
let letters = ["a", "b", "c", "d"];
let replacedLetters = letters.toSpliced(1, 2, "x", "y");
console.log(replacedLetters); 
// Output: ["a", "x", "y", "d"]
console.log(letters); 
// Output: ["a", "b", "c", "d"] (original array remains unchanged)

// 4. Remove all elements after a certain index
let colors = ["red", "green", "blue", "yellow"];
let shortenedColors = colors.toSpliced(2);
console.log(shortenedColors); 
// Output: ["red", "green"]
console.log(colors); 
// Output: ["red", "green", "blue", "yellow"] (original array remains unchanged)

// 5. Insert elements at the beginning of an array
let nums = [4, 5, 6];
let newNums = nums.toSpliced(0, 0, 1, 2, 3);
console.log(newNums); 
// Output: [1, 2, 3, 4, 5, 6]
console.log(nums); 
// Output: [4, 5, 6] (original array remains unchanged)

// 6. Replace all elements in an array
let items = ["item1", "item2", "item3"];
let replacedItems = items.toSpliced(0, items.length, "newItem1", "newItem2");
console.log(replacedItems); 
// Output: ["newItem1", "newItem2"]
console.log(items); 
// Output: ["item1", "item2", "item3"] (original array remains unchanged)

// 7. Remove the first element from an array
let animals = ["cat", "dog", "rabbit"];
let withoutFirstAnimal = animals.toSpliced(0, 1);
console.log(withoutFirstAnimal); 
// Output: ["dog", "rabbit"]
console.log(animals); 
// Output: ["cat", "dog", "rabbit"] (original array remains unchanged)

// 8. Insert elements in the middle of an array
let sequence = [1, 2, 5, 6];
let correctedSequence = sequence.toSpliced(2, 0, 3, 4);
console.log(correctedSequence); 
// Output: [1, 2, 3, 4, 5, 6]
console.log(sequence); 
// Output: [1, 2, 5, 6] (original array remains unchanged)

// 9. Replace a single element in an array
let weekdays = ["Monday", "Tuesday", "Wednesday"];
let updatedWeekdays = weekdays.toSpliced(1, 1, "Thursday");
console.log(updatedWeekdays); 
// Output: ["Monday", "Thursday", "Wednesday"]
console.log(weekdays); 
// Output: ["Monday", "Tuesday", "Wednesday"] (original array remains unchanged)

// 10. Remove and add elements in an array simultaneously
let letters2 = ["a", "b", "c", "d"];
let modifiedLetters = letters2.toSpliced(1, 2, "x", "y", "z");
console.log(modifiedLetters); 
// Output: ["a", "x", "y", "z", "d"]
console.log(letters2); 
// Output: ["a", "b", "c", "d"] (original array remains unchanged)
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-with', event)" >.with() method</td>
          </tr>
          <tr id="detail-tag-with" class="expandable-row-content">
            <td>
              <h3>.with() method</h3>
              <p>The `.with()` method in JavaScript is a modern array method that allows you to create a copy of an array with one element replaced at a specified index, without altering the original array. When you call `.with()`, you provide the index of the element you want to replace and the new value that should take its place. The method then returns a new array with the specified change, while the rest of the array remains unchanged. This method is particularly useful when you need to update a specific element in an array while ensuring the original array remains intact, which is important in scenarios where immutability is desired, such as in functional programming or when working with state in React. The `.with()` method simplifies the process of making targeted updates to arrays, offering a clear and concise way to handle array modifications without the risk of mutating the original data.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Replace an element in an array without mutating the original array
let numbers = [1, 2, 3, 4, 5];
let newNumbers = numbers.with(2, 10); // Replaces the element at index 2 with 10
console.log(newNumbers); 
// Output: [1, 2, 10, 4, 5]
console.log(numbers); 
// Output: [1, 2, 3, 4, 5] (original array remains unchanged)

// 2. Replace the first element in an array
let fruits = ["apple", "banana", "cherry"];
let newFruits = fruits.with(0, "orange");
console.log(newFruits); 
// Output: ["orange", "banana", "cherry"]
console.log(fruits); 
// Output: ["apple", "banana", "cherry"] (original array remains unchanged)

// 3. Replace the last element in an array
let colors = ["red", "green", "blue"];
let newColors = colors.with(colors.length - 1, "yellow");
console.log(newColors); 
// Output: ["red", "green", "yellow"]
console.log(colors); 
// Output: ["red", "green", "blue"] (original array remains unchanged)

// 4. Replace an element in a sparse array
let sparseArray = [1, , 3];
let newSparseArray = sparseArray.with(1, 2);
console.log(newSparseArray); 
// Output: [1, 2, 3]
console.log(sparseArray); 
// Output: [1, empty, 3] (original array remains unchanged)

// 5. Replace an element in an array of objects
let users = [
    {name: "Alice", age: 25},
    {name: "Bob", age: 30},
    {name: "Charlie", age: 35}
];
let newUsers = users.with(1, {name: "Bob", age: 31});
console.log(newUsers); 
// Output: [{name: "Alice", age: 25}, {name: "Bob", age: 31}, {name: "Charlie", age: 35}]
console.log(users); 
// Output: [{name: "Alice", age: 25}, {name: "Bob", age: 30}, {name: "Charlie", age: 35}] (original array remains unchanged)

// 6. Replace an element in an array of strings
let letters = ["a", "b", "c", "d"];
let newLetters = letters.with(3, "z");
console.log(newLetters); 
// Output: ["a", "b", "c", "z"]
console.log(letters); 
// Output: ["a", "b", "c", "d"] (original array remains unchanged)

// 7. Replace an element in a nested array
let nestedArray = [[1, 2], [3, 4], [5, 6]];
let newNestedArray = nestedArray.with(1, [7, 8]);
console.log(newNestedArray); 
// Output: [[1, 2], [7, 8], [5, 6]]
console.log(nestedArray); 
// Output: [[1, 2], [3, 4], [5, 6]] (original array remains unchanged)

// 8. Replace an element with `null`
let items = ["item1", "item2", "item3"];
let newItems = items.with(2, null);
console.log(newItems); 
// Output: ["item1", "item2", null]
console.log(items); 
// Output: ["item1", "item2", "item3"] (original array remains unchanged)

// 9. Replace an element in an array of booleans
let booleans = [true, false, true];
let newBooleans = booleans.with(1, true);
console.log(newBooleans); 
// Output: [true, true, true]
console.log(booleans); 
// Output: [true, false, true] (original array remains unchanged)

// 10. Replace an element in an array of mixed data types
let mixedArray = [1, "two", true];
let newMixedArray = mixedArray.with(1, "three");
console.log(newMixedArray); 
// Output: [1, "three", true]
console.log(mixedArray); 
// Output: [1, "two", true] (original array remains unchanged)    
          </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td id="loops" class="tableletters">Loops</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-loopsoverview', event)">overview</td>
          </tr>
          <tr id="detail-tag-loopsoverview" class="expandable-row-content">
            <td>
              <h3>overview</h3>
              <p>Loops in JavaScript are a powerful and essential programming construct that enable developers to automate repetitive tasks, handle large datasets, and implement complex algorithms efficiently. At their core, loops allow a block of code to be executed repeatedly based on a specified condition. This condition is evaluated before or after each iteration, depending on the type of loop, and as long as it holds true, the loop continues to execute. For instance, if you need to perform an operation on each element of an array, a loop can iterate through each item, applying the desired action without the need for manual, repetitive coding. JavaScript provides several types of loops, such as the `for` loop, which is ideal for situations where the number of iterations is known; the `while` loop, which is useful when the condition for continuation is more dynamic; and the `do...while` loop, which guarantees that the loop body is executed at least once. Additionally, there are specialized loops like `for...in` and `for...of` for iterating over object properties and iterable objects, respectively. By using loops, developers can write more efficient, readable, and maintainable code, particularly when dealing with tasks that require multiple iterations, such as data processing, automation, and traversal of collections. Loops not only save time but also reduce the likelihood of errors, making them a cornerstone of effective programming in JavaScript.</p>
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-forloop', event)">for loop</td>
          </tr>
          <tr id="detail-tag-forloop" class="expandable-row-content">
            <td>
              <h3>for loop</h3>
              <p>The `for` loop in JavaScript is one of the most commonly used looping structures, designed to execute a block of code a specific number of times. It consists of three main parts: an initialization statement, a condition, and an increment or decrement operation. The initialization is typically used to set up a loop counter, the condition is evaluated before each iteration to determine whether the loop should continue, and the increment or decrement adjusts the loop counter at the end of each iteration. For example, in a basic `for` loop, you might initialize a counter variable to zero, set a condition to keep looping as long as the counter is less than a certain value, and then increment the counter by one after each iteration. This structure is particularly useful when the number of iterations is known in advance, such as when you need to iterate over the elements of an array or perform a repetitive task a fixed number of times. The `for` loop provides a concise and flexible way to handle repeated actions, making it a fundamental tool for controlling flow in JavaScript programs.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Basic for loop counting up
// Logs: 0 1 2 3 4
for (let i = 0; i < 5; i++) {
    console.log(i);
}

// 2. For loop iterating through an array
// Logs: Apple Banana Orange
const fruits = ["Apple", "Banana", "Orange"];
for (let i = 0; i < fruits.length; i++) {
    console.log(fruits[i]);
}

// 3. For loop counting down
// Logs: 4 3 2 1 0
for (let i = 4; i >= 0; i--) {
    console.log(i);
}

// 4. For loop with a step of 2
// Logs: 0 2 4 6 8
for (let i = 0; i < 10; i += 2) {
    console.log(i);
}

// 5. For loop through an object's keys
// Logs: name age occupation
const person = { name: "John", age: 30, occupation: "Engineer" };
for (let key in person) {
    console.log(key);
}

// 6. For loop through an object's values
// Logs: John 30 Engineer
for (let key in person) {
    console.log(person[key]);
}

// 7. For loop with nested loops (multiplication table)
// Logs: Multiplication table from 1 to 3
for (let i = 1; i <= 3; i++) {
    for (let j = 1; j <= 3; j++) {
        console.log(`${i} * ${j} = ${i * j}`);
    }
}

// 8. For loop with continue statement
// Logs: 0 1 3 4 (skips 2)
for (let i = 0; i < 5; i++) {
    if (i === 2) continue;
    console.log(i);
}

// 9. For loop with break statement
// Logs: 0 1 2 (stops at 2)
for (let i = 0; i < 5; i++) {
    if (i === 3) break;
    console.log(i);
}

// 10. For loop using for...of with an array
// Logs: Car Bus Train
const vehicles = ["Car", "Bus", "Train"];
for (const vehicle of vehicles) {
    console.log(vehicle);
}

// 11. For loop using for...in with an array (indexes)
// Logs: 0 1 2
for (let index in vehicles) {
    console.log(index);
}

// 12. For loop summing array elements
// Logs: 6
const numbers = [1, 2, 3];
let sum = 0;
for (let i = 0; i < numbers.length; i++) {
    sum += numbers[i];
}
console.log(sum);

// 13. For loop over a string
// Logs: H e l l o
const greeting = "Hello";
for (let i = 0; i < greeting.length; i++) {
    console.log(greeting[i]);
}

// 14. For loop generating a pattern (triangle)
// Logs: *
//       **
//       ***
//       ****
//       *****
for (let i = 1; i <= 5; i++) {
    let pattern = '';
    for (let j = 0; j < i; j++) {
        pattern += '*';
    }
    console.log(pattern);
}

// 15. For loop filtering even numbers from an array
// Logs: 2 4
const numbersArray = [1, 2, 3, 4, 5];
for (let i = 0; i < numbersArray.length; i++) {
    if (numbersArray[i] % 2 === 0) {
        console.log(numbersArray[i]);
    }
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-nestedf', event)">nested for loop</td>
          </tr>
          <tr id="detail-tag-nestedf" class="expandable-row-content">
            <td>
              <h3>nested for loop</h3>
              <p>Nested for loops in JavaScript are loops placed inside another loop, and they are often used when dealing with nested arrays, which are arrays within arrays. This type of structure allows you to iterate through multi-dimensional data efficiently. For example, if you have a 2D array, where each element in the main array is itself an array (like a grid or matrix), the outer loop can iterate through each array (row), and the inner loop can iterate through each element within that row (column). This approach is powerful for tasks like processing or accessing data in a grid-like format, such as creating tables or performing operations across rows and columns simultaneously. However, it's crucial to understand that nested loops, especially with nested arrays, can lead to increased computational complexity, making the code slower as the size of the data grows. Careful consideration should be given to ensure that nested loops are necessary and optimized for performance, especially when working with large or complex datasets.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Basic nested for loop (multiplication table)
// Logs: Multiplication table from 1 to 3
for (let i = 1; i <= 3; i++) {
    for (let j = 1; j <= 3; j++) {
        console.log(`${i} * ${j} = ${i * j}`);
    }
}

// 2. Iterating through a 2D array (grid)
// Logs: Elements of the 2D array row by row
const grid = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];
for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[i].length; j++) {
        console.log(grid[i][j]);
    }
}

// 3. Finding mutual followers between two users
// Logs: List of mutual followers between two users
const userA_followers = ['John', 'Alice', 'Bob', 'Eve'];
const userB_followers = ['Bob', 'Eve', 'Charlie'];
let mutualFollowers = [];
for (let i = 0; i < userA_followers.length; i++) {
    for (let j = 0; j < userB_followers.length; j++) {
        if (userA_followers[i] === userB_followers[j]) {
            mutualFollowers.push(userA_followers[i]);
        }
    }
}
console.log('Mutual Followers:', mutualFollowers);

// 4. Calculating the intersection of two arrays
// Logs: Intersection of two arrays [2, 4]
const array1 = [1, 2, 3, 4];
const array2 = [2, 4, 6, 8];
let intersection = [];
for (let i = 0; i < array1.length; i++) {
    for (let j = 0; j < array2.length; j++) {
        if (array1[i] === array2[j]) {
            intersection.push(array1[i]);
        }
    }
}
console.log('Intersection:', intersection);

// 5. Creating a follow suggestion list (users not followed by User A)
// Logs: List of users not followed by User A from User B's followers
let followSuggestions = [];
for (let i = 0; i < userB_followers.length; i++) {
    let isFollowed = false;
    for (let j = 0; j < userA_followers.length; j++) {
        if (userB_followers[i] === userA_followers[j]) {
            isFollowed = true;
            break;
        }
    }
    if (!isFollowed) {
        followSuggestions.push(userB_followers[i]);
    }
}
console.log('Follow Suggestions:', followSuggestions);

// 6. Counting duplicate elements in an array
// Logs: Number of duplicate elements [3]
const arr = [1, 2, 3, 2, 4, 1, 1];
let duplicates = [];
for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
        if (arr[i] === arr[j] && !duplicates.includes(arr[i])) {
            duplicates.push(arr[i]);
        }
    }
}
console.log('Duplicates:', duplicates);

// 7. Checking if a 2D array (grid) contains a specific value
// Logs: Whether the grid contains the value (true or false)
const valueToFind = 5;
let found = false;
for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[i].length; j++) {
        if (grid[i][j] === valueToFind) {
            found = true;
            break;
        }
    }
    if (found) break;
}
console.log(`Value ${valueToFind} found:`, found);

// 8. Comparing products in an e-commerce app (comparing features)
// Logs: Features present in both products
const productA_features = ['WiFi', 'Bluetooth', 'GPS'];
const productB_features = ['Bluetooth', '4G', 'GPS'];
let commonFeatures = [];
for (let i = 0; i < productA_features.length; i++) {
    for (let j = 0; j < productB_features.length; j++) {
        if (productA_features[i] === productB_features[j]) {
            commonFeatures.push(productA_features[i]);
        }
    }
}
console.log('Common Features:', commonFeatures);

// 9. Checking for symmetrical matrices (common in games or grids)
// Logs: Whether the matrix is symmetrical
let isSymmetric = true;
for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[i].length; j++) {
        if (grid[i][j] !== grid[j][i]) {
            isSymmetric = false;
            break;
        }
    }
    if (!isSymmetric) break;
}
console.log('Is grid symmetric:', isSymmetric);

// 10. Finding common tags between two blog posts
// Logs: List of common tags between two blog posts
const post1_tags = ['JavaScript', 'Web', 'Programming'];
const post2_tags = ['Programming', 'Tutorial', 'JavaScript'];
let commonTags = [];
for (let i = 0; i < post1_tags.length; i++) {
    for (let j = 0; j < post2_tags.length; j++) {
        if (post1_tags[i] === post2_tags[j]) {
            commonTags.push(post1_tags[i]);
        }
    }
}
console.log('Common Tags:', commonTags);
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-loopingarrays', event)">looping through arrays</td>
          </tr>
          <tr id="detail-tag-loopingarrays" class="expandable-row-content">
            <td>
              <h3>looping through arrays</h3>
              <p>Looping through arrays in JavaScript is a fundamental operation that allows you to access and manipulate each element within an array. One common approach is using a `for` loop, which iterates over the array by starting from the first index (0) and continues until the last element is reached. The `.length` property of an array plays a crucial role in this process, as it returns the total number of elements in the array. By using this property, the loop can dynamically adjust to the size of the array, ensuring that it iterates through every element, regardless of the array's length. For example, in a `for` loop, you might use `i < array.length` as the condition, where `i` is the loop's counter variable. This condition ensures the loop continues running until it has processed every element. This method is highly efficient for accessing, modifying, or performing operations on each item in the array, making it a versatile tool for developers working with arrays in JavaScript.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Looping through an array of usernames to greet each user
// Logs: Hello, Alice! Hello, Bob! Hello, Charlie!
const usernames = ['Alice', 'Bob', 'Charlie'];
for (let i = 0; i < usernames.length; i++) {
    console.log(`Hello, ${usernames[i]}!`);
}

// 2. Looping through a list of product prices to calculate the total cost
// Logs: Total cost is: $60
const prices = [10, 20, 30];
let totalCost = 0;
for (let i = 0; i < prices.length; i++) {
    totalCost += prices[i];
}
console.log(`Total cost is: $${totalCost}`);

// 3. Looping through a list of posts to generate HTML snippets
// Logs: <div>Post 1</div> <div>Post 2</div> <div>Post 3</div>
const posts = ['Post 1', 'Post 2', 'Post 3'];
for (let i = 0; i < posts.length; i++) {
    console.log(`<div>${posts[i]}</div>`);
}

// 4. Looping through an array of likes to count how many likes are above 100
// Logs: 2 posts have more than 100 likes
const likes = [50, 150, 200, 80];
let count = 0;
for (let i = 0; i < likes.length; i++) {
    if (likes[i] > 100) {
        count++;
    }
}
console.log(`${count} posts have more than 100 likes`);

// 5. Looping through a list of comments to find the longest comment
// Logs: The longest comment is: "This is the longest comment!"
const comments = ['Nice post!', 'Great!', 'This is the longest comment!', 'Good job!'];
let longestComment = comments[0];
for (let i = 1; i < comments.length; i++) {
    if (comments[i].length > longestComment.length) {
        longestComment = comments[i];
    }
}
console.log(`The longest comment is: "${longestComment}"`);

// 6. Looping through a list of email addresses to check for invalid emails
// Logs: Invalid email found: "invalidemail.com"
const emails = ['user@example.com', 'admin@website.org', 'invalidemail.com'];
for (let i = 0; i < emails.length; i++) {
    if (!emails[i].includes('@')) {
        console.log(`Invalid email found: "${emails[i]}"`);
    }
}

// 7. Looping through a list of tasks to mark all as completed
// Logs: Task 1: completed, Task 2: completed, Task 3: completed
const tasks = ['Task 1', 'Task 2', 'Task 3'];
for (let i = 0; i < tasks.length; i++) {
    console.log(`${tasks[i]}: completed`);
}

// 8. Looping through an array of followers to display follower count
// Logs: You have 3 followers
const followers = ['Follower1', 'Follower2', 'Follower3'];
console.log(`You have ${followers.length} followers`);

// 9. Looping through an array of messages to find the first unread message
// Logs: First unread message is: "You have a new friend request"
const messages = ['Read: Welcome!', 'Unread: You have a new friend request', 'Unread: Don’t miss out on our sale!'];
let unreadMessage = null;
for (let i = 0; i < messages.length; i++) {
    if (messages[i].startsWith('Unread')) {
        unreadMessage = messages[i];
        break;
    }
}
console.log(`First unread message is: "${unreadMessage}"`);

// 10. Looping through a list of product ratings to calculate the average rating
// Logs: The average rating is: 4.2
const ratings = [5, 4, 3, 5, 4];
let sumRatings = 0;
for (let i = 0; i < ratings.length; i++) {
    sumRatings += ratings[i];
}
const averageRating = sumRatings / ratings.length;
console.log(`The average rating is: ${averageRating.toFixed(1)}`);
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-reverseloop', event)">reverse loop</td>
          </tr>
          <tr id="detail-tag-reverseloop" class="expandable-row-content">
            <td>
              <h3>reverse loop</h3>
              <p>Reverse for loops in JavaScript are a variation of the traditional for loop, where the loop starts from the last element of an array and iterates backward to the first element. This type of loop is useful when you need to process or manipulate elements in reverse order, such as when you want to iterate over an array from the end to the beginning. The structure of a reverse for loop typically involves initializing the loop counter to the last index of the array (which is the array's length minus one), setting the condition to continue the loop as long as the counter is greater than or equal to zero, and decrementing the counter in each iteration. This approach ensures that every element of the array is accessed in reverse order. Reverse loops are particularly helpful in situations where modifying the array during iteration might affect the remaining elements, as processing from the end can prevent unintended side effects.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Reverse loop to print numbers from 5 to 1
// Logs: 5 4 3 2 1
for (let i = 5; i >= 1; i--) {
    console.log(i);
}

// 2. Reverse loop to iterate through an array of names
// Logs: Charlie Bob Alice
const names = ['Alice', 'Bob', 'Charlie'];
for (let i = names.length - 1; i >= 0; i--) {
    console.log(names[i]);
}

// 3. Reverse loop to remove elements from an array while iterating
// Logs: [2] [2, 1] [2, 1, 0]
let numbers = [0, 1, 2, 3];
for (let i = numbers.length - 1; i >= 0; i--) {
    numbers.pop();
    console.log(numbers);
}

// 4. Reverse loop to build a string in reverse order
// Logs: "!dlroW olleH"
const str = "Hello World!";
let reversedStr = '';
for (let i = str.length - 1; i >= 0; i--) {
    reversedStr += str[i];
}
console.log(reversedStr);

// 5. Reverse loop to count down even numbers
// Logs: 10 8 6 4 2 0
for (let i = 10; i >= 0; i -= 2) {
    console.log(i);
}

// 6. Reverse loop to log only the last three elements of an array
// Logs: 3 4 5
const arr = [1, 2, 3, 4, 5];
for (let i = arr.length - 1; i >= arr.length - 3; i--) {
    console.log(arr[i]);
}

// 7. Reverse loop to filter out negative numbers
// Logs: [3, 0, 2]
let nums = [3, -1, 0, -4, 2];
let positiveNums = [];
for (let i = nums.length - 1; i >= 0; i--) {
    if (nums[i] >= 0) {
        positiveNums.push(nums[i]);
    }
}
console.log(positiveNums);

// 8. Reverse loop to find the first even number
// Logs: 4
const numbersArray = [1, 3, 5, 4, 7];
let firstEven = null;
for (let i = numbersArray.length - 1; i >= 0; i--) {
    if (numbersArray[i] % 2 === 0) {
        firstEven = numbersArray[i];
        break;
    }
}
console.log(firstEven);

// 9. Reverse loop to display array elements in reverse order
// Logs: 3 2 1
let smallArr = [1, 2, 3];
for (let i = smallArr.length - 1; i >= 0; i--) {
    console.log(smallArr[i]);
}

// 10. Reverse loop to check for palindromes
// Logs: true (since the word "madam" is a palindrome)
const word = "madam";
let isPalindrome = true;
for (let i = 0; i < word.length / 2; i++) {
    if (word[i] !== word[word.length - 1 - i]) {
        isPalindrome = false;
        break;
    }
}
console.log(isPalindrome);
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-forof', event)">for...of loop</td>
          </tr>
          <tr id="detail-tag-forof" class="expandable-row-content">
            <td>
              <h3>for...op loop</h3>
              <p>The `for...of` loop in JavaScript is a modern and concise way to iterate over iterable objects such as arrays, strings, maps, sets, and more. Unlike traditional `for` loops that require managing an index or counter, `for...of` automatically retrieves each element of the iterable in sequence, making the code cleaner and easier to read. This loop is particularly useful when you don't need the index or key of the items, just the values themselves. For example, when iterating over an array with `for...of`, each loop iteration directly accesses the array's elements, allowing you to perform operations on them without worrying about managing the loop's iteration index. This makes `for...of` ideal for simple iterations where only the values matter, contributing to more readable and maintainable code in JavaScript. However, it's important to note that `for...of` cannot be used to iterate over objects directly, as objects are not inherently iterable in JavaScript; instead, `for...in` or `Object.keys()` can be used for object iteration.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Loop through an array of numbers and log each number
// Logs: 1 2 3 4 5
const numbers = [1, 2, 3, 4, 5];
for (const num of numbers) {
    console.log(num);
}

// 2. Loop through an array of strings and log each string
// Logs: Apple Banana Cherry
const fruits = ['Apple', 'Banana', 'Cherry'];
for (const fruit of fruits) {
    console.log(fruit);
}

// 3. Loop through a string and log each character
// Logs: H e l l o
const str = "Hello";
for (const char of str) {
    console.log(char);
}

// 4. Loop through an array of objects and log a specific property
// Logs: Alice Bob Charlie
const users = [{ name: 'Alice' }, { name: 'Bob' }, { name: 'Charlie' }];
for (const user of users) {
    console.log(user.name);
}

// 5. Loop through a Set and log each value
// Logs: a b c
const mySet = new Set(['a', 'b', 'c']);
for (const value of mySet) {
    console.log(value);
}

// 6. Loop through a Map and log each key-value pair
// Logs: a: 1, b: 2, c: 3
const myMap = new Map([['a', 1], ['b', 2], ['c', 3]]);
for (const [key, value] of myMap) {
    console.log(`${key}: ${value}`);
}

// 7. Loop through an array and log the square of each number
// Logs: 1 4 9 16 25
for (const num of numbers) {
    console.log(num * num);
}

// 8. Loop through a list of boolean values and log whether each is true or false
// Logs: true false true false
const bools = [true, false, true, false];
for (const bool of bools) {
    console.log(bool);
}

// 9. Loop through an array and log the length of each string
// Logs: 5 6 6
const words = ['apple', 'banana', 'cherry'];
for (const word of words) {
    console.log(word.length);
}

// 10. Loop through an array of grades and log if they are passing
// Logs: Passed! Failed! Passed!
const grades = [80, 50, 90];
for (const grade of grades) {
    if (grade >= 60) {
        console.log("Passed!");
    } else {
        console.log("Failed!");
    }
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-breakcontinue', event)">break & continue keyword</td>
          </tr>
          <tr id="detail-tag-breakcontinue" class="expandable-row-content">
            <td>
              <h3>break & continue keyword</h3>
              <p>The `break` and `continue` keywords in JavaScript are powerful tools used to control the flow of loops. The `break` keyword is used to immediately exit a loop, terminating the loop's execution entirely and moving the control to the code that follows the loop. This is particularly useful in situations where a specific condition is met, and further iterations of the loop are unnecessary or could lead to undesirable outcomes. The `continue` keyword, on the other hand, is used to skip the current iteration of the loop and jump directly to the next iteration, effectively ignoring any code that follows it within the loop's current cycle. This is useful when certain conditions require bypassing part of the loop's body without exiting the loop altogether. Both `break` and `continue` can be used in various types of loops in JavaScript, including `for`, `while`, and `do...while` loops. They provide fine-grained control over loop execution, allowing developers to manage loop behavior based on specific conditions or logic within the loop.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Using break to exit a loop when a number is found
// Logs: 1 2 3
for (let i = 1; i <= 5; i++) {
    if (i === 4) {
        break;
    }
    console.log(i);
}

// 2. Using continue to skip even numbers
// Logs: 1 3 5
for (let i = 1; i <= 5; i++) {
    if (i % 2 === 0) {
        continue;
    }
    console.log(i);
}

// 3. Using break in a while loop to stop when a condition is met
// Logs: 0 1 2
let count = 0;
while (count < 5) {
    if (count === 3) {
        break;
    }
    console.log(count);
    count++;
}

// 4. Using continue in a while loop to skip a specific iteration
// Logs: 0 1 3 4
count = 0;
while (count < 5) {
    count++;
    if (count === 2) {
        continue;
    }
    console.log(count);
}

// 5. Using break in a for loop to exit when a specific string is found
// Logs: Alice Bob
const names = ['Alice', 'Bob', 'Charlie', 'Dave'];
for (let i = 0; i < names.length; i++) {
    if (names[i] === 'Charlie') {
        break;
    }
    console.log(names[i]);
}

// 6. Using continue in a for loop to skip a specific string
// Logs: Alice Bob Dave
for (let i = 0; i < names.length; i++) {
    if (names[i] === 'Charlie') {
        continue;
    }
    console.log(names[i]);
}

// 7. Using break in a for loop to stop checking after finding the first match
// Logs: 1st found: 5
const numbers = [1, 3, 5, 7, 9];
for (const num of numbers) {
    if (num % 5 === 0) {
        console.log('1st found:', num);
        break;
    }
}

// 8. Using continue to skip non-positive numbers
// Logs: 1 5 9
const moreNumbers = [1, -3, 5, 0, 9];
for (const num of moreNumbers) {
    if (num <= 0) {
        continue;
    }
    console.log(num);
}

// 9. Using break to exit nested loops when a condition is met
// Logs: 1 1, 1 2, 1 3
outerLoop: for (let i = 1; i <= 3; i++) {
    for (let j = 1; j <= 3; j++) {
        if (j === 4) {
            break outerLoop;
        }
        console.log(i, j);
    }
}

// 10. Using continue to skip a specific iteration in a nested loop
// Logs: 1 1, 1 2, 2 1, 2 2
for (let i = 1; i <= 2; i++) {
    for (let j = 1; j <= 2; j++) {
        if (i === 2 && j === 3) {
            continue;
        }
        console.log(i, j);
    }
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-while', event)">while loop</td>
          </tr>
          <tr id="detail-tag-while" class="expandable-row-content">
            <td>
              <h3>while loop</h3>
              <p>The `while` loop in JavaScript is a control flow statement that allows code to be executed repeatedly based on a given Boolean condition. The loop continues to execute as long as the specified condition remains true. The `while` loop is particularly useful when the number of iterations is not known beforehand, as the loop will run until the condition evaluates to false. Inside the loop, any code block can be placed, and it's crucial to ensure that the loop includes logic that will eventually make the condition false, otherwise, the loop will run indefinitely, leading to an infinite loop. This loop is often used for scenarios like waiting for a certain state to be reached, repeatedly processing items until none are left, or iterating over user input until a valid response is provided. The simplicity of the `while` loop makes it a fundamental tool in JavaScript for managing repetitive tasks where the exact number of iterations cannot be determined before entering the loop.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Simple countdown using while loop
// Logs: 5 4 3 2 1
let count = 5;
while (count > 0) {
    console.log(count);
    count--;
}

// 2. Reading input until a valid number is provided
// Logs: "Please enter a valid number." until a valid number is entered
let input;
while (isNaN(input)) {
    input = prompt("Enter a number:");
    if (isNaN(input)) {
        console.log("Please enter a valid number.");
    }
}
// Logs: "Valid number entered!"
console.log("Valid number entered!");

// 3. Loop until a random number greater than 0.8 is generated
// Logs random numbers until one greater than 0.8 is found
let num;
while (num <= 0.8) {
    num = Math.random();
    console.log(num);
}
// Logs: "Number greater than 0.8 found!"
console.log("Number greater than 0.8 found!");

// 4. Accumulating sum until it exceeds 100
// Logs: the sum at each step until it exceeds 100
let sum = 0;
while (sum <= 100) {
    sum += Math.floor(Math.random() * 20);
    console.log(`Current sum: ${sum}`);
}
// Logs: "Sum exceeded 100!"
console.log("Sum exceeded 100!");

// 5. Removing elements from an array until empty
// Logs each removed element until the array is empty
let numbers = [1, 2, 3, 4, 5];
while (numbers.length > 0) {
    const removed = numbers.pop();
    console.log(`Removed: ${removed}`);
}
// Logs: "Array is now empty"
console.log("Array is now empty");

// 6. Looping until a specific value is found in an array
// Logs each value until the specific value (e.g., 7) is found
let values = [2, 4, 6, 7, 9, 12];
let i = 0;
while (values[i] !== 7) {
    console.log(`Checked: ${values[i]}`);
    i++;
}
// Logs: "Value 7 found!"
console.log("Value 7 found!");

// 7. Repeatedly prompt until user clicks "OK"
// Logs: "Do you want to continue?" until user clicks "OK"
let proceed = false;
while (!proceed) {
    proceed = confirm("Do you want to continue?");
}
// Logs: "Continuing..."
console.log("Continuing...");

// 8. Loop until a number divisible by 5 is found
// Logs random numbers until one divisible by 5 is found
let number;
while (number % 5 !== 0) {
    number = Math.floor(Math.random() * 100);
    console.log(number);
}
// Logs: "Found a number divisible by 5!"
console.log("Found a number divisible by 5!");

// 9. Emptying a string by removing its last character
// Logs the string until it's empty
let text = "JavaScript";
while (text.length > 0) {
    text = text.slice(0, -1);
    console.log(text);
}
// Logs: "String is now empty"
console.log("String is now empty");

// 10. Counting down in an array until a specific value is found
// Logs each number until a specific value (e.g., 3) is found, then stops
let countdown = [5, 4, 3, 2, 1];
while (countdown.length > 0) {
    const current = countdown.shift();
    console.log(current);
    if (current === 3) {
        break;
    }
}
// Logs: "Stopped at value 3"
console.log("Stopped at value 3");
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-dowhile', event)">do...while loop</td>
          </tr>
          <tr id="detail-tag-dowhile" class="expandable-row-content">
            <td>
              <h3>do...while loop</h3>
              <p>The `do...while` loop in JavaScript is a control flow statement that allows code to be executed repeatedly based on a given condition, but with a key difference compared to a `while` loop: the `do...while` loop guarantees that the code inside the loop will run at least once, regardless of whether the condition is initially true or false. This is because the condition is evaluated after the code block is executed. The structure of the `do...while` loop starts with the `do` keyword, followed by a block of code enclosed in curly braces, and then the `while` keyword with the condition in parentheses. After the code block is executed, the condition is checked, and if it evaluates to true, the loop runs again. This loop is particularly useful in situations where the loop's code must run at least once, such as when you need to prompt a user for input and you want to ensure the prompt appears at least once before any validation occurs. The `do...while` loop provides a straightforward way to handle scenarios where the loop's logic requires an initial execution before condition checking.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Basic example: Simple countdown using do...while loop
// Logs: 5 4 3 2 1
let count = 5;
do {
    console.log(count);
    count--;
} while (count > 0);

// 2. Basic example: Logging numbers from 1 to 5
// Logs: 1 2 3 4 5
let num = 1;
do {
    console.log(num);
    num++;
} while (num <= 5);

// 3. Basic example: Executing a loop once even if the condition is false
// Logs: "This runs at least once!"
let flag = false;
do {
    console.log("This runs at least once!");
} while (flag);

// 4. Basic example: Looping until a specific condition is met
// Logs: 2 4 6
let number = 2;
do {
    console.log(number);
    number += 2;
} while (number <= 6);

// 5. Basic example: Looping through an array until it's empty
// Logs: Removed: 3 Removed: 2 Removed: 1
let numbers = [3, 2, 1];
do {
    console.log(`Removed: ${numbers.pop()}`);
} while (numbers.length > 0);

// 6. Intermediate example: Accumulating random numbers until a threshold is met
// Logs: random numbers until sum exceeds 20, e.g., "Sum: 3", "Sum: 10", "Sum: 22"
let sum = 0;
do {
    const randomNumber = Math.floor(Math.random() * 10) + 1;
    sum += randomNumber;
    console.log(`Sum: ${sum}`);
} while (sum <= 20);
// Logs: "Threshold of 20 exceeded!"

// 7. Intermediate example: Prompting user until a valid age is entered
// Logs: "Please enter a valid age." until a number between 1 and 120 is entered
let age;
do {
    age = prompt("Enter your age (1-120):");
    if (isNaN(age) || age < 1 || age > 120) {
        console.log("Please enter a valid age.");
    }
} while (isNaN(age) || age < 1 || age > 120);
// Logs: "Valid age entered!"

// 8. Intermediate example: Emptying a string by removing characters one by one
// Logs: "JavaScript" "JavaScrip" "JavaScri" ... "J"
let text = "JavaScript";
do {
    text = text.slice(0, -1);
    console.log(text);
} while (text.length > 0);
// Logs: "String is now empty"

// 9. Intermediate example: Random number generation until a specific number is found
// Logs: random numbers until a number divisible by 5 is generated, e.g., "7", "14", "5"
let randomNum;
do {
    randomNum = Math.floor(Math.random() * 20) + 1;
    console.log(randomNum);
} while (randomNum % 5 !== 0);
// Logs: "Number divisible by 5 found!"

// 10. Intermediate example: Simulating a basic guessing game
// Logs: "Incorrect guess." until the correct number is guessed
const secretNumber = Math.floor(Math.random() * 10) + 1;
let guess;
do {
    guess = prompt("Guess the secret number (1-10):");
    if (guess != secretNumber) {
        console.log("Incorrect guess.");
    }
} while (guess != secretNumber);
// Logs: "Congratulations! You guessed it!"
console.log("Congratulations! You guessed it!");
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-loopingobjects', event)">looping through objects</td>
          </tr>
          <tr id="detail-tag-loopingobjects" class="expandable-row-content">
            <td>
              <h3>looping through objects</h3>
              <p>Looping through objects in JavaScript is a common task that allows you to access and manipulate the properties and values of an object. Unlike arrays, which are indexed and iterable using loops like `for` or `for...of`, objects are collections of key-value pairs where each key is a unique string (or symbol) and the values can be any data type. To loop through an object, you typically use the `for...in` loop, which iterates over the object's enumerable properties, allowing you to access each key. Within this loop, you can retrieve the corresponding value using the bracket notation or dot notation (e.g., `object[key]`). Additionally, modern JavaScript offers methods like `Object.keys()`, `Object.values()`, and `Object.entries()` to retrieve an array of keys, values, or key-value pairs respectively, which can then be looped over using a `for` loop, `forEach`, or `for...of`. These methods provide flexibility in how you access and manipulate object data, making them powerful tools for handling objects in JavaScript.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Using for...in to loop through an object's properties
// Logs: name: Alice, age: 30, occupation: Developer
const person = { name: "Alice", age: 30, occupation: "Developer" };
for (const key in person) {
    console.log(`${key}: ${person[key]}`);
}

// 2. Using Object.keys() to loop through an object's keys
// Logs: name, age, occupation
const keys = Object.keys(person);
for (const key of keys) {
    console.log(key);
}

// 3. Using Object.values() to loop through an object's values
// Logs: Alice, 30, Developer
const values = Object.values(person);
for (const value of values) {
    console.log(value);
}

// 4. Using Object.entries() to loop through an object's key-value pairs
// Logs: name: Alice, age: 30, occupation: Developer
const entries = Object.entries(person);
for (const [key, value] of entries) {
    console.log(`${key}: ${value}`);
}

// 5. Looping through a nested object
// Logs: address: street: 123 Main St, city: Anytown, zip: 12345
const user = {
    name: "John",
    address: {
        street: "123 Main St",
        city: "Anytown",
        zip: "12345"
    }
};
for (const key in user) {
    if (typeof user[key] === 'object') {
        for (const subKey in user[key]) {
            console.log(`${key}: ${subKey}: ${user[key][subKey]}`);
        }
    } else {
        console.log(`${key}: ${user[key]}`);
    }
}

// 6. Looping through an object to calculate the total of numeric properties
// Logs: Total: 55
const scores = { math: 15, science: 20, english: 20 };
let total = 0;
for (const key in scores) {
    total += scores[key];
}
console.log(`Total: ${total}`);

// 7. Looping through an object to create a new array of formatted strings
// Logs: ["Math: 15", "Science: 20", "English: 20"]
let formattedScores = [];
for (const key in scores) {
    formattedScores.push(`${key.charAt(0).toUpperCase() + key.slice(1)}: ${scores[key]}`);
}
console.log(formattedScores);

// 8. Using for...in with inherited properties (demonstrates skipping prototype properties)
// Logs: name: Laptop, price: 1200
function Product(name, price) {
    this.name = name;
    this.price = price;
}
Product.prototype.category = "Electronics";
const product = new Product("Laptop", 1200);
for (const key in product) {
    if (product.hasOwnProperty(key)) {
        console.log(`${key}: ${product[key]}`);
    }
}

// 9. Looping through an object's keys and converting them to uppercase
// Logs: NAME: Alice, AGE: 30, OCCUPATION: Developer
for (const key in person) {
    const upperKey = key.toUpperCase();
    console.log(`${upperKey}: ${person[key]}`);
}

// 10. Looping through an array of objects
// Logs: Name: Alice, Occupation: Developer; Name: Bob, Occupation: Designer
const users = [
    { name: "Alice", occupation: "Developer" },
    { name: "Bob", occupation: "Designer" }
];
for (const user of users) {
    console.log(`Name: ${user.name}, Occupation: ${user.occupation}`);
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-forinloop', event)">for...in loop</td>
          </tr>
          <tr id="detail-tag-forinloop" class="expandable-row-content">
            <td>
              <h3>for...in loop</h3>
              <p>The `for...in` loop in JavaScript is a control structure used to iterate over the enumerable properties of an object. When you use a `for...in` loop, it cycles through each key or property name within the object, allowing you to access and manipulate the associated values. This loop is particularly useful when dealing with objects where you want to perform operations on each property without needing to know the specific keys in advance. However, it's important to note that the `for...in` loop also iterates over properties that are inherited through the object's prototype chain, which can sometimes lead to unintended results if you are only interested in the object's own properties. To avoid this, developers often use the `hasOwnProperty()` method within the loop to ensure that only the object's own properties are processed. While the `for...in` loop is designed for objects, it is generally not recommended for use with arrays because it does not guarantee the order of iteration and may include inherited properties, which can lead to unexpected behavior.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// 1. Basic example: Looping through an object's properties
// Logs: name: Alice, age: 30, occupation: Developer
const person = { name: "Alice", age: 30, occupation: "Developer" };
for (const key in person) {
    console.log(`${key}: ${person[key]}`);
}

// 2. Looping through an object's properties with hasOwnProperty()
// Logs: name: Alice, age: 30, occupation: Developer (only own properties)
for (const key in person) {
    if (person.hasOwnProperty(key)) {
        console.log(`${key}: ${person[key]}`);
    }
}

// 3. Looping through an object's properties and calculating total of numeric values
// Logs: Total score: 150
const scores = { math: 50, science: 40, english: 60 };
let total = 0;
for (const subject in scores) {
    total += scores[subject];
}
console.log(`Total score: ${total}`);

// 4. Looping through an object with inherited properties
// Logs: name: Laptop, price: 1200, category: Electronics (logs inherited properties too)
function Product(name, price) {
    this.name = name;
    this.price = price;
}
Product.prototype.category = "Electronics";
const product = new Product("Laptop", 1200);
for (const key in product) {
    console.log(`${key}: ${product[key]}`);
}

// 5. Looping through an object and converting keys to uppercase
// Logs: NAME: Alice, AGE: 30, OCCUPATION: Developer
for (const key in person) {
    const upperKey = key.toUpperCase();
    console.log(`${upperKey}: ${person[key]}`);
}

// 6. Looping through an object and counting the number of properties
// Logs: Number of properties: 3
let propertyCount = 0;
for (const key in person) {
    propertyCount++;
}
console.log(`Number of properties: ${propertyCount}`);

// 7. Looping through a nested object
// Logs: street: 123 Main St, city: Anytown, zip: 12345
const user = {
    name: "John",
    address: {
        street: "123 Main St",
        city: "Anytown",
        zip: "12345"
    }
};
for (const key in user.address) {
    console.log(`${key}: ${user.address[key]}`);
}

// 8. Looping through an object to collect keys in an array
// Logs: ["name", "age", "occupation"]
let keysArray = [];
for (const key in person) {
    keysArray.push(key);
}
console.log(keysArray);

// 9. Looping through an object and logging only properties with specific conditions
// Logs: math: 50, english: 60 (logs only scores 50 and above)
for (const subject in scores) {
    if (scores[subject] >= 50) {
        console.log(`${subject}: ${scores[subject]}`);
    }
}

// 10. Looping through an object's properties and values to create a formatted string
// Logs: Alice is 30 years old and works as a Developer.
let description = "";
for (const key in person) {
    if (key === "name") {
        description += `${person[key]} is `;
    } else if (key === "age") {
        description += `${person[key]} years old and `;
    } else if (key === "occupation") {
        description += `works as a ${person[key]}.`;
    }
}
console.log(description);
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-differences', event)">differences</td>
          </tr>
          <tr id="detail-tag-differences" class="expandable-row-content">
            <td>
              <h3>differences</h3>
              <p>In JavaScript, `for`, `for...of`, `for...in`, `while`, and `do...while` loops are all used to perform repetitive tasks, but they differ in syntax and use cases. The `for` loop is the most traditional and flexible, allowing you to define an initializer, a condition, and an increment/decrement expression, making it ideal for iterating over arrays or performing tasks a specific number of times. The `for...of` loop is designed specifically for iterating over iterable objects like arrays, strings, and sets, providing a simple way to access the values directly without needing to manage an index, making it perfect for array iteration when you don't need to modify the loop's behavior based on the index. The `for...in` loop, on the other hand, is used to iterate over the enumerable properties of an object, allowing you to access each key in turn, but it's not ideal for arrays because it can include inherited properties and doesn't guarantee the order of iteration. The `while` loop runs as long as a specified condition is true, making it useful when the number of iterations isn't known beforehand and depends on dynamic factors. Finally, the `do...while` loop is similar to the `while` loop but guarantees that the loop body will execute at least once, even if the condition is false from the start, which is useful when the loop's action needs to be performed at least once regardless of the condition. Choosing the right loop depends on the specific task: use `for` for counting, `for...of` for iterating over values, `for...in` for object properties, `while` when the condition must be checked before each iteration, and `do...while` when the loop must run at least once.</p>
              <br />
            </td>
          </tr>
          <tr>
            <td id="objects" class="tableletters">Objects</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-objectsoverview', event)">overview</td>
          </tr>
          <tr id="detail-tag-objectsoverview" class="expandable-row-content">
            <td>
              <h3>overview</h3>
              <p>In JavaScript, an object is a complex data structure that allows you to store collections of data and more complex entities. Objects are used to represent real-world entities by encapsulating related data and behavior. Each object is a collection of properties, where a property is an association between a key (or name) and a value. The value can be a primitive data type, another object, or a function, which in this context is known as a method. The basic syntax for creating an object involves using curly braces `{}` to define an object literal. Inside the curly braces, properties are defined as key-value pairs separated by colons, with each pair separated by commas. For example, `let person = { name: "John", age: 30, greet: function() { console.log("Hello!"); } };` defines an object named `person` with properties `name`, `age`, and a method `greet`. You can access or modify the properties using dot notation (e.g., `person.name`) or bracket notation (e.g., `person["age"]`). Objects in JavaScript are dynamic, meaning you can add, modify, or delete properties after the object is created. This flexibility makes objects a foundational component for organizing and managing data in JavaScript.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Basic object with a string property
let car = { 
  brand: "Toyota", 
  model: "Camry" 
};
console.log(car);
// Logs: { brand: "Toyota", model: "Camry" }

// Example 2: Object with a number property
let smartphone = { 
  brand: "Apple", 
  price: 999 
};
console.log(smartphone);
// Logs: { brand: "Apple", price: 999 }

// Example 3: Object with a boolean property
let user = { 
  name: "Alice", 
  isLoggedIn: true 
};
console.log(user);
// Logs: { name: "Alice", isLoggedIn: true }

// Example 4: Object with a method
let dog = { 
  name: "Buddy", 
  bark: function() { 
    console.log("Woof!"); 
  } 
};
dog.bark();
// Logs: "Woof!" (when the method is called)

// Example 5: Nested object
let student = { 
  name: "John", 
  address: { 
    street: "123 Main St", 
    city: "New York" 
  } 
};
console.log(student);
// Logs: { name: "John", address: { street: "123 Main St", city: "New York" } }

// Example 6: Object with an array property
let book = { 
  title: "The Great Gatsby", 
  genres: ["Classic", "Fiction"] 
};
console.log(book);
// Logs: { title: "The Great Gatsby", genres: ["Classic", "Fiction"] }

// Example 7: Adding a property to an existing object
let laptop = { 
  brand: "Dell" 
};
laptop.model = "XPS 13";
console.log(laptop);
// Logs: { brand: "Dell", model: "XPS 13" }

// Example 8: Deleting a property from an object
let movie = { 
  title: "Inception", 
  director: "Christopher Nolan" 
};
delete movie.director;
console.log(movie);
// Logs: { title: "Inception" } (after `director` property is deleted)

// Example 9: Checking if a property exists in an object
let house = { 
  bedrooms: 3, 
  bathrooms: 2 
};
console.log("bathrooms" in house);
// Logs: true (since `bathrooms` exists in the `house` object)

// Example 10: Using a function to create objects (constructor function)
function Person(name, age) {
  this.name = name;
  this.age = age;
}
let person1 = new Person("Sarah", 28);
console.log(person1);
// Logs: { name: "Sarah", age: 28 }
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-accessingproperties', event)">accessing properties</td>
          </tr>
          <tr id="detail-tag-accessingproperties" class="expandable-row-content">
            <td>
              <h3>accessing properties</h3>
              <p>In JavaScript, accessing properties in objects can be done using two main methods: dot notation and bracket notation. Dot notation is the most common and straightforward way to access an object's properties. You simply write the object's name, followed by a dot, and then the property name, like this: `objectName.propertyName`. For example, if you have an object `person` with a property `name`, you can access it with `person.name`. Bracket notation, on the other hand, is more flexible and is often used when the property name is stored in a variable or when the property name contains spaces or special characters. It involves writing the object's name, followed by the property name inside square brackets, like this: `objectName["propertyName"]`. For example, you could access the `name` property with `person["name"]`. Bracket notation is particularly useful when dealing with dynamic property names, allowing you to pass in a variable or expression that evaluates to the property name. Both methods are essential for working with objects in JavaScript, providing different options depending on the needs of the code.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Accessing a property using dot notation
let car = { 
  brand: "Toyota", 
  model: "Camry" 
};
let carBrand = car.brand;
console.log(carBrand);
// Logs: "Toyota"

// Example 2: Accessing a property using bracket notation
let smartphone = { 
  brand: "Apple", 
  price: 999 
};
let phoneBrand = smartphone["brand"];
console.log(phoneBrand);
// Logs: "Apple"

// Example 3: Accessing a property with a variable key using bracket notation
let user = { 
  name: "Alice", 
  isLoggedIn: true 
};
let propertyKey = "name";
let userName = user[propertyKey];
console.log(userName);
// Logs: "Alice"

// Example 4: Accessing a nested object property using dot notation
let student = { 
  name: "John", 
  address: { 
    street: "123 Main St", 
    city: "New York" 
  } 
};
let studentCity = student.address.city;
console.log(studentCity);
// Logs: "New York"

// Example 5: Accessing a nested object property using bracket notation
let company = { 
  name: "Tech Corp", 
  employees: { 
    count: 500, 
    locations: ["New York", "San Francisco"] 
  } 
};
let employeeCount = company["employees"]["count"];
console.log(employeeCount);
// Logs: 500

// Example 6: Accessing an array within an object using dot notation
let book = { 
  title: "The Great Gatsby", 
  genres: ["Classic", "Fiction"] 
};
let firstGenre = book.genres[0];
console.log(firstGenre);
// Logs: "Classic"

// Example 7: Accessing an array within an object using bracket notation
let movie = { 
  title: "Inception", 
  cast: ["Leonardo DiCaprio", "Joseph Gordon-Levitt"] 
};
let leadActor = movie["cast"][0];
console.log(leadActor);
// Logs: "Leonardo DiCaprio"

// Example 8: Checking if a property exists using "in" keyword
let laptop = { 
  brand: "Dell", 
  model: "XPS 13" 
};
let hasModel = "model" in laptop;
console.log(hasModel);
// Logs: true

// Example 9: Accessing a method within an object using dot notation
let dog = { 
  name: "Buddy", 
  bark: function() { 
    return "Woof!"; 
  } 
};
let dogBark = dog.bark();
console.log(dogBark);
// Logs: "Woof!"

// Example 10: Accessing a non-existent property
let house = { 
  bedrooms: 3, 
  bathrooms: 2 
};
let garage = house.garage;
console.log(garage);
// Logs: undefined
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-updatingproperties', event)">updating properties</td>
          </tr>
          <tr id="detail-tag-updatingproperties" class="expandable-row-content">
            <td>
              <h3>updating properties</h3>
              <p>In JavaScript, updating or mutating properties in objects is a straightforward process, regardless of whether the object was declared using `let` or `const`. To update a property, you simply access the property using either dot notation or bracket notation and assign it a new value. For example, if you have an object `person` with a property `age`, you can update it with `person.age = 30`. If the object was declared with `let`, you can freely update its properties and even reassign the entire object to a new one. However, if the object was declared with `const`, while you cannot reassign the object itself (i.e., you can't make it reference a completely new object), you can still freely mutate its properties. This means you can change existing properties, add new ones, or delete them, even though the reference to the object remains constant. This behavior is possible because `const` only ensures that the reference to the object is immutable, not the contents of the object itself. Therefore, mutating an object's properties is common and works the same way regardless of whether `let` or `const` was used in the declaration.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Updating a property in an object declared with let
let car = { 
  brand: "Toyota", 
  model: "Camry" 
};
car.model = "Corolla";
console.log(car);
// Logs: { brand: "Toyota", model: "Corolla" }

// Example 2: Updating a property in an object declared with const
const smartphone = { 
  brand: "Apple", 
  price: 999 
};
smartphone.price = 1099;
console.log(smartphone);
// Logs: { brand: "Apple", price: 1099 }

// Example 3: Adding a new property to an object declared with let
let user = { 
  name: "Alice", 
  isLoggedIn: true 
};
user.age = 25;
console.log(user);
// Logs: { name: "Alice", isLoggedIn: true, age: 25 }

// Example 4: Adding a new property to an object declared with const
const student = { 
  name: "John", 
  grade: "A" 
};
student.age = 18;
console.log(student);
// Logs: { name: "John", grade: "A", age: 18 }

// Example 5: Updating a nested property in an object declared with let
let book = { 
  title: "The Great Gatsby", 
  details: { 
    author: "F. Scott Fitzgerald", 
    year: 1925 
  } 
};
book.details.year = 2024;
console.log(book);
// Logs: { title: "The Great Gatsby", details: { author: "F. Scott Fitzgerald", year: 2024 } }

// Example 6: Updating a nested property in an object declared with const
const laptop = { 
  brand: "Dell", 
  specs: { 
    ram: "8GB", 
    storage: "256GB" 
  } 
};
laptop.specs.ram = "16GB";
console.log(laptop);
// Logs: { brand: "Dell", specs: { ram: "16GB", storage: "256GB" } }

// Example 7: Removing a property from an object declared with let (setting it to undefined)
let movie = { 
  title: "Inception", 
  director: "Christopher Nolan" 
};
movie.director = undefined;
console.log(movie);
// Logs: { title: "Inception", director: undefined }

// Example 8: Removing a property from an object declared with const (setting it to null)
const house = { 
  bedrooms: 3, 
  bathrooms: 2 
};
house.bathrooms = null;
console.log(house);
// Logs: { bedrooms: 3, bathrooms: null }

// Example 9: Changing a property type in an object declared with let
let person = { 
  name: "Sarah", 
  age: 30 
};
person.age = "Thirty";
console.log(person);
// Logs: { name: "Sarah", age: "Thirty" }

// Example 10: Changing a property type in an object declared with const
const animal = { 
  species: "Dog", 
  weight: 50 
};
animal.weight = "Fifty pounds";
console.log(animal);
// Logs: { species: "Dog", weight: "Fifty pounds" }
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-deletingproperties', event)">deleting properties</td>
          </tr>
          <tr id="detail-tag-deletingproperties" class="expandable-row-content">
            <td>
              <h3>deleting properties</h3>
              <p>In JavaScript, deleting properties from objects can be done using the `delete` operator. When you want to remove a specific property from an object, you can use `delete` followed by the object and the property name. For example, `delete person.age` would remove the `age` property from the `person` object. Once a property is deleted, it is no longer accessible and will return `undefined` if you try to reference it. The `delete` operator only affects the specific property and does not affect other properties of the object. It's important to note that `delete` only removes the property from the object itself and not from the object's prototype chain, meaning if the property is inherited from a prototype, it will still be accessible through the prototype. Additionally, `delete` works on objects declared with both `let` and `const`, as it doesn't affect the reference to the object but merely removes the specific property from the object's structure. This operation is useful when you need to dynamically manage the properties of an object, particularly when cleaning up or altering the object's data.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Deleting a property from an object declared with let
let car = { 
  brand: "Toyota", 
  model: "Camry" 
};
delete car.model;
console.log(car);
// Logs: { brand: "Toyota" }

// Example 2: Deleting a property from an object declared with const
const smartphone = { 
  brand: "Apple", 
  price: 999 
};
delete smartphone.price;
console.log(smartphone);
// Logs: { brand: "Apple" }

// Example 3: Deleting a nested property from an object
let user = { 
  name: "Alice", 
  profile: { 
    age: 25, 
    location: "New York" 
  } 
};
delete user.profile.age;
console.log(user);
// Logs: { name: "Alice", profile: { location: "New York" } }

// Example 4: Deleting a method from an object
const dog = { 
  name: "Buddy", 
  bark: function() { 
    return "Woof!"; 
  } 
};
delete dog.bark;
console.log(dog);
// Logs: { name: "Buddy" }

// Example 5: Deleting a property and checking its existence
let book = { 
  title: "1984", 
  author: "George Orwell" 
};
delete book.author;
console.log("author" in book);
// Logs: false

// Example 6: Deleting a property with bracket notation
const movie = { 
  title: "The Matrix", 
  director: "Wachowski" 
};
delete movie["director"];
console.log(movie);
// Logs: { title: "The Matrix" }

// Example 7: Deleting a dynamically accessed property
let person = { 
  name: "John", 
  age: 30 
};
let prop = "age";
delete person[prop];
console.log(person);
// Logs: { name: "John" }

// Example 8: Deleting a property that doesn't exist
const house = { 
  bedrooms: 3, 
  bathrooms: 2 
};
delete house.garage;
console.log(house);
// Logs: { bedrooms: 3, bathrooms: 2 }

// Example 9: Deleting a property and adding it back later
let laptop = { 
  brand: "Dell", 
  model: "XPS 13" 
};
delete laptop.model;
laptop.model = "XPS 15";
console.log(laptop);
// Logs: { brand: "Dell", model: "XPS 15" }

// Example 10: Deleting all properties from an object
let settings = { 
  theme: "dark", 
  notifications: true 
};
delete settings.theme;
delete settings.notifications;
console.log(settings);
// Logs: {}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-objectmethod', event)">methods</td>
          </tr>
          <tr id="detail-tag-objectmethod" class="expandable-row-content">
            <td>
              <h3>methods</h3>
              <p>In JavaScript, methods are functions that are defined within an object and are used to perform actions related to that object. These methods allow objects to encapsulate behavior along with data, making it easier to manage and manipulate the object's state. A method is defined by creating a property within the object where the value is a function. For example, in an object representing a car, you might have a method called `startEngine` that logs a message or changes the state of the car. Methods can access and modify the properties of the object they belong to using the `this` keyword, which refers to the object itself. This ability to combine data and behavior in a single entity makes methods a powerful feature of objects, enabling more organized and modular code. Methods are a fundamental aspect of object-oriented programming in JavaScript, providing a way to define and reuse functionality that is directly tied to specific data structures.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Basic method in an object
let car = { 
  brand: "Toyota", 
  model: "Camry", 
  startEngine: function() { 
    return "Engine started"; 
  } 
};
console.log(car.startEngine());
// Logs: "Engine started"

// Example 2: Method that accesses object properties using 'this'
let smartphone = { 
  brand: "Apple", 
  model: "iPhone 12", 
  getFullName: function() { 
    return this.brand + " " + this.model; 
  } 
};
console.log(smartphone.getFullName());
// Logs: "Apple iPhone 12"

// Example 3: Method that updates object properties
let user = { 
  name: "Alice", 
  age: 25, 
  incrementAge: function() { 
    this.age += 1; 
  } 
};
user.incrementAge();
console.log(user.age);
// Logs: 26

// Example 4: Method that takes parameters
let calculator = { 
  add: function(a, b) { 
    return a + b; 
  } 
};
console.log(calculator.add(5, 3));
// Logs: 8

// Example 5: Method that uses a loop
let numbers = { 
  values: [1, 2, 3, 4], 
  sum: function() { 
    let total = 0; 
    for(let i = 0; i < this.values.length; i++) { 
      total += this.values[i]; 
    }
    return total;
  } 
};
console.log(numbers.sum());
// Logs: 10

// Example 6: Method that returns another method
let greeter = { 
  greet: function(name) { 
    return function() { 
      return "Hello, " + name; 
    }; 
  } 
};
let greetJohn = greeter.greet("John");
console.log(greetJohn());
// Logs: "Hello, John"

// Example 7: Method that modifies an array property
let playlist = { 
  songs: ["Song 1", "Song 2"], 
  addSong: function(song) { 
    this.songs.push(song); 
  } 
};
playlist.addSong("Song 3");
console.log(playlist.songs);
// Logs: ["Song 1", "Song 2", "Song 3"]

// Example 8: Method that checks for a condition
let person = { 
  name: "Bob", 
  age: 20, 
  canVote: function() { 
    return this.age >= 18; 
  } 
};
console.log(person.canVote());
// Logs: true

// Example 9: Method that returns a formatted string
let book = { 
  title: "1984", 
  author: "George Orwell", 
  getDetails: function() { 
    return `${this.title} by ${this.author}`; 
  } 
};
console.log(book.getDetails());
// Logs: "1984 by George Orwell"

// Example 10: Method that deletes a property from the object
let house = { 
  rooms: 4, 
  hasGarage: true, 
  removeGarage: function() { 
    delete this.hasGarage; 
  } 
};
house.removeGarage();
console.log(house);
// Logs: { rooms: 4 }
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-nestedobjects', event)">nested objects</td>
          </tr>
          <tr id="detail-tag-nestedobjects" class="expandable-row-content">
            <td>
              <h3>nested objects</h3>
              <p>Nested objects in JavaScript refer to objects that are contained within other objects, allowing for a hierarchical structure of data. This nesting can represent more complex relationships between data, such as an object representing a person containing another object that represents the person's address. To access properties within nested objects, you can use a combination of dot notation and bracket notation. Starting from the outermost object, you chain property names to drill down to the desired level. For example, if you have an object `person` with a nested object `address` that contains a property `city`, you would access the city with `person.address.city`. If any of the property names contain spaces or special characters, or if the property name is dynamic, you can use bracket notation like `person["address"]["city"]`. It's important to ensure that each level of the object exists before trying to access deeper properties to avoid errors. Nested objects are a powerful way to model real-world data structures in JavaScript, allowing for organized and manageable code when dealing with complex data.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Basic nested object
let person = { 
  name: "John", 
  address: { 
    street: "123 Main St", 
    city: "New York" 
  } 
};
console.log(person.address.city);
// Logs: "New York"

// Example 2: Nested object with multiple levels
let company = { 
  name: "Tech Corp", 
  departments: { 
    hr: { 
      manager: "Alice" 
    }, 
    it: { 
      manager: "Bob" 
    } 
  } 
};
console.log(company.departments.it.manager);
// Logs: "Bob"

// Example 3: Accessing a nested array inside an object
let user = { 
  name: "Sarah", 
  hobbies: { 
    outdoor: ["Hiking", "Cycling"], 
    indoor: ["Reading", "Gaming"] 
  } 
};
console.log(user.hobbies.outdoor[0]);
// Logs: "Hiking"

// Example 4: Nested object with methods
let car = { 
  brand: "Toyota", 
  model: "Camry", 
  features: { 
    sunroof: true, 
    startEngine: function() { 
      return "Engine started"; 
    } 
  } 
};
console.log(car.features.startEngine());
// Logs: "Engine started"

// Example 5: Nested object with dynamic property access
let laptop = { 
  brand: "Dell", 
  specs: { 
    cpu: "i7", 
    ram: "16GB" 
  } 
};
let spec = "cpu";
console.log(laptop.specs[spec]);
// Logs: "i7"

// Example 6: Nested object with an array of objects
let library = { 
  name: "City Library", 
  books: [ 
    { 
      title: "1984", 
      author: "George Orwell" 
    }, 
    { 
      title: "To Kill a Mockingbird", 
      author: "Harper Lee" 
    } 
  ] 
};
console.log(library.books[1].author);
// Logs: "Harper Lee"

// Example 7: Accessing a deeply nested property
let organization = { 
  name: "Global Corp", 
  locations: { 
    usa: { 
      ny: { 
        address: "123 Broadway", 
        employees: 200 
      } 
    }, 
    uk: { 
      london: { 
        address: "456 King's Rd", 
        employees: 150 
      } 
    } 
  } 
};
console.log(organization.locations.uk.london.address);
// Logs: "456 King's Rd"

// Example 8: Updating a nested object property
let student = { 
  name: "Jane", 
  courses: { 
    math: { 
      grade: "A" 
    }, 
    science: { 
      grade: "B" 
    } 
  } 
};
student.courses.science.grade = "A+";
console.log(student.courses.science.grade);
// Logs: "A+"

// Example 9: Checking if a nested property exists
let movie = { 
  title: "Inception", 
  details: { 
    director: "Christopher Nolan", 
    ratings: { 
      imdb: 8.8 
    } 
  } 
};
console.log("imdb" in movie.details.ratings);
// Logs: true

// Example 10: Adding a new property to a nested object
let house = { 
  rooms: 4, 
  amenities: { 
    garage: true 
  } 
};
house.amenities.pool = false;
console.log(house.amenities.pool);
// Logs: false
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-passby', event)">pass by reference</td>
          </tr>
          <tr id="detail-tag-passby" class="expandable-row-content">
            <td>
              <h3>pass by reference</h3>
              <p>In JavaScript, when objects are passed as arguments to functions or assigned to other variables, they are passed by reference. This means that the reference or memory address of the object is passed, not the actual object itself. As a result, if you modify the object within the function or through the new variable, those changes will affect the original object as well. This is because both the original object and the new reference point to the same location in memory. For example, if you have an object `person` and pass it to a function that alters one of its properties, the change will be reflected in the `person` object outside of the function as well. This behavior is essential to understand when working with objects in JavaScript, as it can lead to unintended side effects if the object is modified in different parts of the code. Understanding pass by reference helps in managing and controlling how objects are shared and modified throughout a program.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Passing an object to a function and modifying it
let person = { 
  name: "John", 
  age: 30 
};

function updateAge(obj) { 
  obj.age = 31; 
}

updateAge(person);
console.log(person);
// Logs: { name: "John", age: 31 }

// Example 2: Assigning an object to a new variable and modifying it
let car = { 
  brand: "Toyota", 
  model: "Camry" 
};

let newCar = car;
newCar.model = "Corolla";
console.log(car);
console.log(newCar);
// Logs: { brand: "Toyota", model: "Corolla" }
// Logs: { brand: "Toyota", model: "Corolla" }

// Example 3: Adding a property through a reference variable
let user = { 
  name: "Alice", 
  loggedIn: true 
};

let anotherUser = user;
anotherUser.role = "admin";
console.log(user);
console.log(anotherUser);
// Logs: { name: "Alice", loggedIn: true, role: "admin" }
// Logs: { name: "Alice", loggedIn: true, role: "admin" }

// Example 4: Deleting a property through a reference variable
let book = { 
  title: "1984", 
  author: "George Orwell" 
};

let refBook = book;
delete refBook.author;
console.log(book);
console.log(refBook);
// Logs: { title: "1984" }
// Logs: { title: "1984" }

// Example 5: Modifying a nested object property via reference
let employee = { 
  name: "Bob", 
  details: { 
    position: "Manager", 
    department: "Sales" 
  } 
};

let employeeRef = employee;
employeeRef.details.position = "Director";
console.log(employee.details.position);
console.log(employeeRef.details.position);
// Logs: "Director"
// Logs: "Director"

// Example 6: Assigning a method to a reference variable and modifying the object
let laptop = { 
  brand: "Dell", 
  specs: { 
    ram: "8GB", 
    storage: "256GB" 
  } 
};

let refLaptop = laptop;
refLaptop.specs.storage = "512GB";
console.log(laptop.specs.storage);
console.log(refLaptop.specs.storage);
// Logs: "512GB"
// Logs: "512GB"

// Example 7: Adding a nested object property through a reference
let movie = { 
  title: "Inception", 
  director: "Christopher Nolan" 
};

let refMovie = movie;
refMovie.details = { releaseYear: 2010 };
console.log(movie.details.releaseYear);
console.log(refMovie.details.releaseYear);
// Logs: 2010
// Logs: 2010

// Example 8: Passing an object with a method to a function and modifying it
let calculator = { 
  value: 10, 
  add: function(num) { 
    this.value += num; 
  } 
};

function modifyCalculator(calc) { 
  calc.add(5); 
}

modifyCalculator(calculator);
console.log(calculator.value);
// Logs: 15

// Example 9: Changing the object through a function that modifies nested properties
let student = { 
  name: "Jane", 
  grades: { 
    math: "B", 
    science: "A" 
  } 
};

function updateGrades(stud) { 
  stud.grades.math = "A+"; 
}

updateGrades(student);
console.log(student.grades.math);
// Logs: "A+"

// Example 10: Copying a reference and modifying both references
let house = { 
  rooms: 3, 
  hasGarage: true 
};

let houseRef = house;
houseRef.rooms = 4;
house.hasGarage = false;
console.log(house);
console.log(houseRef);
// Logs: { rooms: 4, hasGarage: false }
// Logs: { rooms: 4, hasGarage: false }
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-loopobj', event)">looping through objects</td>
          </tr>
          <tr id="detail-tag-loopobj" class="expandable-row-content">
            <td>
              <h3>looping through objects</h3>
              <p>Looping through objects in JavaScript is commonly done using the `for...in` loop, which allows you to iterate over the enumerable properties of an object. The `for...in` loop goes through each key in the object, enabling you to access both the key and its corresponding value within the loop. This approach is useful when you need to perform operations on each property of an object, such as logging values or applying changes to them. However, `for...in` does not guarantee the order of iteration, as the properties are iterated in the order they were added, which may not always be sequential. In addition to `for...in`, methods like `Object.keys()`, `Object.values()`, and `Object.entries()` can be used in combination with looping constructs like `for` or `forEach` to iterate through the keys, values, or key-value pairs of an object, respectively. These methods are often preferred for better control and compatibility with modern JavaScript features, allowing for more flexible and readable code when working with objects.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Looping through an object with for...in
let person = { 
  name: "John", 
  age: 30, 
  city: "New York" 
};

for (let key in person) { 
  console.log(key + ": " + person[key]); 
}
// Logs: 
// name: John
// age: 30
// city: New York

// Example 2: Looping through an object and accessing keys
let car = { 
  brand: "Toyota", 
  model: "Camry", 
  year: 2020 
};

for (let key in car) { 
  console.log("Key: " + key); 
}
// Logs:
// Key: brand
// Key: model
// Key: year

// Example 3: Looping through an object and accessing values
let laptop = { 
  brand: "Dell", 
  ram: "16GB", 
  storage: "512GB" 
};

for (let key in laptop) { 
  console.log("Value: " + laptop[key]); 
}
// Logs:
// Value: Dell
// Value: 16GB
// Value: 512GB

// Example 4: Using Object.keys() to loop through an object's keys
let book = { 
  title: "1984", 
  author: "George Orwell", 
  year: 1949 
};

Object.keys(book).forEach(function(key) { 
  console.log(key + ": " + book[key]); 
});
// Logs:
// title: 1984
// author: George Orwell
// year: 1949

// Example 5: Using Object.values() to loop through an object's values
let user = { 
  name: "Alice", 
  age: 25, 
  country: "USA" 
};

Object.values(user).forEach(function(value) { 
  console.log("Value: " + value); 
});
// Logs:
// Value: Alice
// Value: 25
// Value: USA

// Example 6: Using Object.entries() to loop through an object's key-value pairs
let smartphone = { 
  brand: "Apple", 
  model: "iPhone 12", 
  price: 999 
};

Object.entries(smartphone).forEach(function([key, value]) { 
  console.log(key + ": " + value); 
});
// Logs:
// brand: Apple
// model: iPhone 12
// price: 999

// Example 7: Looping through a nested object with for...in
let student = { 
  name: "Jane", 
  grades: { 
    math: "A", 
    science: "B" 
  } 
};

for (let key in student.grades) { 
  console.log(key + ": " + student.grades[key]); 
}
// Logs:
// math: A
// science: B

// Example 8: Using for...of with Object.keys() to loop through keys
let house = { 
  rooms: 3, 
  bathrooms: 2, 
  hasGarage: true 
};

for (let key of Object.keys(house)) { 
  console.log(key + ": " + house[key]); 
}
// Logs:
// rooms: 3
// bathrooms: 2
// hasGarage: true

// Example 9: Using for...of with Object.values() to loop through values
let movie = { 
  title: "Inception", 
  director: "Christopher Nolan", 
  releaseYear: 2010 
};

for (let value of Object.values(movie)) { 
  console.log("Value: " + value); 
}
// Logs:
// Value: Inception
// Value: Christopher Nolan
// Value: 2010

// Example 10: Looping through an object and modifying properties
let employee = { 
  name: "Bob", 
  position: "Manager", 
  salary: 50000 
};

for (let key in employee) { 
  if (key === "salary") { 
    employee[key] += 5000; 
  }
}

console.log(employee);
// Logs:
// { name: "Bob", position: "Manager", salary: 55000 }
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-objectsoverview', event)">overview</td>
          </tr>
          <tr id="detail-tag-objectsoverview" class="expandable-row-content">
            <td>
              <h3>overview</h3>
              <p>In JavaScr</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Declare and initialize a variable to store age
let age = 25;
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-objectsoverview', event)">overview</td>
          </tr>
          <tr id="detail-tag-objectsoverview" class="expandable-row-content">
            <td>
              <h3>overview</h3>
              <p>In JavaScr</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Declare and initialize a variable to store age
let age = 25;
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-objectsoverview', event)">overview</td>
          </tr>
          <tr id="detail-tag-objectsoverview" class="expandable-row-content">
            <td>
              <h3>overview</h3>
              <p>In JavaScr</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Declare and initialize a variable to store age
let age = 25;
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-objectsoverview', event)">overview</td>
          </tr>
          <tr id="detail-tag-objectsoverview" class="expandable-row-content">
            <td>
              <h3>overview</h3>
              <p>In JavaScr</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Declare and initialize a variable to store age
let age = 25;
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-objectsoverview', event)">overview</td>
          </tr>
          <tr id="detail-tag-objectsoverview" class="expandable-row-content">
            <td>
              <h3>overview</h3>
              <p>In JavaScr</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Declare and initialize a variable to store age
let age = 25;
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-objectsoverview', event)">overview</td>
          </tr>
          <tr id="detail-tag-objectsoverview" class="expandable-row-content">
            <td>
              <h3>overview</h3>
              <p>In JavaScr</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Declare and initialize a variable to store age
let age = 25;
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td id="comments" class="tableletters">Comments</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-slc', event)">
              single line comments
            </td>
          </tr>
          <tr id="detail-tag-slc" class="expandable-row-content">
            <td>
              <h3>single line comments</h3>
              <p>In JavaScript, single-line comments are used to add brief explanations or notes within the code. They are created using two forward slashes //. Everything following the // on that line will be considered a comment and ignored by the JavaScript engine during execution.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// This is a single-line comment

// Declare and initialize a variable to store age
let age = 25;
           
// Check if the score is greater than or equal to 80
let score = 85;
if (score >= 80) {
  console.log('Great job!');
} else {
  console.log('Keep trying!');
}    

// Loop through numbers from 1 to 5
for (let i = 1; i <= 5; i++) {
  console.log(i); // Output the current number
}
 
// Function to add two numbers
function add(a, b) {
  return a + b; // Return the sum
}
console.log(add(2, 3)); // Output: 5
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-mlc', event)">
              multi line comments
            </td>
          </tr>
          <tr id="detail-tag-mlc" class="expandable-row-content">
            <td>
              <h3>multi line comments</h3>
              <p>Multi-line comments in JavaScript are used to comment out blocks of code or add longer explanations within the code. They start with /* and end with */. Everything between these delimiters is considered a comment and ignored by the JavaScript engine during execution.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
/*
  This is a multi-line comment.
  It can span multiple lines.
*/

/*
  Declare and initialize a variable to store the user's age.
  This value will be used to determine access permissions.
*/
let age = 30;

/*
  Function to greet the user.
  It prints a welcome message to the console.
*/
function greetUser(name) {
  console.log('Hello, ' + name + '!');
}

/*
  Loop through an array of numbers.
  Print each number to the console.
*/
let numbers = [1, 2, 3, 4, 5];
for (let i = 0; i < numbers.length; i++) {
  console.log(numbers[i]); // Print the current number
}
           </code></pre>
              <br />
            </td>
          </tr>


            <td id="data-types" class="tableletters">Data Types</td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-data-types', event)"
            >7 primitive data types & objects
            </td>
          </tr>
          <tr id="detail-tag-data-types" class="expandable-row-content">
            <td>
              <h3>7 primitive data types & objects</h3>
              <p>JavaScript has a variety of data types that can be categorized into primitive types and objects. Primitive types are immutable and compared by value, while objects are mutable and compared by reference.</p>
              <ol>
                <li>String: Represents text and is enclosed in quotes.</li>
                <li>Number: Represents both integers and floating-point numbers.</li>
                <li>Boolean: Represents true or false values.</li>
                <li>Boolean: Represents true or false values.</li>
                <li>Null: Represents the intentional absence of any object value.</li>
                <li>Symbol: Represents a unique identifier created using the Symbol function.</li>
                <li>BigInt: Represents integers larger than the maximum safe integer limit for Number.</li>
                <li>Object: A complex data type that allows you to store collections of data in key-value pairs.</li>
              </ol>

              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// String
let greeting = "Hello, world!";
let name = 'Alice';
let phrase = `JavaScript is fun!`; // Template literals allow for embedded expressions

// Number
let age = 25;
let pi = 3.14159;
let negativeNumber = -42; // Negative number example

// Boolean
let isStudent = true;
let hasGraduated = false;
let isLoggedIn = true;

// Undefined
let x;
let y = undefined;
let z; // Undefined by default when not assigned

// Null
let emptyValue = null;
let noValue = null;
let response = null; // Commonly used to indicate no response or empty result

// Symbol
let sym1 = Symbol('unique');
let sym2 = Symbol('unique');
let sym3 = Symbol(); // Symbol without a description

// BigInt
let bigInt1 = 1234567890123456789012345678901234567890n;
let bigInt2 = BigInt(1234567890123456789012345678901234567890);
let bigInt3 = 9007199254740991n; // Maximum safe integer + 1

// Object
let person = {
  name: "Alice",
  age: 25
};
let car = {
  brand: "Toyota",
  model: "Corolla"
};
let book = {
  title: "JavaScript: The Good Parts",
  author: "Douglas Crockford"
};
          

</code></pre>
              <br />
            </td>
          </tr>
          
        </tbody>

        <tfoot></tfoot>
      </table>
      <br /> 
    </main>  
    <footer>
      <small> No Rights Reserved. </small>
    </footer>
    <script src="script.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
    <script>
      function toggleDetail(detailId, event) {
    var detailRow = document.getElementById(detailId);
    var isExpanded = detailRow.style.display === "table-row";
    detailRow.style.display = isExpanded ? "none" : "table-row";

    if (isExpanded) {
      event.target.classList.remove("expanded");
    } else {
      event.target.classList.add("expanded");
    }
  }
    </script> 
    <script src="https://unpkg.com/smoothscroll-polyfill/dist/smoothscroll.min.js"></script>
    <script src="https://unpkg.com/smoothscroll-anchor-polyfill"></script>
  </body>
</html>



