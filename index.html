<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Programming Syntax Notes"
    />
    <meta
      property="og:title"
      content="Programming Syntax Notes"
    />
    <meta
      name="twitter:title"
      content="Programming Syntax Notes"
    />
    <title>Syntax Notes</title>
    <link href="main.css" rel="stylesheet" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.css"
    />
    <link rel="icon" href="favicon.ico" />
    <base href="https://mathieu.so/" />
    <style>
      p {
        text-align: justify;
      }
    </style>
  </head>

  <body>
    <header>
      <h1>JAVASCRIPT SYNTAX NOTES</h1>
      <p>Content last updated on 03/08/2024 by <em>Mathieu</em></p>
    </header>
    <main>
      <section id="elements">
        <h2>Index</h2>
      </section>
      <hr />
      <div class="alphsort">
        <a href="#variables">Variables</a>
        <a href="#conditionals">Conditionals</a>
        <a href="#comments">Comments</a>
        <a href="#data-types">Data Types</a>
        <a href="#ao">Arithmetic Operators</a>
        <a href="#functions">Functions</a>
        <a href="#scope">Scope</a>
        <a href="#arrays">Arrays</a>
      </div>
      <hr />
      <br />
      <table>
        <tbody>
          <tr>
            <td id="variables" class="tableletters">Variables</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-let', event)">
              let
            </td>
          </tr>
          <tr id="detail-tag-let" class="expandable-row-content">
            <td>
              <h3>let</h3>
              <p>A variable in programming is a storage location identified by a name, which can hold data that may be modified during the execution of a program. Variables are used to store values so that these values can be used and manipulated throughout the program. They can hold different types of data, such as numbers, strings, objects, and more. Variables enable developers to write flexible and dynamic code by providing a way to reference and operate on data without hard-coding values directly into the program.

                <br><br>In JavaScript, the let keyword is used to declare a variable that is block-scoped, which means it is limited to the block, statement, or expression where it is declared. This contrasts with the older var keyword, which declares a variable globally or locally to an entire function regardless of block scope. The let keyword was introduced in ECMAScript 6 (ES6) to provide better control over variable scope and to avoid issues related to variable hoisting that are associated with var.
                
                <br><br>When you declare a variable using let, it is not hoisted to the top of its enclosing block. Instead, it is hoisted to the top of the block but not initialized, which means it cannot be accessed until the execution reaches the line of code where it is declared. This behavior is known as the "temporal dead zone" and helps prevent errors that can occur when variables are used before they are defined.
                
                <br><br>For example, in a block, trying to access a variable declared with let before its declaration line results in a ReferenceError. Once the declaration line is reached, the variable can be accessed and used. The let keyword also prevents the redeclaration of the same variable within the same scope, providing an additional layer of error checking. Attempting to redeclare a variable with let in the same scope results in a SyntaxError, which helps to catch mistakes and enforce cleaner code practices.
                
                <br><br>Overall, the let keyword in JavaScript provides a way to declare variables that are confined to their block scope, reducing the likelihood of errors related to variable hoisting and redeclaration, and promoting better coding practices by encouraging the use of variables only within their intended context.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Redeclaration in the same block
let x = 10;
// let x = 20; // SyntaxError: Identifier 'x' has already been declared
x = 20; // Allowed: updating the value
console.log(x); // 20

// Example 2: Redeclaration in nested blocks
let y = 30;
{
  // let y = 40; // SyntaxError: Identifier 'y' has already been declared
  let z = 50;
  console.log(z); // 50
}
{
  let y = 40; // Allowed: different block scope
  console.log(y); // 40
}
console.log(y); // 30 (original y)

// Example 3: Redeclaration in a function
function redeclareLet() {
  let a = 60;
  // let a = 70; // SyntaxError: Identifier 'a' has already been declared
  a = 70; // Allowed: updating the value
  console.log(a); // 70
}
redeclareLet();

// Example 4: Redeclaration in an if block
let condition = true;
if (condition) {
  let status = 'active';
  // let status = 'inactive'; // SyntaxError: Identifier 'status' has already been declared
  status = 'inactive'; // Allowed: updating the value
  console.log(status); // 'inactive'
}

// Example 5: Block scope
{
  let x = 10;
  console.log(x); // 10
}
console.log(typeof x); // undefined (x is not accessible here)

// Example 6: Temporal Dead Zone
{
  // console.log(y); // ReferenceError: Cannot access 'y' before initialization
  let y = 20;
  console.log(y); // 20
}

// Example 7: let in a loop block
for (let i = 0; i < 3; i++) {
  console.log(i); // 0, 1, 2
}
// console.log(i); // ReferenceError: i is not defined (i is not accessible here)

// Example 8: Nested blocks
{
  let outer = 'outer';
  {
    let inner = 'inner';
    console.log(outer); // outer
    console.log(inner); // inner
  }
  // console.log(inner); // ReferenceError: inner is not defined
}

// Example 9: let in functions
function testLet() {
  let z = 50;
  console.log(z); // 50
}
// console.log(z); // ReferenceError: z is not defined
testLet();

// Example 10: Updating let variables
let score = 10;
score += 5;
console.log(score); // 15
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-const', event)">
              const
            </td>
          </tr>
          <tr id="detail-tag-const" class="expandable-row-content">
            <td>
              <h3>const</h3>
              <p>The `const` keyword in JavaScript is used to declare variables that are intended to be constant, meaning their values are not supposed to change after they are initialized. Similar to the `let` keyword, `const` creates block-scoped variables. This means that the variable declared with `const` is limited to the block, statement, or expression where it is defined, and cannot be accessed outside of that scope. 

                <br><br>When you declare a variable with `const`, it must be initialized with a value at the time of declaration. This is because `const` variables are read-only after they are assigned a value. Trying to declare a `const` variable without initializing it will result in a syntax error. Once assigned, the variable cannot be reassigned a new value, which helps enforce immutability at the variable level.
                
                <br><br>It's important to note that while the `const` keyword prevents reassignment of the variable itself, it does not make the value immutable. For example, if the value assigned to a `const` variable is an object or an array, the contents of that object or array can still be modified. This means you can change the properties of an object or elements of an array, but you cannot reassign the variable to a different object or array. 
                
                <br><br>Using `const` for variables that should remain unchanged helps improve code reliability and readability by signaling the intent that the variable's value should not be altered. It also reduces the risk of unintended side effects caused by variable reassignment. However, because `const` is block-scoped like `let`, it can only be accessed within the block it is declared in, and it cannot be redeclared within that same block. 
                
                <br><br>In summary, the `const` keyword in JavaScript is used to declare variables with a constant value that should not be reassigned. It provides block scope similar to `let` and enforces immutability for the variable binding itself, though not necessarily for the value it holds if that value is an object or array.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Redeclaration in the same block
const a = 10;
// const a = 20; // SyntaxError: Identifier 'a' has already been declared
// a = 20; // TypeError: Assignment to constant variable
console.log(a); // 10

// Example 2: Redeclaration in nested blocks
const b = 30;
{
  // const b = 40; // SyntaxError: Identifier 'b' has already been declared
  const c = 50;
  console.log(c); // 50
}
{
  const b = 40; // Allowed: different block scope
  console.log(b); // 40
}
console.log(b); // 30 (original b)

// Example 3: Redeclaration in functions
function exampleFunction() {
  const d = 60;
  // const d = 70; // SyntaxError: Identifier 'd' has already been declared
  console.log(d); // 60
}
exampleFunction();

// Example 4: Redeclaration in if block
const condition = true;
if (condition) {
  const status = 'active';
  // const status = 'inactive'; // SyntaxError: Identifier 'status' has already been declared
  console.log(status); // 'active'
}

// Example 5: Initializing const without assignment
// const e; // SyntaxError: Missing initializer in const declaration

// Example 6: Modifying properties of a const object
const obj = { key: 'value' };
obj.key = 'newValue'; // Allowed: modifying object properties
console.log(obj.key); // 'newValue'

// Example 7: Modifying array elements of a const array
const arr = [1, 2, 3];
arr[0] = 10; // Allowed: modifying array elements
console.log(arr[0]); // 10

// Example 8: Block scope with const
{
  const f = 70;
  console.log(f); // 70
}
// console.log(f); // ReferenceError: f is not defined

// Example 9: const in loops
for (const g of [1, 2, 3]) {
  console.log(g); // 1, 2, 3
}
// console.log(g); // ReferenceError: g is not defined

// Example 10: const in a switch case
const h = 'A';
switch (h) {
  case 'A':
    const grade = 'Excellent';
    console.log(grade); // 'Excellent'
    break;
  case 'B':
    // const grade = 'Good'; // SyntaxError: Identifier 'grade' has already been declared
    break;
  default:
    const grade = 'Unknown'; // Allowed: different block scope
    console.log(grade); // 'Unknown'
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td id="conditionals" class="tableletters">Conditionals</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-if', event)">
              if statement
            </td>
          </tr>
          <tr id="detail-tag-if" class="expandable-row-content">
            <td>
              <h3>if statement</h3>
              <p>In JavaScript, an if statement is a fundamental control structure used to execute a block of code only if a specified condition is true. The syntax starts with the keyword if, followed by a condition enclosed in parentheses. This condition is an expression that the JavaScript engine evaluates to either true or false. If the condition evaluates to true, the code block enclosed in curly braces {} immediately following the if statement is executed. For instance, consider the example if (temperature > 30) { console.log("It's hot outside!"); }. In this case, if the value of the variable temperature is greater than 30, the message "It's hot outside!" will be logged to the console. However, if the condition evaluates to false, the code block within the curly braces is skipped and not executed. This allows developers to control the flow of their programs by specifying actions that should only occur when certain conditions are met, making the code more dynamic and responsive to different scenarios.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
let age = 18;
if (age >= 18) {
  console.log("You are an adult.");
}

let temperature = 25;
if (temperature < 0) {
  console.log("It is freezing outside.");
}

let score = 85;
if (score >= 80) {
  console.log("You passed the exam.");
}

let isMember = true;
if (isMember) {
  console.log("Welcome, member!");
}

let name = "Alice";
if (name === "Alice") {
  console.log("Hello, Alice!");
}

let balance = 1000;
if (balance >= 500) {
  console.log("You have sufficient funds.");
}

let light = "green";
if (light === "green") {
  console.log("You can go.");
}

let password = "securePassword123";
if (password.length >= 8) {
  console.log("Password is long enough.");
}

let itemsInCart = 3;
if (itemsInCart > 0) {
  console.log("Your cart is not empty.");
}

let hasAccess = false;
if (!hasAccess) {
  console.log("Access denied.");
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-else', event)">
              else statement
            </td>
          </tr>
          <tr id="detail-tag-else" class="expandable-row-content">
            <td>
              <h3>else statement</h3>
              <p>In JavaScript, the `else` statement is used to define a block of code that will be executed if the condition in the preceding `if` statement evaluates to false. It acts as a fallback or default action when the specified condition is not met. When an `if` statement evaluates its condition and finds it to be false, the code inside the `else` block runs instead. This ensures that one of the two blocks of code (either the `if` block or the `else` block) will always execute, making it useful for handling alternative outcomes. For instance, in the code snippet `if (condition) { /* code if condition is true */ } else { /* code if condition is false */ }`, if `condition` evaluates to false, the program will skip the first block and execute the code within the `else` block.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Checking if a number is positive
let number = 5;
if (number > 0) {
    console.log("The number is positive");
} else {
    console.log("The number is not positive");
}

// Example 2: Checking if a user is logged in
let isLoggedIn = false;
if (isLoggedIn) {
    console.log("Welcome, user!");
} else {
    console.log("Please log in");
}

// Example 3: Checking if an array is empty
let array = [];
if (array.length > 0) {
    console.log("The array is not empty");
} else {
    console.log("The array is empty");
}

// Example 4: Checking if a string is not empty
let str = "";
if (str !== "") {
    console.log("The string is not empty");
} else {
    console.log("The string is empty");
}

// Example 5: Checking if a number is even
let num = 7;
if (num % 2 === 0) {
    console.log("The number is even");
} else {
    console.log("The number is odd");
}

// Example 6: Checking if a temperature is above freezing
let temperature = -5;
if (temperature > 0) {
    console.log("The temperature is above freezing");
} else {
    console.log("The temperature is below freezing");
}

// Example 7: Checking if a year is a leap year
let year = 2023;
if ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0) {
    console.log("The year is a leap year");
} else {
    console.log("The year is not a leap year");
}

// Example 8: Checking if a password is valid (simplified)
let password = "pass123";
if (password.length >= 8) {
    console.log("The password is valid");
} else {
    console.log("The password is invalid");
}

// Example 9: Checking if a light is on
let lightOn = true;
if (lightOn) {
    console.log("The light is on");
} else {
    console.log("The light is off");
}

// Example 10: Checking if a value is greater than a threshold
let value = 15;
let threshold = 10;
if (value > threshold) {
    console.log("The value is above the threshold");
} else {
    console.log("The value is below the threshold");
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-elseif', event)">
              else if statement
            </td>
          </tr>
          <tr id="detail-tag-elseif" class="expandable-row-content">
            <td>
              <h3>else if statement</h3>
              <p>In JavaScript, the `else if` statement is used to specify a new condition to test if the previous `if` condition evaluates to false. This allows for multiple conditions to be checked sequentially, enabling more complex decision-making within the code. When an `if` statement's condition is false, the program moves to the `else if` statement to check its condition. If this condition is true, the corresponding block of code executes. If it is also false, the program can continue to additional `else if` statements, if any are present. This chaining of conditions with `else if` statements enables the program to handle various scenarios in a structured manner. If all `if` and `else if` conditions are false, an optional `else` statement can be used as a final fallback. For instance, in the code snippet `if (condition1) { /* code if condition1 is true */ } else if (condition2) { /* code if condition2 is true */ } else { /* code if none of the conditions are true */ }`, the program evaluates each condition in sequence until one is true, executing the corresponding block of code and skipping the rest.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Checking user role
let userRole = "editor";
if (userRole === "admin") {
    console.log("Access level: Full");
} else if (userRole === "editor") {
    console.log("Access level: Edit");
} else if (userRole === "viewer") {
    console.log("Access level: View");
} else {
    console.log("Access level: None");
}

// Example 2: Determining shipping cost
let orderValue = 75;
if (orderValue >= 100) {
    console.log("Shipping cost: Free");
} else if (orderValue >= 50) {
    console.log("Shipping cost: $5");
} else if (orderValue >= 20) {
    console.log("Shipping cost: $10");
} else {
    console.log("Shipping cost: $15");
}

// Example 3: Movie rating classification
let movieRating = "R";
if (movieRating === "G") {
    console.log("Suitable for all ages");
} else if (movieRating === "PG") {
    console.log("Parental guidance suggested");
} else if (movieRating === "PG-13") {
    console.log("Parents strongly cautioned");
} else if (movieRating === "R") {
    console.log("Restricted to 17 and older");
} else {
    console.log("Rating not recognized");
}

// Example 4: Network connection status
let connectionStatus = "connected";
if (connectionStatus === "connected") {
    console.log("Network status: Connected");
} else if (connectionStatus === "connecting") {
    console.log("Network status: Connecting");
} else if (connectionStatus === "disconnected") {
    console.log("Network status: Disconnected");
} else {
    console.log("Network status: Unknown");
}

// Example 5: Battery level indicator
let batteryLevel = 45;
if (batteryLevel > 80) {
    console.log("Battery status: High");
} else if (batteryLevel > 40) {
    console.log("Battery status: Medium");
} else if (batteryLevel > 20) {
    console.log("Battery status: Low");
} else {
    console.log("Battery status: Critical");
}

// Example 6: Air quality index (AQI) categorization
let aqi = 120;
if (aqi <= 50) {
    console.log("Air quality: Good");
} else if (aqi <= 100) {
    console.log("Air quality: Moderate");
} else if (aqi <= 150) {
    console.log("Air quality: Unhealthy for sensitive groups");
} else if (aqi <= 200) {
    console.log("Air quality: Unhealthy");
} else if (aqi <= 300) {
    console.log("Air quality: Very Unhealthy");
} else {
    console.log("Air quality: Hazardous");
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-comparison', event)">
              comparison operators
            </td>
          </tr>
          <tr id="detail-tag-comparison" class="expandable-row-content">
            <td>
              <h3>comparison operators</h3>
              <p>In JavaScript, comparison operators are used in conditionals to compare two values and determine the relationship between them, returning a boolean value (true or false) as the result. The equality operator (`==`) checks if two values are equal, while the strict equality operator (`===`) checks for both value and type equality. The inequality operator (`!=`) checks if two values are not equal, and the strict inequality operator (`!==`) checks for both value and type inequality. The greater than (`>`), greater than or equal to (`>=`), less than (`<`), and less than or equal to (`<=`) operators are used to compare the relative magnitude of two values. These operators are essential in conditional statements like `if`, `else if`, and `while`, allowing the code to execute different blocks based on whether specific conditions are met. For example, `if (a > b) { /* code */ }` will execute the contained code if `a` is greater than `b`. Comparison operators provide the fundamental logic needed for decision-making processes in programming.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Equality and Inequality Operators

// Example 1: Check if two strings are equal
let string1 = "hello";
let string2 = "hello";
if (string1 == string2) {
    console.log("The strings are equal"); // Logs: "The strings are equal"
} else {
    console.log("The strings are not equal");
}

// Example 2: Check if two numbers are not equal
let a = 10;
let b = 20;
if (a != b) {
    console.log("a is not equal to b"); // Logs: "a is not equal to b"
} else {
    console.log("a is equal to b");
}

// Example 3: Check if a value is strictly equal to another
let value1 = 100;
let value2 = "100";
if (value1 === value2) {
    console.log("value1 is strictly equal to value2");
} else {
    console.log("value1 is not strictly equal to value2"); // Logs: "value1 is not strictly equal to value2"
}

// Example 4: Check if a value is not strictly equal to another
let x = 15;
let y = "15";
if (x !== y) {
    console.log("x is not strictly equal to y"); // Logs: "x is not strictly equal to y"
} else {
    console.log("x is strictly equal to y");
}

// Example 5: Check if a string is not equal to another
let str1 = "apple";
let str2 = "orange";
if (str1 != str2) {
    console.log("The strings are not equal"); // Logs: "The strings are not equal"
} else {
    console.log("The strings are equal");
}

// Example 6: Check if a boolean value is true
let isTrue = true;
if (isTrue === true) {
    console.log("The value is true"); // Logs: "The value is true"
} else {
    console.log("The value is false");
}

// Example 7: Check if a boolean value is false
let isFalse = false;
if (isFalse === false) {
    console.log("The value is false"); // Logs: "The value is false"
} else {
    console.log("The value is true");
}

// Example 8: Check if a number is equal to a specific value
let num = 42;
if (num === 42) {
    console.log("The number is 42"); // Logs: "The number is 42"
} else {
    console.log("The number is not 42");
}

// Greater Than and Less Than Operators

// Example 9: Check if a number is greater than another number
let num1 = 5;
let num2 = 3;
if (num1 > num2) {
    console.log("num1 is greater than num2"); // Logs: "num1 is greater than num2"
} else {
    console.log("num1 is not greater than num2");
}

// Example 10: Check if a number is less than another number
let num3 = 5;
let num4 = 10;
if (num3 < num4) {
    console.log("num3 is less than num4"); // Logs: "num3 is less than num4"
} else {
    console.log("num3 is not less than num4");
}

// Example 11: Check if a number is greater than or equal to another number
let num5 = 10;
let num6 = 10;
if (num5 >= num6) {
    console.log("num5 is greater than or equal to num6"); // Logs: "num5 is greater than or equal to num6"
} else {
    console.log("num5 is less than num6");
}

// Example 12: Check if a number is less than or equal to another number
let num7 = 5;
let num8 = 8;
if (num7 <= num8) {
    console.log("num7 is less than or equal to num8"); // Logs: "num7 is less than or equal to num8"
} else {
    console.log("num7 is greater than num8");
}

// Example 13: Check if a value is greater than zero
let value = -1;
if (value > 0) {
    console.log("The value is greater than zero");
} else {
    console.log("The value is not greater than zero"); // Logs: "The value is not greater than zero"
}

// Example 14: Check if a value is less than zero
let value3 = -5;
if (value3 < 0) {
    console.log("The value is less than zero"); // Logs: "The value is less than zero"
} else {
    console.log("The value is not less than zero");
}

// Example 15: Check if a temperature is above freezing
let temperature = -5;
if (temperature > 0) {
    console.log("The temperature is above freezing");
} else {
    console.log("The temperature is below freezing"); // Logs: "The temperature is below freezing"
}

// Example 16: Check if a year is in the future
let currentYear = 2024;
let futureYear = 2030;
if (futureYear > currentYear) {
    console.log("The year is in the future"); // Logs: "The year is in the future"
} else {
    console.log("The year is not in the future");
}

// Example 17: Check if a person's age is over 18
let personAge = 20;
if (personAge > 18) {
    console.log("The person is over 18"); // Logs: "The person is over 18"
} else {
    console.log("The person is not over 18");
}

// Example 18: Check if a price is within a budget
let price = 50;
let budget = 100;
if (price <= budget) {
    console.log("The price is within the budget"); // Logs: "The price is within the budget"
} else {
    console.log("The price is not within the budget");
}

// Example 19: Check if a value is less than a threshold
let threshold = 10;
let testValue = 8;
if (testValue < threshold) {
    console.log("The value is less than the threshold"); // Logs: "The value is less than the threshold"
} else {
    console.log("The value is not less than the threshold");
}

// Example 20: Check if a password length is sufficient
let password = "12345";
if (password.length >= 8) {
    console.log("The password length is sufficient");
} else {
    console.log("The password length is insufficient"); // Logs: "The password length is insufficient"
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-logical', event)">
              logical operators
            </td>
          </tr>
          <tr id="detail-tag-logical" class="expandable-row-content">
            <td>
              <h3>logical operators</h3>
              <p>In JavaScript, logical operators are used in conditionals to combine or invert Boolean values, allowing for more complex decision-making. The three main logical operators are `&&` (logical AND), `||` (logical OR), and `!` (logical NOT). The `&&` operator evaluates to true only if both operands are true, making it useful for checking multiple conditions that must all be satisfied. The `||` operator evaluates to true if at least one of the operands is true, allowing for flexibility when only one of several conditions needs to be met. The `!` operator inverts the truthiness of its operand, turning true to false and vice versa, which is helpful for checking the opposite condition. These operators enable more nuanced control flow in programs, such as executing a block of code only if multiple criteria are met, or if at least one of several conditions is true, or even when a specific condition is not true.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Logical AND Operator

// Example 1: Check if both conditions are true
let temperature = 25;
let humidity = 50;
if (temperature > 20 && humidity < 60) {
    console.log("The weather is pleasant"); // Logs: "The weather is pleasant"
} else {
    console.log("The weather is not pleasant");
}

// Example 2: Check if a person is eligible for a senior discount
let personAge = 65;
let isMember = true;
if (personAge >= 65 && isMember) {
    console.log("Eligible for senior discount"); // Logs: "Eligible for senior discount"
} else {
    console.log("Not eligible for senior discount");
}

// Example 3: Check if a number is within a range
let age = 25;
if (age >= 18 && age <= 30) {
    console.log("The age is within the range"); // Logs: "The age is within the range"
} else {
    console.log("The age is outside the range");
}

// Example 4: Check if a string has a specific length and starts with a specific letter
let name = "Alice";
if (name.length > 3 && name.charAt(0) === "A") {
    console.log("The name is valid"); // Logs: "The name is valid"
} else {
    console.log("The name is not valid");
}

// Logical OR Operator

// Example 5: Check if a number is outside a range
let score = 45;
if (score < 50 || score > 90) {
    console.log("The score is outside the range"); // Logs: "The score is outside the range"
} else {
    console.log("The score is within the range");
}

// Example 6: Check if a user is an admin or a moderator
let role = "admin";
if (role === "admin" || role === "moderator") {
    console.log("User has elevated privileges"); // Logs: "User has elevated privileges"
} else {
    console.log("User does not have elevated privileges");
}

// Example 7: Check if it's a weekend or a holiday
let day = "Saturday";
let isHoliday = false;
if (day === "Saturday" || day === "Sunday" || isHoliday) {
    console.log("It's a day off"); // Logs: "It's a day off"
} else {
    console.log("It's a working day");
}

// Example 8: Check if an item is available in stock or on backorder
let inStock = false;
let onBackorder = true;
if (inStock || onBackorder) {
    console.log("The item can be ordered"); // Logs: "The item can be ordered"
} else {
    console.log("The item is not available");
}

// Logical NOT Operator

// Example 9: Check if a user is not logged in
let isLoggedIn = false;
if (!isLoggedIn) {
    console.log("User is not logged in"); // Logs: "User is not logged in"
} else {
    console.log("User is logged in");
}

// Example 10: Check if a value is not null or undefined
let data = null;
if (data !== null && data !== undefined) {
    console.log("Data is available");
} else {
    console.log("Data is not available"); // Logs: "Data is not available"
}

// Example 11: Check if an array is not empty
let array = [1, 2, 3];
if (array.length !== 0) {
    console.log("The array is not empty"); // Logs: "The array is not empty"
} else {
    console.log("The array is empty");
}

// Example 12: Check if a form field is not blank
let formField = "username";
if (formField !== "") {
    console.log("The form field is filled out"); // Logs: "The form field is filled out"
} else {
    console.log("The form field is blank");
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-ternary', event)">
              ternary operator
            </td>
          </tr>
          <tr id="detail-tag-ternary" class="expandable-row-content">
            <td>
              <h3>ternary operator</h3>
              <p>In JavaScript, the ternary operator is a concise way to perform conditional evaluations. It is the only operator that takes three operands: a condition, an expression to execute if the condition is true, and an expression to execute if the condition is false. The syntax is `condition ? expressionIfTrue : expressionIfFalse`. This operator is particularly useful for assigning values based on a condition or for inline conditional expressions, making the code more succinct. For example, `let result = (age >= 18) ? "Adult" : "Minor";` assigns the string "Adult" to the variable `result` if the `age` is 18 or older, otherwise it assigns "Minor". The ternary operator improves readability for simple conditional assignments, but for more complex logic, traditional `if...else` statements are often more appropriate.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Check if a number is positive, negative, or zero
let number = 5;
let numberCheck = (number > 0) ? "Positive" : (number < 0) ? "Negative" : "Zero";
console.log(numberCheck); // Logs: "Positive"

// Example 2: Determine if a user is an adult or a minor based on age
let age = 17;
let ageGroup = (age >= 18) ? "Adult" : "Minor";
console.log(ageGroup); // Logs: "Minor"

// Example 3: Check if a string is empty or not
let str = "";
let stringCheck = (str !== "") ? "Not empty" : "Empty";
console.log(stringCheck); // Logs: "Empty"

// Example 4: Assign a discount based on membership status
let isMember = true;
let discount = (isMember) ? "10% discount" : "No discount";
console.log(discount); // Logs: "10% discount"

// Example 5: Determine the maximum of two numbers
let a = 10;
let b = 20;
let max = (a > b) ? a : b;
console.log(max); // Logs: 20
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-switch', event)">
              switch statement
            </td>
          </tr>
          <tr id="detail-tag-switch" class="expandable-row-content">
            <td>
              <h3>switch statement</h3>
              <p>In JavaScript, the switch statement is used to perform different actions based on different conditions, serving as an alternative to multiple `if...else if` statements. It evaluates an expression and matches its value against a series of case labels, executing the corresponding block of code when a match is found. The switch statement starts with the keyword `switch`, followed by the expression in parentheses and a block of cases enclosed in curly braces. Each case block starts with the keyword `case`, followed by a value and a colon, and contains the code to execute if the expression matches that value. The `break` statement is typically used at the end of each case to exit the switch block, preventing the execution from falling through to the subsequent cases. If none of the cases match, an optional `default` case can be defined to execute a block of code as a fallback. This structure allows for cleaner and more readable code when handling multiple possible values for a single variable, compared to using numerous `if...else if` statements.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Determine the day of the week
let day = 3;
let dayName;
switch (day) {
    case 0:
        dayName = "Sunday";
        break;
    case 1:
        dayName = "Monday";
        break;
    case 2:
        dayName = "Tuesday";
        break;
    case 3:
        dayName = "Wednesday";
        break;
    case 4:
        dayName = "Thursday";
        break;
    case 5:
        dayName = "Friday";
        break;
    case 6:
        dayName = "Saturday";
        break;
    default:
        dayName = "Invalid day";
}
console.log(dayName); // Logs: "Wednesday"

// Example 2: Evaluate a grade and provide feedback
let grade = 'B';
let feedback;
switch (grade) {
    case 'A':
        feedback = "Excellent";
        break;
    case 'B':
        feedback = "Good";
        break;
    case 'C':
        feedback = "Fair";
        break;
    case 'D':
        feedback = "Poor";
        break;
    case 'F':
        feedback = "Fail";
        break;
    default:
        feedback = "Invalid grade";
}
console.log(feedback); // Logs: "Good"

// Example 3: Determine the browser type based on user agent
let browser = 'Chrome';
let browserType;
switch (browser) {
    case 'Edge':
        browserType = "Microsoft Edge";
        break;
    case 'Chrome':
        browserType = "Google Chrome";
        break;
    case 'Firefox':
        browserType = "Mozilla Firefox";
        break;
    case 'Safari':
        browserType = "Apple Safari";
        break;
    default:
        browserType = "Unknown browser";
}
console.log(browserType); // Logs: "Google Chrome"

// Example 4: Identify the traffic light color action
let trafficLight = 'Yellow';
let action;
switch (trafficLight) {
    case 'Red':
        action = "Stop";
        break;
    case 'Yellow':
        action = "Caution";
        break;
    case 'Green':
        action = "Go";
        break;
    default:
        action = "Invalid color";
}
console.log(action); // Logs: "Caution"

// Example 5: Determine the season based on the month
let month = 8;
let season;
switch (month) {
    case 12:
    case 1:
    case 2:
        season = "Winter";
        break;
    case 3:
    case 4:
    case 5:
        season = "Spring";
        break;
    case 6:
    case 7:
    case 8:
        season = "Summer";
        break;
    case 9:
    case 10:
    case 11:
        season = "Fall";
        break;
    default:
        season = "Invalid month";
}
console.log(season); // Logs: "Summer"
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-truthy', event)">
              truthy and falsy values
            </td>
          </tr>
          <tr id="detail-tag-truthy" class="expandable-row-content">
            <td>
              <h3>truthy and falsy values</h3>
              <p>In JavaScript, truthy and falsy values determine how expressions are evaluated in conditional statements. A value is considered truthy if it evaluates to true in a boolean context, and falsy if it evaluates to false. JavaScript treats the following values as falsy: `false`, `0`, `-0`, `0n` (BigInt zero), `""` (empty string), `null`, `undefined`, and `NaN` (Not-a-Number). All other values, including non-empty strings, non-zero numbers, objects, arrays, and functions, are considered truthy. Understanding truthy and falsy values is essential for writing concise and effective conditionals, as it allows developers to leverage implicit type coercion. For example, the expression `if (value)` will execute the block of code if `value` is truthy, and skip it if `value` is falsy. This implicit evaluation can simplify checks for empty strings, null values, or zeroes, making the code more readable and succinct.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Check if a variable is truthy
let value1 = "hello";
if (value1) {
    console.log("The value is truthy"); // Logs: "The value is truthy"
} else {
    console.log("The value is falsy");
}

// Example 2: Check if a variable is falsy
let value2 = 0;
if (value2) {
    console.log("The value is truthy");
} else {
    console.log("The value is falsy"); // Logs: "The value is falsy"
}

// Example 3: Check if a variable is undefined
let value3;
if (value3) {
    console.log("The value is truthy");
} else {
    console.log("The value is falsy"); // Logs: "The value is falsy"
}

// Example 4: Check if an empty string is falsy
let value4 = "";
if (value4) {
    console.log("The value is truthy");
} else {
    console.log("The value is falsy"); // Logs: "The value is falsy"
}

// Example 5: Check if a non-zero number is truthy
let value5 = 42;
if (value5) {
    console.log("The value is truthy"); // Logs: "The value is truthy"
} else {
    console.log("The value is falsy");
}

// Example 6: Check if null is falsy
let value6 = null;
if (value6) {
    console.log("The value is truthy");
} else {
    console.log("The value is falsy"); // Logs: "The value is falsy"
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-bp', event)">
              best practices
            </td>
          </tr>
          <tr id="detail-tag-bp" class="expandable-row-content">
            <td>
              <h3>best practices</h3>
              <p>Best practices for conditionals in JavaScript focus on writing clear, readable, and efficient code. First, always use strict equality (`===`) and strict inequality (`!==`) to avoid unexpected type coercion, ensuring that both the value and type are compared. Second, keep conditionals simple and avoid deeply nested structures; if a function becomes too complex, consider breaking it into smaller, more manageable pieces. Third, leverage short-circuit evaluation to provide default values or to avoid unnecessary computations. For example, use `||` to set default values and `&&` to execute code only if certain conditions are met. Fourth, use descriptive variable names and comments to make the purpose of the condition clear. Additionally, handle edge cases explicitly and use the `default` case in `switch` statements to cover unexpected values. Finally, when multiple conditions need to be checked, consider using `switch` statements for better readability over multiple `if...else if` statements. Following these practices will result in more maintainable and less error-prone code.</p>
              <br />
            </td>
          </tr>
          
          <tr>
            <td id="comments" class="tableletters">Comments</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-slc', event)">
              single line comments
            </td>
          </tr>
          <tr id="detail-tag-slc" class="expandable-row-content">
            <td>
              <h3>single line comments</h3>
              <p>In JavaScript, single-line comments are used to add brief explanations or notes within the code. They are created using two forward slashes //. Everything following the // on that line will be considered a comment and ignored by the JavaScript engine during execution.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// This is a single-line comment

// Declare and initialize a variable to store age
let age = 25;
           
// Check if the score is greater than or equal to 80
let score = 85;
if (score >= 80) {
  console.log('Great job!');
} else {
  console.log('Keep trying!');
}    

// Loop through numbers from 1 to 5
for (let i = 1; i <= 5; i++) {
  console.log(i); // Output the current number
}
 
// Function to add two numbers
function add(a, b) {
  return a + b; // Return the sum
}
console.log(add(2, 3)); // Output: 5
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-mlc', event)">
              multi line comments
            </td>
          </tr>
          <tr id="detail-tag-mlc" class="expandable-row-content">
            <td>
              <h3>multi line comments</h3>
              <p>Multi-line comments in JavaScript are used to comment out blocks of code or add longer explanations within the code. They start with /* and end with */. Everything between these delimiters is considered a comment and ignored by the JavaScript engine during execution.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
/*
  This is a multi-line comment.
  It can span multiple lines.
*/

/*
  Declare and initialize a variable to store the user's age.
  This value will be used to determine access permissions.
*/
let age = 30;

/*
  Function to greet the user.
  It prints a welcome message to the console.
*/
function greetUser(name) {
  console.log('Hello, ' + name + '!');
}

/*
  Loop through an array of numbers.
  Print each number to the console.
*/
let numbers = [1, 2, 3, 4, 5];
for (let i = 0; i < numbers.length; i++) {
  console.log(numbers[i]); // Print the current number
}
           </code></pre>
              <br />
            </td>
          </tr>


            <td id="data-types" class="tableletters">Data Types</td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-data-types', event)"
            >7 primitive data types & objects
            </td>
          </tr>
          <tr id="detail-tag-data-types" class="expandable-row-content">
            <td>
              <h3>7 primitive data types & objects</h3>
              <p>JavaScript has a variety of data types that can be categorized into primitive types and objects. Primitive types are immutable and compared by value, while objects are mutable and compared by reference.</p>
              <ol>
                <li>String: Represents text and is enclosed in quotes.</li>
                <li>Number: Represents both integers and floating-point numbers.</li>
                <li>Boolean: Represents true or false values.</li>
                <li>Boolean: Represents true or false values.</li>
                <li>Null: Represents the intentional absence of any object value.</li>
                <li>Symbol: Represents a unique identifier created using the Symbol function.</li>
                <li>BigInt: Represents integers larger than the maximum safe integer limit for Number.</li>
                <li>Object: A complex data type that allows you to store collections of data in key-value pairs.</li>
              </ol>

              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// String
let greeting = "Hello, world!";
let name = 'Alice';
let phrase = `JavaScript is fun!`; // Template literals allow for embedded expressions

// Number
let age = 25;
let pi = 3.14159;
let negativeNumber = -42; // Negative number example

// Boolean
let isStudent = true;
let hasGraduated = false;
let isLoggedIn = true;

// Undefined
let x;
let y = undefined;
let z; // Undefined by default when not assigned

// Null
let emptyValue = null;
let noValue = null;
let response = null; // Commonly used to indicate no response or empty result

// Symbol
let sym1 = Symbol('unique');
let sym2 = Symbol('unique');
let sym3 = Symbol(); // Symbol without a description

// BigInt
let bigInt1 = 1234567890123456789012345678901234567890n;
let bigInt2 = BigInt(1234567890123456789012345678901234567890);
let bigInt3 = 9007199254740991n; // Maximum safe integer + 1

// Object
let person = {
  name: "Alice",
  age: 25
};
let car = {
  brand: "Toyota",
  model: "Corolla"
};
let book = {
  title: "JavaScript: The Good Parts",
  author: "Douglas Crockford"
};
          

</code></pre>
              <br />
            </td>
          </tr>
          <td id="ao" class="tableletters">Arithmetic Operators</td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-add', event)"
            >
            addition (+)
            </td>
          </tr>
          <tr id="detail-tag-add" class="expandable-row-content">
            <td>
              <h3>addition (+)</h3>
              <p>In JavaScript, the + operator is used for two primary purposes: numeric addition and string concatenation. When used with numbers, + performs arithmetic addition to calculate their sum. For example, 5 + 3 results in 8 and 10 + 15 results in 25, while 7 + -2 adds a negative number to get 5. When used with strings, the + operator concatenates them into a single string. For instance, "Hello, " + "world!" produces "Hello, world!", and concatenating "Alice" and "Johnson" with a space results in "Alice Johnson". If you add a number to a string, the number is converted to a string and concatenated. For example, 10 + " apples" yields "10 apples", and "The result is " + (2 + 3) first evaluates the addition inside the parentheses to get 5, then concatenates it with the string to produce "The result is 5". A special case of addition is adding null to a number, where null is treated as 0, so 5 + null results in 5. Similarly, adding undefined to a string results in "undefined" as a string, so "Value is " + undefined produces "Value is undefined".</p>

              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Numeric Addition
let sum1 = 5 + 3;       // 8
let sum2 = 10 + 15;     // 25
let sum3 = 7 + -2;      // 5 (adding a negative number)

// String Concatenation
let greeting = "Hello, " + "world!";  // "Hello, world!"
let firstName = "Alice";
let lastName = "Johnson";
let fullName = firstName + " " + lastName;  // "Alice Johnson"

// Number and String Concatenation
let number = 10;
let text = "The number is " + number;  // "The number is 10"

// Adding a String and a Number (Implicit Conversion)
let addition = 5 + " apples";  // "5 apples" (number converted to string)
let result = "The result is " + (2 + 3);  // "The result is 5"

// Adding null to a number
let resultNull = 5 + null;  // 5 (null is converted to 0)

// Adding undefined to a string
let resultUndefined = "Value is " + undefined;  // "Value is undefined"

</code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-sub', event)"
            >
            subtraction (-)
            </td>
          </tr>
          <tr id="detail-tag-sub" class="expandable-row-content">
            <td>
              <h3>subtraction (-)</h3>
              <p>In JavaScript, the - operator is used primarily for numeric subtraction. It subtracts the right operand from the left operand to yield a numerical result. If used with two numbers, such as 8 - 3, it calculates the difference, which is 5. Subtraction can also be applied to negative numbers, for instance, 10 - (-4) results in 14 as it effectively adds the absolute value of the negative number. When - is used with non-numeric types, JavaScript first tries to convert the operands to numbers. If one operand is a string and the other is a number, JavaScript attempts to convert the string to a number; for example, "10" - 5 results in 5 because "10" is converted to the number 10. If the string cannot be converted to a number, such as in "hello" - 5, the result is NaN (Not-a-Number). Additionally, subtracting null from a number results in the number itself, as null is converted to 0; for instance, 15 - null equals 15. However, subtracting undefined from a number results in NaN, as undefined cannot be converted to a number, so 10 - undefined yields NaN.</p>

              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Numeric Subtraction
let difference1 = 8 - 3;         // 5
let difference2 = 10 - 4;        // 6
let difference3 = 10 - (-4);     // 14 (subtracting a negative number)

// Subtracting a String from a Number (Implicit Conversion)
let result1 = "10" - 5;         // 5 (string "10" is converted to number 10)
let result2 = "20" - "5";       // 15 (both strings are converted to numbers)

// Subtracting Non-Numeric Strings
let result3 = "hello" - 5;      // NaN (non-numeric string cannot be converted to a number)

// Subtracting null from a Number
let result4 = 15 - null;       // 15 (null is converted to 0)

// Subtracting undefined from a Number
let result5 = 10 - undefined;  // NaN (undefined cannot be converted to a number)

</code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-multi', event)"
            >
            multiplication (*)
            </td>
          </tr>
          <tr id="detail-tag-multi" class="expandable-row-content">
            <td>
              <h3>multiplication (*)</h3>
              <p>In JavaScript, the * operator is used for numeric multiplication. It multiplies the two operands and returns the product. For example, using 5 * 3 results in 15, as it multiplies 5 by 3. The * operator also supports multiplication with floating-point numbers, where 2.5 * 4 results in 10.0. JavaScript handles cases where one or both operands are non-numeric values by attempting to convert them into numbers before performing the multiplication. If one operand is a string that represents a number, like "7", multiplying it by a number results in 7, as the string "7" is converted to the number 7. However, if the string cannot be converted to a number, such as "hello" * 3, the result is NaN (Not-a-Number). Additionally, multiplying null by a number treats null as 0, so null * 4 yields 0. When undefined is involved in multiplication with a number, the result is also NaN, as undefined cannot be converted to a number, so 5 * undefined results in NaN.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Numeric Multiplication
let product1 = 5 * 3;         // 15
let product2 = 2.5 * 4;       // 10.0
let product3 = -7 * 6;        // -42 (multiplying a negative number)

// Multiplying a String that Represents a Number
let result1 = "7" * 2;        // 14 (string "7" is converted to number 7)
let result2 = "5.5" * 2;      // 11.0 (string "5.5" is converted to number 5.5)
let result3 = "10" * 3;       // 30 (string "10" is converted to number 10)

// Multiplying Non-Numeric Strings
let result4 = "hello" * 3;    // NaN (non-numeric string cannot be converted to a number)

// Multiplying null by a Number
let result5 = null * 4;      // 0 (null is converted to 0)

// Multiplying undefined by a Number
let result6 = 5 * undefined; // NaN (undefined cannot be converted to a number)

</code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-div', event)"
            >
            division (/)
            </td>
          </tr>
          <tr id="detail-tag-div" class="expandable-row-content">
            <td>
              <h3>division (/)</h3>
              <p>In JavaScript, the / operator is used for numeric division. It divides the left operand by the right operand and returns the quotient. For example, 10 / 2 results in 5, as it divides 10 by 2. The / operator supports division with both integers and floating-point numbers, such as 7.5 / 2 which results in 3.75. When one or both of the operands are non-numeric types, JavaScript attempts to convert them to numbers before performing the division. For instance, if one operand is a string that represents a number, like "8", dividing it by a number yields 4, since the string "8" is converted to the number 8. However, if the string cannot be converted to a number, such as "hello" / 2, the result is NaN (Not-a-Number). Additionally, dividing a number by null treats null as 0, so dividing by null results in Infinity or -Infinity depending on the sign of the dividend. For example, 10 / null yields Infinity, while -10 / null results in -Infinity. When undefined is used in division with a number, the result is NaN, as undefined cannot be converted to a number, so 5 / undefined results in NaN.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Numeric Division
let quotient1 = 10 / 2;         // 5
let quotient2 = 7.5 / 2;       // 3.75
let quotient3 = -10 / 2;       // -5 (dividing a negative number)

// Dividing a String that Represents a Number
let result1 = "8" / 2;        // 4 (string "8" is converted to number 8)
let result2 = "5.5" / 2;      // 2.75 (string "5.5" is converted to number 5.5)
let result3 = "12" / 4;       // 3 (string "12" is converted to number 12)

// Dividing Non-Numeric Strings
let result4 = "hello" / 2;    // NaN (non-numeric string cannot be converted to a number)

// Dividing by null
let result5 = 10 / null;     // Infinity (null is converted to 0)
let result6 = -10 / null;    // -Infinity (null is converted to 0)

// Dividing by undefined
let result7 = 5 / undefined; // NaN (undefined cannot be converted to a number)

// Special Cases
let zeroDiv = 5 / 0;      // Infinity (dividing by zero yields Infinity)
let negativeZeroDiv = -5 / 0;  // -Infinity (dividing by zero yields -Infinity)

</code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-rem', event)"
            >
            remainder (%)
            </td>
          </tr>
          <tr id="detail-tag-rem" class="expandable-row-content">
            <td>
              <h3>remainder (%)</h3>
              <p>In JavaScript, the % operator is used to calculate the remainder of the division between two numbers. It performs a division operation and returns the remainder after the division. For example, 10 % 3 results in 1, as 10 divided by 3 is 3 with a remainder of 1. The % operator works with both positive and negative numbers, where -10 % 3 results in -1, as it computes the remainder considering the sign of the dividend. When used with non-numeric values, JavaScript attempts to convert the operands to numbers before calculating the remainder. For instance, if one operand is a string that represents a number, like "9", the operation "9" % 4 yields 1, as "9" is converted to 9 and then the remainder of 9 divided by 4 is 1. If the string cannot be converted to a number, such as "hello" % 2, the result is NaN (Not-a-Number). Additionally, when null is used as an operand, null is treated as 0, so 10 % null yields NaN because division by 0 is undefined. When undefined is involved, the result of the operation is also NaN, as undefined cannot be converted to a number, so 5 % undefined results in NaN.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Numeric Remainder
let remainder1 = 10 % 3;        // 1 (10 divided by 3 has a remainder of 1)
let remainder2 = 20 % 4;        // 0 (20 divided by 4 has no remainder)
let remainder3 = -10 % 3;       // -1 (negative dividend with positive divisor)

// Remainder with a String that Represents a Number
let result1 = "9" % 4;         // 1 (string "9" is converted to number 9)
let result2 = "15" % 6;        // 3 (string "15" is converted to number 15)
let result3 = "8" % 2;         // 0 (string "8" is converted to number 8)

// Remainder with Non-Numeric Strings
let result4 = "hello" % 2;     // NaN (non-numeric string cannot be converted to a number)

// Remainder with null
let result5 = 10 % null;      // NaN (null is converted to 0, division by 0 is undefined)

// Remainder with undefined
let result6 = 5 % undefined;  // NaN (undefined cannot be converted to a number)

// Special Cases
let zeroDiv = 0 % 5;          // 0 (0 divided by any number has a remainder of 0)
let negZeroDiv = -5 % 2;      // -1 (negative dividend with positive divisor)

</code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-expo', event)"
            >
            exponentiation (**)
            </td>
          </tr>
          <tr id="detail-tag-expo" class="expandable-row-content">
            <td>
              <h3>exponentiation (**)</h3>
              <p>In JavaScript, the / operator is used for numeric division. It divides the left operand by the right operand and returns the quotient. For example, 10 / 2 results in 5, as it divides 10 by 2. The / operator supports division with both integers and floating-point numbers, such as 7.5 / 2 which results in 3.75. When one or both of the operands are non-numeric types, JavaScript attempts to convert them to numbers before performing the division. For instance, if one operand is a string that represents a number, like "8", dividing it by a number yields 4, since the string "8" is converted to the number 8. However, if the string cannot be converted to a number, such as "hello" / 2, the result is NaN (Not-a-Number). Additionally, dividing a number by null treats null as 0, so dividing by null results in Infinity or -Infinity depending on the sign of the dividend. For example, 10 / null yields Infinity, while -10 / null results in -Infinity. When undefined is used in division with a number, the result is NaN, as undefined cannot be converted to a number, so 5 / undefined results in NaN.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Numeric Exponentiation
let power1 = 2 ** 3;          // 8 (2 raised to the power of 3 is 8)
let power2 = 4 ** -2;         // 0.0625 (4 raised to the power of -2 is 1/16)
let power3 = 2.5 ** 2;       // 6.25 (2.5 raised to the power of 2 is 6.25)

// Exponentiation with a String that Represents a Number
let result1 = "3" ** 2;      // 9 (string "3" is converted to number 3)
let result2 = "5.5" ** 2;    // 30.25 (string "5.5" is converted to number 5.5)
let result3 = "7" ** 0;      // 1 (any number to the power of 0 is 1)

// Exponentiation with Non-Numeric Strings
let result4 = "hello" ** 2; // NaN (non-numeric string cannot be converted to a number)

// Exponentiation with null
let result5 = null ** 2;    // 0 (null is treated as 0 for exponentiation)

// Exponentiation with undefined
let result6 = 5 ** undefined; // NaN (undefined cannot be converted to a number)

// Special Cases
let zeroBase = 0 ** 3;          // 0 (0 raised to any power other than 0 yields 0)
let negativeExponent = 2 ** -3; // 0.125 (2 raised to the power of -3 is 1/8)

</code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-inc', event)"
            >
            increment (++)
            </td>
          </tr>
          <tr id="detail-tag-inc" class="expandable-row-content">
            <td>
              <h3>increment (++)</h3>
              <p>In JavaScript, the ++ operator is used to increment a number by one. This operator can be applied in two ways: as a prefix (before the operand) or as a postfix (after the operand). When used as a prefix, such as ++x, the value of x is incremented before it is used in an expression. Conversely, when used as a postfix, such as x++, the value of x is incremented after its current value has been used in the expression. The ++ operator only affects numbers; when applied to non-numeric values, JavaScript attempts to convert them to numbers. For example, "5"++ converts "5" to 5 and increments it to 6. If the string cannot be converted to a number, such as "hello"++, it results in NaN (Not-a-Number). Applying the ++ operator to null treats null as 0, so null++ increments null to 1. However, applying the ++ operator to undefined results in NaN because undefined cannot be converted to a number, so undefined++ yields NaN.</p>

              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Prefix Increment
let x = 5;
let y = ++x;       // 6 (x is incremented to 6 before assigning to y)

// Postfix Increment
let a = 3;
let b = a++;       // 3 (a is assigned to b first, then a is incremented to 4)

// Increment with a String that Represents a Number
let result1 = "7"++;  // Results in an error (Postfix ++ does not work with strings)

// Increment with Non-Numeric Strings
let result2 = "hello"++; // NaN (non-numeric string cannot be incremented)

// Increment with null
let result3 = null++;  // 1 (null is treated as 0, then incremented to 1)

// Increment with undefined
let result4 = undefined++; // NaN (undefined cannot be incremented)

// Special Cases
let object = { count: 1 };
object.count++;       // 2 (increments the `count` property of the object)

// Prefix and Postfix Increment with Arrays
let array = [1, 2, 3];
++array[0];           // 2 (prefix increment on the first element of the array)
array[1]++;           // 3 (postfix increment on the second element of the array)

</code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td
              class="clickable"
              onclick="toggleDetail('detail-tag-dec', event)"
            >
            decrement (--)
            </td>
          </tr>
          <tr id="detail-tag-dec" class="expandable-row-content">
            <td>
              <h3>decrement (--)</h3>
              <p>In JavaScript, the -- operator is used to decrement a number by one. This operator can be utilized in two distinct ways: as a prefix (before the operand) or as a postfix (after the operand). When used as a prefix, such as --x, the value of x is decremented before it is used in any expression. Conversely, when used as a postfix, such as x--, the value of x is decremented after its current value has been used. The -- operator operates exclusively on numbers; if applied to non-numeric values, JavaScript attempts to convert the operands to numbers before performing the decrement operation. For example, "5"-- converts the string "5" to 5 and decrements it to 4. If the string cannot be converted to a number, such as "hello"--, it results in NaN (Not-a-Number). When null is decremented, null is treated as 0, so null-- decrements null to -1. However, decrementing undefined results in NaN because undefined cannot be converted to a number, so undefined-- yields NaN.</p>

              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Prefix Decrement
let x = 5;
let y = --x;       // 4 (x is decremented to 4 before assigning to y)

// Postfix Decrement
let a = 3;
let b = a--;       // 3 (a is assigned to b first, then a is decremented to 2)

// Decrement with a String that Represents a Number
let result1 = "7"--;  // 6 (string "7" is converted to number 7 and decremented to 6)
let result2 = "3"--;  // 2 (string "3" is converted to number 3 and decremented to 2)

// Decrement with Non-Numeric Strings
let result3 = "hello"--; // NaN (non-numeric string cannot be decremented)

// Decrement with null
let result4 = null--;  // -1 (null is treated as 0, then decremented to -1)

// Decrement with undefined
let result5 = undefined--; // NaN (undefined cannot be decremented)

// Special Cases
let object = { count: 5 };
object.count--;       // 5 (decrements the `count` property of the object to 4)

// Prefix and Postfix Decrement with Arrays
let array = [3, 4, 5];
--array[0];           // 2 (prefix decrement on the first element of the array)
array[1]--;           // 3 (postfix decrement on the second element of the array)

</code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td id="functions" class="tableletters">Functions</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-overview', event)">
              overview
            </td>
          </tr>
          <tr id="detail-tag-overview" class="expandable-row-content">
            <td>
              <h3>overview</h3>
              <p>JavaScript functions are essential components of the language, providing a way to encapsulate code into reusable and maintainable blocks. Defined using the `function` keyword, followed by a function name, a set of parentheses, and a code block enclosed in curly braces, functions can take parameters and perform operations based on the provided arguments. They are invoked by calling the function name with parentheses, optionally passing arguments. Functions can return values using the `return` statement, allowing them to output results that can be used in other parts of the program. JavaScript also supports anonymous functions, which are functions without names, often utilized in event handling or as immediately invoked function expressions (IIFE). With the introduction of ES6, arrow functions offer a more concise syntax and lexically bind the `this` keyword, making them particularly useful for callbacks and functional programming techniques. Functions in JavaScript can be assigned to variables, passed as arguments to other functions, and even returned from other functions, enabling the creation of higher-order functions. They can also be nested, meaning a function can be defined within another function, providing a way to create private scopes. This encapsulation helps in avoiding global namespace pollution. Functions enhance code readability and organization by breaking down complex operations into smaller, manageable tasks. They support recursion, allowing a function to call itself, which is useful for tasks like traversing data structures or solving problems with repetitive patterns. Additionally, JavaScript functions can be defined using function expressions or function declarations, each with its scope and hoisting behaviors. Functions are fundamental in implementing modular, maintainable code structures, promoting reuse and reducing redundancy. Asynchronous operations, such as those involving callbacks, promises, and async/await syntax, rely heavily on functions. They are also the foundation for many JavaScript design patterns and libraries, making a deep understanding of functions crucial for effective JavaScript programming. Overall, JavaScript functions are versatile and powerful, enabling developers to write efficient, readable, and maintainable code.</p>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-fd', event)">
              function declaration
            </td>
          </tr>
          <tr id="detail-tag-fd" class="expandable-row-content">
            <td>
              <h3>function declaration</h3>
              <p>In JavaScript, function declarations are one of the primary ways to define functions, offering a straightforward syntax and certain benefits, such as hoisting. A function declaration consists of the `function` keyword followed by a name, a set of parentheses for parameters, and a block of code enclosed in curly braces. For example, `function greet() { console.log("Hello, world!"); }` defines a function named `greet` that logs a message to the console. One significant feature of function declarations is hoisting, which allows the function to be called before its definition in the code. This means that the JavaScript engine processes the function declarations at the compile phase, making them available throughout their scope. Function declarations are typically used when the function needs to be reused multiple times, enhancing code readability and maintainability. They create a function object and bind it to the function's name within the current scope, enabling easy invocation. Function declarations are integral to structuring code in a modular and organized manner, facilitating the breakdown of complex operations into manageable and reusable pieces.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Function to greet a user
function greet() {
    console.log("Hello, world!");
}
greet(); // Logs: "Hello, world!"

// Example 2: Function to add two numbers
function add(a, b) {
    return a + b;
}
console.log(add(5, 3)); // Logs: 8

// Example 3: Function to check if a number is even
function isEven(number) {
    return number % 2 === 0;
}
console.log(isEven(4)); // Logs: true

// Example 4: Function to calculate the square of a number
function square(x) {
    return x * x;
}
console.log(square(5)); // Logs: 25

// Example 5: Function to find the maximum of two numbers
function max(a, b) {
    return a > b ? a : b;
}
console.log(max(10, 15)); // Logs: 15

// Example 6: Function to print a message multiple times
function repeatMessage(message, times) {
    for (let i = 0; i < times; i++) {
        console.log(message);
    }
}
repeatMessage("Hello!", 3); // Logs: "Hello!" three times

// Example 7: Function to convert Celsius to Fahrenheit
function toFahrenheit(celsius) {
    return celsius * 9 / 5 + 32;
}
console.log(toFahrenheit(0)); // Logs: 32

// Example 8: Function to find the factorial of a number
function factorial(n) {
    if (n === 0) {
        return 1;
    }
    return n * factorial(n - 1);
}
console.log(factorial(5)); // Logs: 120

// Example 9: Function to reverse a string
function reverseString(str) {
    return str.split('').reverse().join('');
}
console.log(reverseString("hello")); // Logs: "olleh"

// Example 10: Function to check if a string is a palindrome
function isPalindrome(str) {
    let reversed = str.split('').reverse().join('');
    return str === reversed;
}
console.log(isPalindrome("racecar")); // Logs: true

            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-call', event)">
              calling a function
            </td>
          </tr>
          <tr id="detail-tag-call" class="expandable-row-content">
            <td>
              <h3>calling a function</h3>
              <p>Calling a function in JavaScript involves executing the code within the function's block by invoking the function's name followed by parentheses, optionally including arguments inside the parentheses if the function requires parameters. When a function is called, the JavaScript engine creates a new execution context for it, assigns the provided arguments to the corresponding parameters, and runs the function's code. If the function has a return statement, the value specified by that statement is returned to the caller; otherwise, the function returns `undefined` by default. Function calls can be made from anywhere in the code, including from within other functions, allowing for modular and reusable code. Calling a function is essential for utilizing its defined behavior and achieving the desired operations within a program. Properly invoking functions enables developers to build complex applications by breaking down tasks into manageable, reusable units of code.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Calling a function to print a greeting message
function greet() {
    console.log("Hello, world!");
}
greet(); // Logs: "Hello, world!"

// Example 2: Calling a function to add two numbers and print the result
function add(a, b) {
    return a + b;
}
console.log(add(5, 3)); // Logs: 8

// Example 3: Calling a function to check if a number is even and print the result
function isEven(number) {
    return number % 2 === 0;
}
console.log(isEven(4)); // Logs: true

// Example 4: Calling a function to convert Celsius to Fahrenheit and print the result
function toFahrenheit(celsius) {
    return celsius * 9 / 5 + 32;
}
console.log(toFahrenheit(0)); // Logs: 32

// Example 5: Calling a function to reverse a string and print the result
function reverseString(str) {
    return str.split('').reverse().join('');
}
console.log(reverseString("hello")); // Logs: "olleh"

            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-para', event)">
              parameters and arguments
            </td>
          </tr>
          <tr id="detail-tag-para" class="expandable-row-content">
            <td>
              <h3>parameters and arguments</h3>
              <p>In JavaScript, parameters and arguments are key concepts in functions that enable the passing of data into functions for processing. Parameters are the names listed in the function definition and act as placeholders for the values that will be passed to the function when it is called. For instance, in the function `function add(a, b)`, `a` and `b` are parameters. Arguments, on the other hand, are the actual values that are passed to the function when it is invoked. For example, in the call `add(5, 3)`, the values `5` and `3` are arguments. Parameters define what type of input a function can accept, while arguments provide the actual input data. When a function is called, the arguments are assigned to the corresponding parameters, and the function uses these values to execute its code. This mechanism allows functions to be flexible and reusable, as the same function can be called with different arguments to perform a variety of tasks. Understanding how to use parameters and arguments effectively is crucial for writing dynamic and adaptable JavaScript code.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Function with parameters to add two numbers
function add(a, b) {
    return a + b;
}
console.log(add(5, 3)); // Logs: 8

// Example 2: Function with parameters to greet a user by name
function greet(name) {
    console.log("Hello, " + name + "!");
}
greet("Alice"); // Logs: "Hello, Alice!"

// Example 3: Function with parameters to calculate the area of a rectangle
function calculateArea(width, height) {
    return width * height;
}
console.log(calculateArea(5, 10)); // Logs: 50

// Example 4: Function with parameters to determine if a number is greater than another
function isGreater(a, b) {
    return a > b;
}
console.log(isGreater(10, 5)); // Logs: true

// Example 5: Function with parameters to concatenate two strings
function concatenate(str1, str2) {
    return str1 + " " + str2;
}
console.log(concatenate("Hello", "world")); // Logs: "Hello world"
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-default', event)">
              default parameters
            </td>
          </tr>
          <tr id="detail-tag-default" class="expandable-row-content">
            <td>
              <h3>default parameters</h3>
              <p>Default parameters in JavaScript functions allow you to specify default values for parameters in case no arguments are provided or if `undefined` is passed as an argument when the function is called. This feature, introduced in ES6, simplifies the function definitions by eliminating the need for manual checks and assignments within the function body. To set a default parameter, you simply assign a value to the parameter in the function definition, like `function greet(name = "Guest")`. If the caller does not provide a value for `name`, it will default to "Guest". This mechanism enhances the flexibility and robustness of functions, ensuring they have meaningful default behavior even when some arguments are omitted. Default parameters can also be expressions or even other function calls, providing a powerful tool for managing function inputs and improving code readability.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Function with a default parameter for greeting
function greet(name = "Guest") {
    console.log("Hello, " + name + "!");
}
greet(); // Logs: "Hello, Guest!"
greet("Alice"); // Logs: "Hello, Alice!"

// Example 2: Function with a default parameter for addition
function add(a = 0, b = 0) {
    return a + b;
}
console.log(add()); // Logs: 0
console.log(add(5)); // Logs: 5
console.log(add(5, 3)); // Logs: 8

// Example 3: Function with a default parameter for multiplication
function multiply(a, b = 1) {
    return a * b;
}
console.log(multiply(5)); // Logs: 5
console.log(multiply(5, 2)); // Logs: 10

// Example 4: Function with a default parameter for calculating power
function power(base, exponent = 2) {
    return Math.pow(base, exponent);
}
console.log(power(3)); // Logs: 9
console.log(power(3, 3)); // Logs: 27

// Example 5: Function with a default parameter for formatting a date
function formatDate(date = new Date()) {
    return date.toDateString();
}
console.log(formatDate()); // Logs: Current date in string format
console.log(formatDate(new Date('2022-01-01'))); // Logs: "Sat Jan 01 2022"
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-return', event)">
              return keyword
            </td>
          </tr>
          <tr id="detail-tag-return" class="expandable-row-content">
            <td>
              <h3>return keyword</h3>
              <p>The `return` keyword in JavaScript functions is used to specify the value that a function should output when it is called. When a function reaches a `return` statement, it immediately stops execution and returns the specified value to the caller. This allows functions to produce results that can be used elsewhere in the code. For example, a function that performs a calculation can return the result so it can be assigned to a variable or used in another computation. If a function does not explicitly return a value, it implicitly returns `undefined`. The `return` keyword is essential for creating reusable and modular code, as it enables functions to provide outputs based on their input parameters and internal logic. Using `return` effectively can make functions more versatile and the overall codebase more maintainable and efficient.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Function with no return statement, implicitly returns undefined
function noReturn() {
    let a = 5 + 3;
}
console.log(noReturn()); // Logs: undefined

// Example 2: Function to add two numbers and return the result
function add(a, b) {
    return a + b;
}
console.log(add(5, 3)); // Logs: 8

// Example 3: Function to find the square of a number and return the result
function square(x) {
    return x * x;
}
console.log(square(4)); // Logs: 16

// Example 4: Function to concatenate two strings and return the result
function concatenate(str1, str2) {
    return str1 + " " + str2;
}
console.log(concatenate("Hello", "world")); // Logs: "Hello world"

// Example 5: Function to determine if a number is even and return the result
function isEven(number) {
    return number % 2 === 0;
}
console.log(isEven(10)); // Logs: true
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-helper', event)">
              helper functions
            </td>
          </tr>
          <tr id="detail-tag-helper" class="expandable-row-content">
            <td>
              <h3>helper functions</h3>
              <p>Helper functions in JavaScript are small, reusable functions designed to perform specific tasks that support the main operations of a program. These functions typically handle common or repetitive tasks, such as data formatting, calculations, or other utility operations, thereby promoting code reusability and modularity. By breaking down complex problems into smaller, manageable functions, helper functions make the main codebase cleaner, more readable, and easier to maintain. They encapsulate functionality that can be tested independently, improving code reliability and facilitating debugging. For instance, a helper function might be used to validate user input, format dates, or manipulate arrays. Using helper functions allows developers to avoid redundancy, as the same piece of logic can be called multiple times from different parts of the application, ensuring consistency and reducing the likelihood of errors. Overall, helper functions are a fundamental practice in writing efficient and maintainable JavaScript code.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Helper function to format a date
function formatDate(date) {
    const options = { year: 'numeric', month: 'long', day: 'numeric' };
    return date.toLocaleDateString(undefined, options);
}
const date = new Date('2024-07-24');
console.log(formatDate(date)); // Logs: "July 24, 2024"

// Example 2: Helper function to validate an email address
function isValidEmail(email) {
    const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return re.test(email);
}
console.log(isValidEmail("test@example.com")); // Logs: true
console.log(isValidEmail("invalid-email")); // Logs: false

// Example 3: Helper function to capitalize the first letter of a string
function capitalizeFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
console.log(capitalizeFirstLetter("hello")); // Logs: "Hello"

// Example 4: Helper function to generate a random integer between two values
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
console.log(getRandomInt(1, 10)); // Logs: a random number between 1 and 10

// Example 5: Helper function to remove duplicates from an array
function removeDuplicates(arr) {
    return [...new Set(arr)];
}
const arrayWithDuplicates = [1, 2, 2, 3, 4, 4, 5];
console.log(removeDuplicates(arrayWithDuplicates)); // Logs: [1, 2, 3, 4, 5]

            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-fexpressions', event)">
              function expressions
            </td>
          </tr>
          <tr id="detail-tag-fexpressions" class="expandable-row-content">
            <td>
              <h3>function expressions</h3>
              <p>Function expressions in JavaScript are a way to define functions as part of a larger expression, typically assigned to a variable. Unlike function declarations, which are hoisted and available throughout their scope, function expressions are not hoisted and are only available after their assignment is evaluated. A function expression can be anonymous, meaning it does not have a name, or named, where the function is assigned a name for reference within its own scope. For example, `const add = function(a, b) { return a + b; };` defines a function expression assigned to the variable `add`. This form of function definition is particularly useful for creating closures, passing functions as arguments to other functions, or defining functions within conditional blocks. Function expressions provide more flexibility and control over when and how functions are defined and executed, contributing to more modular and maintainable code. They are fundamental in many JavaScript programming patterns, including immediately invoked function expressions (IIFEs) and callbacks, enhancing the language's functional programming capabilities.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Anonymous function expression assigned to a variable
const greet = function() {
    console.log("Hello, world!");
};
greet(); // Logs: "Hello, world!"

// Example 2: Named function expression assigned to a variable
const factorial = function fact(n) {
    if (n <= 1) return 1;
    return n * fact(n - 1);
};
console.log(factorial(5)); // Logs: 120

// Example 3: Function expression used as a callback
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(function(num) {
    return num * 2;
});
console.log(doubled); // Logs: [2, 4, 6, 8, 10]

// Example 4: Immediately Invoked Function Expression (IIFE)
(function() {
    console.log("This function runs immediately!");
})(); // Logs: "This function runs immediately!"

// Example 5: Function expression used in an object method
const mathOperations = {
    add: function(a, b) {
        return a + b;
    },
    subtract: function(a, b) {
        return a - b;
    }
};
console.log(mathOperations.add(10, 5)); // Logs: 15
console.log(mathOperations.subtract(10, 5)); // Logs: 5

// Example 6: Function expression used as an event handler
document.getElementById("myButton").addEventListener("click", function() {
    console.log("Button clicked!");
}); // Logs: "Button clicked!" when the button is clicked

// Example 7: Function expression to filter an array
const isEven = function(num) {
    return num % 2 === 0;
};
const evens = numbers.filter(isEven);
console.log(evens); // Logs: [2, 4]

// Example 8: Function expression to find the maximum in an array
const max = function(arr) {
    return Math.max.apply(null, arr);
};
console.log(max([1, 2, 3, 4, 5])); // Logs: 5

// Example 9: Function expression to sort an array
const sorted = numbers.sort(function(a, b) {
    return b - a;
});
console.log(sorted); // Logs: [5, 4, 3, 2, 1]

// Example 10: Function expression to convert an array of strings to uppercase
const upperCaseStrings = ["hello", "world"].map(function(str) {
    return str.toUpperCase();
});
console.log(upperCaseStrings); // Logs: ["HELLO", "WORLD"]

            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-arrow', event)">
              arrow functions
            </td>
          </tr>
          <tr id="detail-tag-arrow" class="expandable-row-content">
            <td>
              <h3>arrow functions</h3>
              <p>Arrow functions in JavaScript, introduced in ES6, provide a concise syntax for writing functions. Unlike traditional function expressions, arrow functions do not have their own `this`, `arguments`, `super`, or `new.target` bindings. Instead, they lexically inherit `this` from the surrounding function or scope, which makes them particularly useful for maintaining the correct `this` context inside callbacks and other nested functions. The syntax of arrow functions is shorter: parameters are enclosed in parentheses (which can be omitted if there's only one parameter), followed by the `=>` symbol, and the function body. For single expression functions, curly braces and the `return` keyword can be omitted, resulting in even more compact code. For example, `const add = (a, b) => a + b;` defines a simple arrow function that adds two numbers. Arrow functions enhance code readability and are often used in array methods like `map`, `filter`, and `reduce` due to their brevity and automatic binding of `this`. However, they are not suitable for all situations, such as methods in an object, where traditional function expressions are more appropriate.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Simple arrow function to add two numbers
const add = (a, b) => a + b;
console.log(add(5, 3)); // Logs: 8

// Example 2: Arrow function with a single parameter
const square = x => x * x;
console.log(square(4)); // Logs: 16

// Example 3: Arrow function returning an object
const createUser = (name, age) => ({ name, age });
console.log(createUser("Alice", 30)); // Logs: { name: 'Alice', age: 30 }

// Example 4: Arrow function with no parameters
const greet = () => "Hello, world!";
console.log(greet()); // Logs: "Hello, world!"

// Example 5: Arrow function used as a callback in array map method
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(num => num * 2);
console.log(doubled); // Logs: [2, 4, 6, 8, 10]

// Example 6: Arrow function used in array filter method
const evens = numbers.filter(num => num % 2 === 0);
console.log(evens); // Logs: [2, 4]

// Example 7: Arrow function used in array reduce method
const sum = numbers.reduce((total, num) => total + num, 0);
console.log(sum); // Logs: 15

// Example 8: Arrow function with implicit return
const multiply = (a, b) => a * b;
console.log(multiply(6, 7)); // Logs: 42

// Example 9: Arrow function with explicit return
const isEven = num => {
    return num % 2 === 0;
};
console.log(isEven(10)); // Logs: true

// Example 10: Arrow function used inside a setTimeout
setTimeout(() => {
    console.log("This runs after 1 second");
}, 1000); // Logs: "This runs after 1 second" (after 1 second)

            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-concise', event)">
              concise body arrow functions
            </td>
          </tr>
          <tr id="detail-tag-concise" class="expandable-row-content">
            <td>
              <h3>concise body arrow functions</h3>
              <p>Concise body arrow functions in JavaScript are a streamlined way to write functions, allowing for more readable and compact code. These functions omit the curly braces and the `return` keyword when the function body contains a single expression. The value of this expression is implicitly returned, making the syntax much shorter and more convenient for simple operations. For instance, `const add = (a, b) => a + b;` is a concise body arrow function that adds two numbers and returns the result. This format is particularly useful for inline functions, such as those passed to array methods like `map`, `filter`, and `reduce`. Concise body arrow functions improve code clarity and reduce boilerplate, enabling developers to write succinct and expressive functions, especially for straightforward computations and transformations. However, for more complex logic that requires multiple statements, curly braces and an explicit `return` statement must be used.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Concise body arrow function to add two numbers
const add = (a, b) => a + b;
console.log(add(5, 3)); // Logs: 8

// Example 2: Concise body arrow function to square a number
const square = x => x * x;
console.log(square(4)); // Logs: 16

// Example 3: Concise body arrow function to return a greeting message
const greet = () => "Hello, world!";
console.log(greet()); // Logs: "Hello, world!"

// Example 4: Concise body arrow function to check if a number is even
const isEven = num => num % 2 === 0;
console.log(isEven(10)); // Logs: true

// Example 5: Concise body arrow function to get the length of a string
const getLength = str => str.length;
console.log(getLength("Hello")); // Logs: 5

// Example 6: Concise body arrow function to convert an array of numbers to their squares
const squares = numbers => numbers.map(num => num * num);
console.log(squares([1, 2, 3, 4])); // Logs: [1, 4, 9, 16]

// Example 7: Concise body arrow function to filter out odd numbers from an array
const filterOdds = numbers => numbers.filter(num => num % 2 === 0);
console.log(filterOdds([1, 2, 3, 4, 5])); // Logs: [2, 4]
          
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-bpf', event)">
              best practices
            </td>
          </tr>
          <tr id="detail-tag-bpf" class="expandable-row-content">
            <td>
              <h3>best practices</h3>
              <p>When writing functions in JavaScript, adhering to best practices is crucial for creating clean, maintainable, and efficient code. One key practice is to keep functions small and focused, adhering to the single responsibility principle, which states that a function should accomplish only one task. This approach enhances readability and makes the function easier to test and debug. Naming functions descriptively is also important; a function's name should clearly describe what it does, making the code self-documenting and understandable at a glance. Using default parameters can help handle edge cases gracefully, ensuring functions behave predictably even when called with missing arguments. Additionally, leveraging function expressions and arrow functions can improve code conciseness and maintain the correct this context, especially in callbacks. Properly using return statements is essential to avoid unintended side effects and to clearly define what a function outputs. When dealing with asynchronous operations, utilizing promises and async/await syntax helps manage code flow more effectively and avoid callback hell. It is also a good practice to avoid using global variables within functions to prevent side effects and potential conflicts in larger codebases. Instead, functions should rely on parameters and return values to pass data in and out. Documenting functions with comments or JSDoc annotations can be beneficial, especially for complex logic, providing clear explanations of the function's purpose, parameters, and return values. Testing functions thoroughly, including edge cases, ensures robustness and reliability.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Single Responsibility Principle - Function to add two numbers
function add(a, b) {
    return a + b;
}
console.log(add(5, 3)); // Logs: 8

// Example 2: Descriptive Function Name - Function to greet a user by name
function greetUser(name) {
    return `Hello, ${name}!`;
}
console.log(greetUser("Alice")); // Logs: "Hello, Alice!"

// Example 3: Using Default Parameters - Function to multiply two numbers with a default value
function multiply(a, b = 1) {
    return a * b;
}
console.log(multiply(5)); // Logs: 5
console.log(multiply(5, 3)); // Logs: 15

// Example 4: Using Arrow Functions - Function to check if a number is even
const isEven = num => num % 2 === 0;
console.log(isEven(4)); // Logs: true

// Example 5: Properly Using Return Statements - Function to find the maximum of two numbers
function max(a, b) {
    return a > b ? a : b;
}
console.log(max(10, 15)); // Logs: 15

// Example 6: Avoiding Global Variables - Function to calculate area of a rectangle
function calculateArea(width, height) {
    return width * height;
}
console.log(calculateArea(5, 10)); // Logs: 50

// Example 7: Using Async/Await - Function to fetch data from an API
async function fetchData(url) {
    try {
        let response = await fetch(url);
        let data = await response.json();
        return data;
    } catch (error) {
        console.error("Error fetching data:", error);
    }
}
fetchData('https://api.example.com/data').then(data => console.log(data));

// Example 8: Thorough Testing - Function to calculate factorial
function factorial(n) {
    if (n < 0) return undefined;
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
console.log(factorial(5)); // Logs: 120
console.log(factorial(-1)); // Logs: undefined

// Example 9: Using Function Expressions - Function to filter odd numbers from an array
const filterOdds = function(numbers) {
    return numbers.filter(num => num % 2 === 0);
};
console.log(filterOdds([1, 2, 3, 4, 5])); // Logs: [2, 4]

// Example 10: Documenting Functions - Function to reverse a string
/**
 * Reverses a given string.
 * @param {string} str - The string to be reversed.
 * @returns {string} - The reversed string.
 */
function reverseString(str) {
    return str.split('').reverse().join('');
}
console.log(reverseString("hello")); // Logs: "olleh"
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td id="scope" class="tableletters">Scope</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-blocks', event)">
              blocks
            </td>
          </tr>
          <tr id="detail-tag-blocks" class="expandable-row-content">
            <td>
              <h3>blocks</h3>
              <p>Blocks in JavaScript are fundamental structures used to group statements together, enclosed within curly braces `{}`. They are typically used in control flow statements such as `if`, `for`, `while`, and `switch`, as well as in defining the bodies of functions. Blocks create a new scope for variables declared with `let` and `const`, meaning these variables are confined to the block and cannot be accessed outside of it, thus preventing potential conflicts and unintended behavior in the broader program. This scoping behavior, known as block-level scoping, is a key feature introduced in ES6 that enhances the management and predictability of variables within code. Blocks also play a crucial role in the organization and readability of code, allowing developers to structure and nest operations logically and hierarchically. They ensure that related statements are executed together, maintaining the integrity of the logic and control flow within the program. Understanding and utilizing blocks effectively is essential for writing clean, efficient, and maintainable JavaScript code.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Block in an if statement
if (true) {
    let message = "This is inside the block";
    console.log(message); // Logs: "This is inside the block"
}
// console.log(message); // Uncaught ReferenceError: message is not defined

// Example 2: Block in a for loop
for (let i = 0; i < 3; i++) {
    let message = `Iteration ${i}`;
    console.log(message); // Logs: "Iteration 0", "Iteration 1", "Iteration 2"
}
// console.log(i); // Uncaught ReferenceError: i is not defined

// Example 3: Block in a while loop
let count = 0;
while (count < 3) {
    let message = `Count is ${count}`;
    console.log(message); // Logs: "Count is 0", "Count is 1", "Count is 2"
    count++;
}

// Example 4: Block in a function
function greet(name) {
    {
        let message = `Hello, ${name}!`;
        console.log(message); // Logs: "Hello, [name]!"
    }
    // console.log(message); // Uncaught ReferenceError: message is not defined
}
greet("Alice"); // Logs: "Hello, Alice!"

// Example 5: Block in a switch statement
let fruit = "apple";
switch (fruit) {
    case "apple": {
        let message = "This is an apple";
        console.log(message); // Logs: "This is an apple"
        break;
    }
    case "banana": {
        let message = "This is a banana";
        console.log(message);
        break;
    }
    default: {
        let message = "Unknown fruit";
        console.log(message);
    }
}
// console.log(message); // Uncaught ReferenceError: message is not defined
          
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-global', event)">
              global scope and global variables
            </td>
          </tr>
          <tr id="detail-tag-global" class="expandable-row-content">
            <td>
              <h3>global scope and global variables</h3>
              <p>In JavaScript, the global scope is the outermost scope in the execution context, where global variables reside. Global variables are those declared outside of any function or block, making them accessible from any part of the code. When a variable is defined in the global scope, it becomes a property of the global object, which is `window` in browsers and `global` in Node.js. While global variables can be convenient for sharing data across different parts of a program, they come with significant risks, such as potential naming conflicts and unintended side effects. Because global variables can be modified from anywhere in the code, they can lead to bugs that are difficult to trace and debug. Furthermore, excessive use of global variables can reduce the modularity and maintainability of the code. Best practices suggest minimizing the use of global variables and, instead, encapsulating variables within functions or blocks to limit their scope and improve the reliability of the code. Understanding and managing the global scope is crucial for writing efficient and error-free JavaScript applications.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Declaring a global variable
let globalVar = "I am a global variable";
function showGlobalVar() {
    console.log(globalVar); // Logs: "I am a global variable"
}
showGlobalVar();

// Example 2: Modifying a global variable within a function
let globalCounter = 0;
function incrementCounter() {
    globalCounter++;
}
incrementCounter();
console.log(globalCounter); // Logs: 1

// Example 3: Accessing a global variable inside a block
const globalMessage = "Hello, world!";
{
    console.log(globalMessage); // Logs: "Hello, world!"
}

// Example 4: Declaring a global variable with let
let globalLetVar = "I am a global let variable";
function showGlobalLetVar() {
    console.log(globalLetVar); // Logs: "I am a global let variable"
}
showGlobalLetVar();

// Example 5: Creating a global variable without let or const (not recommended)
function createGlobalVar() {
    window.accidentalGlobalVar = "I am an accidental global variable";
}
createGlobalVar();
console.log(window.accidentalGlobalVar); // Logs: "I am an accidental global variable"

// Example 6: Using a global variable in multiple functions
let sharedVar = "Shared variable";
function firstFunction() {
    console.log(sharedVar); // Logs: "Shared variable"
}
function secondFunction() {
    sharedVar = "Modified shared variable";
    console.log(sharedVar); // Logs: "Modified shared variable"
}
firstFunction();
secondFunction();
console.log(sharedVar); // Logs: "Modified shared variable"

// Example 7: Potential conflict with global variables
let name = "Alice";
function setName() {
    name = "Bob"; // Modifies the global variable
}
setName();
console.log(name); // Logs: "Bob"
          
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-block', event)">
              block scope and local variables
            </td>
          </tr>
          <tr id="detail-tag-block" class="expandable-row-content">
            <td>
              <h3>block scope and local variables</h3>
              <p>Block scope in JavaScript refers to the visibility and accessibility of variables declared within a specific block of code, which is defined by curly braces `{}`. Variables declared with `let` and `const` inside a block are confined to that block and cannot be accessed outside of it. This scoping behavior contrasts with variables declared using `var`, which are function-scoped and can be accessed outside the block they are defined in, provided they are within the same function. Block scope enhances code maintainability and readability by preventing variables from leaking into the outer scope, reducing the likelihood of naming conflicts and unintended interactions. This feature is particularly useful in control flow statements like `if`, `for`, and `while`, as well as in function definitions, where you want to limit the variable's lifespan and accessibility to a specific section of code. By using block-scoped variables, developers can write more predictable and error-free code, as it is clear where each variable is accessible and where it is not.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Block scope with let in an if statement
if (true) {
    let message = "This is inside the block";
    console.log(message); // Logs: "This is inside the block"
}
// console.log(message); // Uncaught ReferenceError: message is not defined

// Example 2: Block scope with const in a for loop
for (let i = 0; i < 3; i++) {
    const message = `Iteration ${i}`;
    console.log(message); // Logs: "Iteration 0", "Iteration 1", "Iteration 2"
}
// console.log(i); // Uncaught ReferenceError: i is not defined

// Example 3: Block scope with let in a while loop
let count = 0;
while (count < 3) {
    let message = `Count is ${count}`;
    console.log(message); // Logs: "Count is 0", "Count is 1", "Count is 2"
    count++;
}
// console.log(message); // Uncaught ReferenceError: message is not defined

// Example 4: Block scope with const in a function
function greet(name) {
    {
        const message = `Hello, ${name}!`;
        console.log(message); // Logs: "Hello, Alice!"
    }
    // console.log(message); // Uncaught ReferenceError: message is not defined
}
greet("Alice");

// Example 5: Block scope with let in a switch statement
let fruit = "apple";
switch (fruit) {
    case "apple": {
        let message = "This is an apple";
        console.log(message); // Logs: "This is an apple"
        break;
    }
    case "banana": {
        let message = "This is a banana";
        console.log(message);
        break;
    }
    default: {
        let message = "Unknown fruit";
        console.log(message);
    }
}
// console.log(message); // Uncaught ReferenceError: message is not defined

// Example 6: Block scope with const in nested blocks
{
    const outerMessage = "Outer block";
    {
        const innerMessage = "Inner block";
        console.log(outerMessage); // Logs: "Outer block"
        console.log(innerMessage); // Logs: "Inner block"
    }
    // console.log(innerMessage); // Uncaught ReferenceError: innerMessage is not defined
}
// console.log(outerMessage); // Uncaught ReferenceError: outerMessage is not defined

// Example 7: Block scope with let in a try-catch block
try {
    let message = "Trying something";
    console.log(message); // Logs: "Trying something"
} catch (error) {
    let errorMessage = "An error occurred";
    console.log(errorMessage); // Only logs if an error occurs
}
// console.log(message); // Uncaught ReferenceError: message is not defined
// console.log(errorMessage); // Uncaught ReferenceError: errorMessage is not defined
          
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-scopep', event)">
              scope pollution
            </td>
          </tr>
          <tr id="detail-tag-scopep" class="expandable-row-content">
            <td>
              <h3>scope pollution</h3>
              <p>Scope pollution, often referred to as namespace pollution, in JavaScript occurs when too many variables, functions, or objects are declared in the global scope, leading to potential conflicts and maintainability issues. This happens when variables are unnecessarily declared globally rather than locally within functions or blocks, making them accessible from any part of the program. Such global declarations can cause name collisions, where multiple variables with the same name overwrite each other's values, resulting in unpredictable behavior and hard-to-debug errors. Namespace pollution makes the codebase more difficult to read and maintain because it becomes challenging to track the origin and usage of each variable. Additionally, it increases the risk of inadvertently affecting other parts of the code, leading to unintended side effects. To mitigate scope pollution, it is essential to declare variables within the narrowest possible scope, such as inside functions or blocks, and use `let` and `const` instead of `var` to leverage block scoping. Encapsulating code within functions, modules, or immediately invoked function expressions (IIFEs) can further help manage variable scope effectively, ensuring that variables do not leak into the global scope and reducing the risk of scope pollution.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Global variable affecting functions
let globalVar = "I am global";

function showGlobalVar() {
    console.log(globalVar); // Logs: "I am global"
}

function changeGlobalVar() {
    globalVar = "I am changed globally";
}

showGlobalVar(); // Logs: "I am global"
changeGlobalVar();
showGlobalVar(); // Logs: "I am changed globally"

// Example 2: Overwriting global variable
let counter = 1;

function incrementCounter() {
    counter++;
}

function resetCounter() {
    counter = 0; // This affects the global counter
}

console.log(counter); // Logs: 1
incrementCounter();
console.log(counter); // Logs: 2
resetCounter();
console.log(counter); // Logs: 0

// Example 3: Function variable leaking to global scope
function createGlobalVariable() {
    leakedVar = "I am leaked"; // No let or const, becomes global
}

createGlobalVariable();
console.log(leakedVar); // Logs: "I am leaked"

// Example 4: Global variable name collision
let name = "Alice";

function setName() {
    name = "Bob"; // Overwrites the global variable
}

console.log(name); // Logs: "Alice"
setName();
console.log(name); // Logs: "Bob"

// Example 5: Using var in loops causing scope pollution
for (var i = 0; i < 5; i++) {
    // i is declared globally due to var
    console.log(i); // Logs: 0, 1, 2, 3, 4
}
console.log(i); // Logs: 5, i is accessible outside the loop
          
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-bpscope', event)">
              best practices
            </td>
          </tr>
          <tr id="detail-tag-bpscope" class="expandable-row-content">
            <td>
              <h3>best practices</h3>
              <p>Best practices regarding scope in JavaScript emphasize the importance of minimizing the use of global variables to prevent scope pollution and potential conflicts. Variables should be declared within the narrowest possible scope, such as inside functions or blocks, to limit their visibility and impact. Using `let` and `const` instead of `var` is recommended, as they provide block-level scoping, reducing the likelihood of unintended variable leakage and overwriting. Encapsulating code within functions, modules, or immediately invoked function expressions (IIFEs) can further isolate variables and functions, ensuring they do not interfere with other parts of the program. Consistently using descriptive and unique variable names helps avoid naming collisions and makes the code more readable and maintainable. Additionally, understanding and leveraging closures can help manage scope effectively, allowing functions to access variables from their containing scope in a controlled manner. By adhering to these practices, developers can write more robust, maintainable, and error-free JavaScript code.</p>
              <br />
            </td>
          </tr>
          <tr>
            <td id="arrays" class="tableletters">Arrays</td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-arrayover', event)">
              syntax & purpose
            </td>
          </tr>
          <tr id="detail-tag-arrayover" class="expandable-row-content">
            <td>
              <h3>syntax & purpose</h3>
              <p>In JavaScript, arrays are a powerful data structure used to store multiple values in a single variable, allowing developers to manage collections of data efficiently. The syntax for creating an array involves using square brackets `[]`, with elements separated by commas. For instance, an array of numbers can be created with the syntax `let numbers = [1, 2, 3, 4, 5];`. Arrays in JavaScript can contain elements of various data types, such as numbers, strings, objects, or even other arrays, which makes them extremely flexible. To create an array, you can use the array literal notation, as shown above, or the `Array` constructor, like `let fruits = new Array('apple', 'banana', 'cherry');`. However, using the array literal notation is generally preferred for its simplicity and readability. Elements within an array are accessed via their index, starting from 0, meaning `numbers[0]` would access the first element of the `numbers` array. JavaScript arrays come with numerous built-in methods to facilitate manipulation, such as `push()` to add elements, `pop()` to remove the last element, and `shift()` and `unshift()` to add or remove elements from the beginning. Arrays are essential for tasks involving data organization, iteration, and implementing complex data structures like stacks and queues. This makes arrays a fundamental part of JavaScript programming, allowing developers to handle data collections effectively.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Creating an array using array literal notation
let fruits = ['apple', 'banana', 'cherry'];

// Example 2: Creating an array using the Array constructor
let numbers = new Array(1, 2, 3, 4, 5);

// Example 3: Accessing elements in an array by index
console.log(fruits[0]); // Output: 'apple'

// Example 4: Modifying an element in an array
fruits[1] = 'blueberry';
console.log(fruits); // Output: ['apple', 'blueberry', 'cherry']

// Example 5: Adding elements to the end of an array using push()
fruits.push('orange');
console.log(fruits); // Output: ['apple', 'blueberry', 'cherry', 'orange']

// Example 6: Removing the last element of an array using pop()
let lastFruit = fruits.pop();
console.log(lastFruit); // Output: 'orange'
console.log(fruits); // Output: ['apple', 'blueberry', 'cherry']

// Example 7: Adding elements to the beginning of an array using unshift()
fruits.unshift('kiwi');
console.log(fruits); // Output: ['kiwi', 'apple', 'blueberry', 'cherry']  
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-literal', event)">
              literal notation
            </td>
          </tr>
          <tr id="detail-tag-literal" class="expandable-row-content">
            <td>
              <h3>literal notation</h3>
              <p>The literal notation of JavaScript arrays is a straightforward and efficient way to create arrays by directly specifying the elements within square brackets, separated by commas. This method is concise and widely used due to its simplicity and readability, allowing developers to initialize arrays without needing to invoke a constructor. For example, an array of fruits can be created with the syntax `let fruits = ['apple', 'banana', 'cherry'];`, where each string represents an element within the array. This notation supports elements of various data types, including numbers, strings, objects, and even nested arrays, which can all be mixed within a single array. The flexibility of array literal notation makes it a popular choice for defining arrays quickly, especially when the initial content is known. Accessing elements is done using zero-based indexing, allowing developers to easily retrieve, modify, or iterate over the data. Literal notation also supports empty arrays, represented by simply using empty brackets `[]`, which can be filled with elements dynamically as needed. This approach not only enhances code readability but also improves maintainability by presenting a clear structure of the array's contents at a glance. Overall, array literal notation is an essential feature in JavaScript that simplifies the process of working with collections of data.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Creating an array of numbers
let numbers = [1, 2, 3, 4, 5];
console.log(numbers); // Output: [1, 2, 3, 4, 5]

// Example 2: Creating an array of strings
let fruits = ['apple', 'banana', 'cherry'];
console.log(fruits); // Output: ['apple', 'banana', 'cherry']

// Example 3: Creating an array with mixed data types
let mixedArray = [42, 'hello', true, null];
console.log(mixedArray); // Output: [42, 'hello', true, null]

// Example 4: Creating an array with nested arrays
let nestedArray = [[1, 2], [3, 4], [5, 6]];
console.log(nestedArray); // Output: [[1, 2], [3, 4], [5, 6]]

// Example 5: Creating an array of objects
let users = [{name: 'Alice', age: 30}, {name: 'Bob', age: 25}];
console.log(users); // Output: [{name: 'Alice', age: 30}, {name: 'Bob', age: 25}]

// Example 6: Creating an empty array
let emptyArray = [];
console.log(emptyArray); // Output: []

// Example 7: Using literal notation to create a sparse array
let sparseArray = [1, , 3]; // The second element is missing, creating a hole
console.log(sparseArray);
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-constructor', event)">
              constructor notation
            </td>
          </tr>
          <tr id="detail-tag-constructor" class="expandable-row-content">
            <td>
              <h3>constructor notation</h3>
              <p>The constructor notation of JavaScript arrays involves using the `Array` constructor to create a new array instance, providing more explicit control over the array's creation process. This method uses the `new Array()` syntax, where you can optionally pass arguments to specify the elements or the length of the array. For example, `let numbers = new Array(5);` creates an array with a length of five, filled with empty slots, while `let fruits = new Array('apple', 'banana', 'cherry');` initializes an array with the specified elements. The constructor notation is particularly useful when creating arrays with a predetermined size or when you need to create an array without initializing it with specific elements immediately. However, this method can sometimes lead to confusion, especially when a single numerical argument is passed to the constructor, as it is interpreted as the array's length rather than a single element. Despite this potential pitfall, using the `Array` constructor provides a more explicit way to define arrays, allowing for flexibility in certain programming scenarios, especially when handling array-like objects or creating arrays dynamically. Overall, while the literal notation is often preferred for its simplicity, the constructor notation remains a valuable tool in a JavaScript developer's arsenal, offering an alternative method for creating and managing arrays.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Creating an empty array with a specific length
let emptyArray = new Array(5);
console.log(emptyArray); // Output: [undefined, undefined, undefined, undefined, undefined]

// Example 2: Creating an array with initial elements
let fruits = new Array('apple', 'banana', 'cherry');
console.log(fruits); // Output: ['apple', 'banana', 'cherry']

// Example 3: Creating an array with a single numeric element
let singleNumber = new Array(7);
console.log(singleNumber); // Output: [undefined, undefined, undefined, undefined, undefined, undefined, undefined]

// Example 4: Creating an array with a single string element
let singleString = new Array('hello');
console.log(singleString); // Output: ['hello']

// Example 5: Creating an array with mixed data types
let mixedArray = new Array(42, 'hello', true, null);
console.log(mixedArray); // Output: [42, 'hello', true, null]

// Example 6: Creating a two-dimensional array
let matrix = new Array(
  new Array(1, 2, 3),
  new Array(4, 5, 6),
  new Array(7, 8, 9)
);
console.log(matrix); // Output: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

// Example 7: Creating an array using the Array.of method (alternative to constructor)
let arrayOf = Array.of(10, 20, 30);
console.log(arrayOf); // Output: [10, 20, 30]
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-indexing', event)">
              zero-based indexing
            </td>
          </tr>
          <tr id="detail-tag-indexing" class="expandable-row-content">
            <td>
              <h3>zero-based indexing</h3>
              <p>In JavaScript, arrays are indexed collections of elements, where each element is accessed by a numerical index that starts at zero. This means the first element in an array is at index 0, the second element at index 1, and so on, which is known as zero-based indexing. This indexing system allows developers to iterate over arrays efficiently and perform operations on specific elements by referencing their positions. The index serves as a key to access the corresponding value within the array, enabling quick data retrieval and manipulation. For example, given an array `let colors = ['red', 'green', 'blue'];`, accessing the first element is done using `colors[0]`, which would return `'red'`. JavaScript also allows negative indexing using methods like `Array.prototype.at()`, where `colors.at(-1)` returns the last element of the array. Additionally, arrays in JavaScript can be sparse, meaning they can have empty slots without defined values if elements are omitted during initialization or removed later. This feature can lead to indices that do not have associated values, which can be handled carefully during iterations and data manipulations. Overall, understanding and utilizing array indexing in JavaScript is crucial for effectively managing and manipulating collections of data in various programming scenarios.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Accessing the first element using zero-based index
let colors = ['red', 'green', 'blue'];
console.log(colors[0]); // Output: 'red'

// Example 2: Accessing the last element using length property
console.log(colors[colors.length - 1]); // Output: 'blue'

// Example 3: Accessing an element in a nested array
let matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
console.log(matrix[1][1]); // Output: 5 (second row, second column)

// Example 4: Modifying an element at a specific index
colors[1] = 'yellow';
console.log(colors); // Output: ['red', 'yellow', 'blue']

// Example 5: Adding a new element at a specific index
colors[3] = 'purple';
console.log(colors); // Output: ['red', 'yellow', 'blue', 'purple']

// Example 6: Accessing an index that doesn't exist (returns undefined)
console.log(colors[10]); // Output: undefined

// Example 7: Iterating over an array using index
for (let i = 0; i < colors.length; i++) {
  console.log(colors[i]); // Output: 'red', 'yellow', 'blue', 'purple'
}

// Example 8: Using negative indexing with Array.prototype.at()
console.log(colors.at(-1)); // Output: 'purple'

// Example 9: Finding the index of an element using indexOf
let index = colors.indexOf('blue');
console.log(index); // Output: 2

// Example 10: Using the index to remove an element
let removedElement = colors.splice(1, 1); // Removes 'yellow'
console.log(colors); // Output: ['red', 'blue', 'purple']
console.log(removedElement); // Output: ['yellow']
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-access', event)">
              accessing & updating elements
            </td>
          </tr>
          <tr id="detail-tag-access" class="expandable-row-content">
            <td>
              <h3>accessing & updating elements</h3>
              <p>In JavaScript, accessing and updating arrays is a fundamental operation that allows developers to manipulate data collections effectively. Arrays use zero-based indexing, which means each element can be accessed by its numerical index, starting from 0 for the first element. For example, given an array `let fruits = ['apple', 'banana', 'cherry'];`, you can access the second element by using `fruits[1]`, which would return `'banana'`. To update an element at a specific index, you simply assign a new value to that index, such as `fruits[1] = 'orange';`, which changes the second element to `'orange'`. This direct access and modification capability make arrays very versatile for a wide range of tasks, including data processing and manipulation. In addition to numeric indices, JavaScript provides various methods for accessing and updating arrays, such as `push()` to add elements to the end, `pop()` to remove the last element, and `splice()` to insert or remove elements at specific positions. By leveraging these array methods, developers can efficiently perform complex operations, such as sorting, filtering, and transforming data, making arrays an essential part of JavaScript programming.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Accessing the first element of an array
let numbers = [10, 20, 30, 40, 50];
console.log(numbers[0]); // Output: 10

// Example 2: Accessing the last element of an array using the length property
console.log(numbers[numbers.length - 1]); // Output: 50

// Example 3: Updating the first element of an array
numbers[0] = 100;
console.log(numbers); // Output: [100, 20, 30, 40, 50]

// Example 4: Updating the last element of an array
numbers[numbers.length - 1] = 500;
console.log(numbers); // Output: [100, 20, 30, 40, 500]

// Example 5: Accessing a middle element of an array
console.log(numbers[2]); // Output: 30

// Example 6: Updating a middle element of an array
numbers[2] = 300;
console.log(numbers); // Output: [100, 20, 300, 40, 500]

// Example 7: Adding a new element at the end of an array
numbers[numbers.length] = 60;
console.log(numbers); // Output: [100, 20, 300, 40, 500, 60]

// Example 8: Adding a new element at a specific index
numbers[6] = 70;
console.log(numbers); // Output: [100, 20, 300, 40, 500, 60, 70]

// Example 9: Accessing an element using a negative index (manually calculated)
console.log(numbers[numbers.length - 2]); // Output: 60

// Example 10: Accessing elements in a loop (read-only)
for (let i = 0; i < numbers.length; i++) {
  console.log(numbers[i]); // Output: 100, 20, 300, 40, 500, 60, 70
}

// Example 11: Updating all elements in a loop
for (let i = 0; i < numbers.length; i++) {
  numbers[i] *= 2; // Doubling each element
}
console.log(numbers); // Output: [200, 40, 600, 80, 1000, 120, 140]

// Example 12: Resetting an entire array
numbers = [1, 2, 3, 4, 5];
console.log(numbers); // Output: [1, 2, 3, 4, 5]
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-arrayvar', event)">
              let & const for arrays
            </td>
          </tr>
          <tr id="detail-tag-arrayvar" class="expandable-row-content">
            <td>
              <h3>let & const for arrays</h3>
              <p>In JavaScript, the use of `let` and `const` for arrays involves specific considerations related to variable scope and mutability. Both `let` and `const` are block-scoped, meaning they are accessible only within the block where they are declared, unlike `var`, which is function-scoped. When using `let` to declare an array, you can reassign the entire array to a new array later, allowing for flexibility in scenarios where the reference to the array itself may need to change. In contrast, `const` is used to declare arrays when you want to ensure that the reference to the array remains constant and cannot be reassigned. However, it is important to note that `const` does not make the array immutable; the contents of the array can still be modified, meaning you can add, remove, or change elements within the array. This distinction is crucial because it highlights that `const` only prevents reassignment of the variable itself, not the modification of the array's content. This behavior makes `const` ideal for situations where the array structure is intended to remain consistent throughout the code's execution, thereby reducing the risk of accidental reassignment and enhancing code reliability and clarity.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Declaring an array with let and modifying an element
let numbers = [1, 2, 3];
numbers[0] = 10; // Modifying the first element
console.log(numbers); // Output: [10, 2, 3]

// Example 2: Reassigning an array declared with let
numbers = [4, 5, 6]; // Reassigning to a new array
console.log(numbers); // Output: [4, 5, 6]

// Example 3: Declaring an array with const and modifying an element
const fruits = ['apple', 'banana', 'cherry'];
fruits[1] = 'orange'; // Modifying the second element
console.log(fruits); // Output: ['apple', 'orange', 'cherry']

// Example 4: Attempting to reassign a const array (will throw an error)
try {
    fruits = ['kiwi', 'mango']; // Attempting to reassign the entire array
} catch (error) {
    console.log(error.message); // Output: Assignment to constant variable.
}

// Example 5: Adding an element to a let array
let animals = ['dog', 'cat'];
animals[2] = 'rabbit'; // Adding a new element at index 2
console.log(animals); // Output: ['dog', 'cat', 'rabbit']

// Example 6: Adding an element to a const array
const cities = ['New York', 'Los Angeles'];
cities[2] = 'Chicago'; // Adding a new element at index 2
console.log(cities); // Output: ['New York', 'Los Angeles', 'Chicago']

// Example 7: Removing an element from a let array
let colors = ['red', 'green', 'blue'];
colors[2] = undefined; // Removing the element at index 2
console.log(colors); // Output: ['red', 'green', undefined]

// Example 8: Removing an element from a const array
const shapes = ['circle', 'square', 'triangle'];
shapes[2] = null; // Removing the element at index 2 (set to null for clarity)
console.log(shapes); // Output: ['circle', 'square', null]

// Example 9: Let allows for reassignment, replacing the array entirely
let scores = [10, 20, 30];
scores = [100, 200]; // Replacing with a new array
console.log(scores); // Output: [100, 200]

// Example 10: Const does not allow for reassignment of the entire array
const points = [5, 10, 15];
try {
    points = [50, 100]; // Attempting to reassign will throw an error
} catch (error) {
    console.log(error.message); // Output: Assignment to constant variable.
}
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-length', event)">
              .length property
            </td>
          </tr>
          <tr id="detail-tag-length" class="expandable-row-content">
            <td>
              <h3>.length property</h3>
              <p>The `.length` property in JavaScript arrays is a built-in property that returns or sets the number of elements in an array. It provides a simple way to determine the size of an array, which is particularly useful for iterating over elements, performing operations based on the array's size, or dynamically managing data collections. The value of `.length` is always one greater than the highest index in the array because arrays in JavaScript are zero-based. Interestingly, the `.length` property is mutable, meaning it can be set explicitly to change the size of the array. For example, setting `.length` to a smaller value than the current length truncates the array, removing elements from the end, while setting it to a larger value than the current length adds undefined elements to the array, effectively expanding it. This ability to adjust the length makes the `.length` property a powerful tool for managing arrays efficiently. However, it's important to note that while `.length` provides a count of elements, it does not account for any undefined or empty slots in sparse arrays, which can lead to situations where the reported length doesn't correspond to the number of initialized elements. Overall, the `.length` property is a fundamental feature in JavaScript that plays a critical role in array manipulation and management.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Accessing the length of an array
let fruits = ['apple', 'banana', 'cherry'];
console.log(fruits.length); // Output: 3

// Example 2: Using length to iterate over an array
let colors = ['red', 'green', 'blue', 'yellow'];
for (let i = 0; i < colors.length; i++) {
  console.log(colors[i]); // Output: 'red', 'green', 'blue', 'yellow'
}

// Example 3: Truncating an array by setting a smaller length
let animals = ['dog', 'cat', 'rabbit', 'elephant'];
animals.length = 2; // Truncate to the first two elements
console.log(animals); // Output: ['dog', 'cat']

// Example 4: Extending an array by setting a larger length
let numbers = [1, 2, 3];
numbers.length = 5; // Extend with undefined elements
console.log(numbers); // Output: [1, 2, 3, <2 empty items>]

// Example 5: Adding an element at the end using length
let cities = ['New York', 'Los Angeles'];
cities[cities.length] = 'Chicago'; // Add element at the next available index
console.log(cities); // Output: ['New York', 'Los Angeles', 'Chicago']

// Example 6: Removing the last element using length
let sports = ['soccer', 'basketball', 'tennis'];
sports.length = sports.length - 1; // Remove the last element
console.log(sports); // Output: ['soccer', 'basketball']

// Example 7: Creating an empty array by setting length to zero
let flowers = ['rose', 'tulip', 'daisy'];
flowers.length = 0; // Clear the entire array
console.log(flowers); // Output: []

// Example 8: Using length to find the index of the last element
let cars = ['Toyota', 'Honda', 'Ford', 'BMW'];
let lastIndex = cars.length - 1; // Calculate the index of the last element
console.log(cars[lastIndex]); // Output: 'BMW'
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-push', event)">
              .push() method
            </td>
          </tr>
          <tr id="detail-tag-push" class="expandable-row-content">
            <td>
              <h3>.push() method</h3>
              <p>The `.push()` method in JavaScript arrays is a built-in function used to add one or more elements to the end of an array, thereby increasing its length. This method modifies the original array in place and returns the new length of the array after the elements have been added. It is a versatile and commonly used method, especially when working with dynamic data where new elements need to be appended regularly. The `.push()` method can accept multiple arguments, allowing developers to add several elements simultaneously without needing multiple calls. For example, if you have an array `let fruits = ['apple', 'banana']`, using `fruits.push('cherry', 'orange')` will result in `['apple', 'banana', 'cherry', 'orange']`. This makes `.push()` an efficient way to expand an array when dealing with tasks such as collecting user inputs, handling data from external sources, or accumulating results within loops. Furthermore, because it operates on the existing array, `.push()` helps maintain memory efficiency, as it does not create a new array instance. Overall, the `.push()` method is a fundamental part of JavaScript's array manipulation capabilities, enabling developers to manage collections of data with ease and flexibility.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Adding a single element to an array
let fruits = ['apple', 'banana'];
fruits.push('cherry');
console.log(fruits); // Output: ['apple', 'banana', 'cherry']

// Example 2: Adding multiple elements to an array
let colors = ['red', 'green'];
colors.push('blue', 'yellow');
console.log(colors); // Output: ['red', 'green', 'blue', 'yellow']

// Example 3: Using push() to add an element to an empty array
let numbers = [];
numbers.push(1);
console.log(numbers); // Output: [1]

// Example 4: Adding elements of different data types
let mixedArray = ['text', 42];
mixedArray.push(true, null);
console.log(mixedArray); // Output: ['text', 42, true, null]

// Example 5: Adding an array to another array as a single element
let array1 = [1, 2];
let array2 = [3, 4];
array1.push(array2);
console.log(array1); // Output: [1, 2, [3, 4]]

// Example 6: Pushing elements from a function
function addElement(arr, element) {
  arr.push(element);
}

let animals = ['dog', 'cat'];
addElement(animals, 'rabbit');
console.log(animals); // Output: ['dog', 'cat', 'rabbit']

// Example 7: Using push() to build a list from user input
let userInputs = [];
userInputs.push('John');
userInputs.push('Doe');
console.log(userInputs); // Output: ['John', 'Doe']

// Example 8: Using push() to track actions
let actions = [];
actions.push('login');
actions.push('view_page');
console.log(actions); // Output: ['login', 'view_page']

// Example 9: Dynamically adding data to an array
let dataLog = [];
dataLog.push({ timestamp: '2024-01-01', value: 100 });
dataLog.push({ timestamp: '2024-01-02', value: 200 });
console.log(dataLog); 
// Output: [{ timestamp: '2024-01-01', value: 100 }, { timestamp: '2024-01-02', value: 200 }]

// Example 10: Returning the new length of the array after push
let books = ['1984', 'Brave New World'];
let newLength = books.push('Fahrenheit 451');
console.log(books); // Output: ['1984', 'Brave New World', 'Fahrenheit 451']
console.log(newLength); // Output: 3
            </code></pre>
              <br/>
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-pop', event)">
              .pop() method
            </td>
          </tr>
          <tr id="detail-tag-pop" class="expandable-row-content">
            <td>
              <h3>.pop() method</h3>
              <p>The `.pop()` method in JavaScript arrays is a built-in function that removes the last element from an array, decreasing its length by one, and returns the removed element. This method modifies the original array directly and is particularly useful for operations where you need to retrieve and simultaneously remove the most recent addition to an array, following the Last-In-First-Out (LIFO) principle often used in stack data structures. For example, if you have an array `let fruits = ['apple', 'banana', 'cherry']`, calling `fruits.pop()` will remove `'cherry'` from the array, leaving `['apple', 'banana']`, and return the value `'cherry'`. This behavior makes `.pop()` an essential tool for tasks that require managing collections of data in a sequential manner, such as undo operations, backtracking algorithms, or buffer management. It's important to note that if the array is empty, calling `.pop()` will return `undefined` without throwing an error, providing a safe way to attempt removal without needing explicit checks for emptiness. Additionally, because `.pop()` only affects the last element of the array, it maintains the efficiency of the operation, allowing for quick retrieval and deletion without needing to re-index the entire array. As such, the `.pop()` method is a fundamental and frequently used part of JavaScript's array manipulation toolkit, offering a simple yet powerful way to manage and manipulate data collections.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Removing the last element from an array
let fruits = ['apple', 'banana', 'cherry'];
let lastFruit = fruits.pop();
console.log(fruits); // Output: ['apple', 'banana']
console.log(lastFruit); // Output: 'cherry'

// Example 2: Using pop() on an empty array
let emptyArray = [];
let poppedElement = emptyArray.pop();
console.log(emptyArray); // Output: []
console.log(poppedElement); // Output: undefined

// Example 3: Removing the last element from a single-element array
let singleElementArray = ['onlyElement'];
let removedElement = singleElementArray.pop();
console.log(singleElementArray); // Output: []
console.log(removedElement); // Output: 'onlyElement'

// Example 4: Using pop() to manage a stack of tasks
let tasks = ['task1', 'task2', 'task3'];
let lastTask = tasks.pop();
console.log(tasks); // Output: ['task1', 'task2']
console.log(lastTask); // Output: 'task3'

// Example 5: Chaining pop() with other array methods
let colors = ['red', 'green', 'blue'];
let removedColor = colors.sort().pop(); // Sorts and then removes the last element
console.log(colors); // Output: ['green', 'red']
console.log(removedColor); // Output: 'blue'

// Example 6: Using pop() to process and remove elements
let numbers = [10, 20, 30, 40];
while (numbers.length > 0) {
  console.log(numbers.pop()); // Output: 40, 30, 20, 10 (one by one)
}
console.log(numbers); // Output: []

// Example 7: Removing elements until a condition is met
let scores = [85, 90, 78, 92];
while (scores.pop() < 90) {
  console.log("Removed a score below 90");
}
console.log(scores); // Output: [85, 90]

// Example 8: Using pop() to manage a history of actions
let history = ['start', 'login', 'view'];
let lastAction = history.pop();
console.log(history); // Output: ['start', 'login']
console.log(lastAction); // Output: 'view'

// Example 9: Using pop() to implement undo functionality
let commands = ['draw', 'erase', 'fill'];
let undoCommand = commands.pop();
console.log(commands); // Output: ['draw', 'erase']
console.log(`Undo action: ${undoCommand}`); // Output: 'Undo action: fill'

// Example 10: Using pop() with nested arrays
let nestedArrays = [[1, 2], [3, 4], [5, 6]];
let lastNestedArray = nestedArrays.pop();
console.log(nestedArrays); // Output: [[1, 2], [3, 4]]
console.log(lastNestedArray); // Output: [5, 6]
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-join', event)">
              .join() method
            </td>
          </tr>
          <tr id="detail-tag-join" class="expandable-row-content">
            <td>
              <h3>.join() method</h3>
              <p>The `.join()` method in JavaScript arrays is a built-in function that creates and returns a new string by concatenating all the elements of an array, separated by a specified delimiter. This method does not modify the original array; instead, it provides a way to represent array contents as a string. By default, if no delimiter is specified, the elements are separated by commas. For example, if you have an array `let fruits = ['apple', 'banana', 'cherry']`, calling `fruits.join()` will result in the string `"apple,banana,cherry"`. However, you can specify a different delimiter, such as `fruits.join(' - ')`, which would produce the string `"apple - banana - cherry"`. The `.join()` method is particularly useful for generating formatted strings from array data, such as creating CSV (Comma Separated Values) strings, constructing paths, or displaying list items in a readable format. Additionally, when used on an array containing elements that are not strings, `.join()` implicitly converts them to strings before concatenation, ensuring that any type of array can be effectively joined into a single string representation. This makes the `.join()` method a versatile and valuable tool in JavaScript for transforming and presenting array data in a clean and customizable string format.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Joining elements of an array with a comma (default separator)
let fruits = ['apple', 'banana', 'cherry'];
let fruitsString = fruits.join();
console.log(fruitsString); // Output: 'apple,banana,cherry'

// Example 2: Joining elements with a custom separator
let colors = ['red', 'green', 'blue'];
let colorString = colors.join(' - ');
console.log(colorString); // Output: 'red - green - blue'

// Example 3: Joining elements without any separator
let letters = ['a', 'b', 'c'];
let letterString = letters.join('');
console.log(letterString); // Output: 'abc'

// Example 4: Joining elements of an array with a space
let words = ['Hello', 'world'];
let sentence = words.join(' ');
console.log(sentence); // Output: 'Hello world'

// Example 5: Joining numbers with a colon as a separator
let numbers = [1, 2, 3, 4, 5];
let numberString = numbers.join(':');
console.log(numberString); // Output: '1:2:3:4:5'

// Example 6: Joining elements of a mixed array
let mixedArray = ['apple', 42, true, null];
let mixedString = mixedArray.join(', ');
console.log(mixedString); // Output: 'apple, 42, true, null'

// Example 7: Creating a CSV string from an array of data
let data = ['Name', 'Age', 'Country'];
let csv = data.join(',');
console.log(csv); // Output: 'Name,Age,Country'

// Example 8: Joining nested arrays into a single string
let nestedArray = [[1, 2], [3, 4], [5, 6]];
let flatString = nestedArray.map(arr => arr.join('-')).join('; ');
console.log(flatString); // Output: '1-2; 3-4; 5-6'

// Example 9: Handling empty slots in sparse arrays
let sparseArray = [1, , 3, , 5];
let sparseString = sparseArray.join('-');
console.log(sparseString); // Output: '1--3--5'

// Example 10: Joining an array of objects using a property
let users = [{name: 'Alice'}, {name: 'Bob'}, {name: 'Charlie'}];
let names = users.map(user => user.name).join(', ');
console.log(names); // Output: 'Alice, Bob, Charlie'
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-shift', event)">
              .shift() method
            </td>
          </tr>
          <tr id="detail-tag-shift" class="expandable-row-content">
            <td>
              <h3>.shift() method</h3>
              <p>The `.shift()` method in JavaScript arrays is a built-in function that removes the first element from an array and returns that removed element, effectively decreasing the array's length by one. This method directly modifies the original array, making it particularly useful for scenarios where the first element needs to be extracted and processed, such as in First-In-First-Out (FIFO) data structures like queues. For instance, if you have an array `let queue = ['task1', 'task2', 'task3']`, invoking `queue.shift()` will remove `'task1'` from the array, resulting in `['task2', 'task3']`, and return the value `'task1'`. The `.shift()` method is advantageous in applications that require sequential processing of elements, such as handling tasks in order, managing buffers, or processing data streams. Unlike the `.pop()` method, which removes elements from the end of an array, `.shift()` operates on the first element, which can be less efficient for large arrays as it requires re-indexing of the remaining elements. If the array is empty, calling `.shift()` will return `undefined` without throwing an error, offering a safe way to attempt removal without pre-checking the array's size. Overall, the `.shift()` method is an essential tool in JavaScript for managing arrays where order and sequence of elements are crucial, enabling developers to efficiently manipulate data collections by removing elements from the front.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Removing the first element from an array
let fruits = ['apple', 'banana', 'cherry'];
let firstFruit = fruits.shift();
console.log(fruits); // Output: ['banana', 'cherry']
console.log(firstFruit); // Output: 'apple'

// Example 2: Using shift() on an empty array
let emptyArray = [];
let shiftedElement = emptyArray.shift();
console.log(emptyArray); // Output: []
console.log(shiftedElement); // Output: undefined

// Example 3: Removing the first element from a single-element array
let singleElementArray = ['onlyElement'];
let removedElement = singleElementArray.shift();
console.log(singleElementArray); // Output: []
console.log(removedElement); // Output: 'onlyElement'

// Example 4: Using shift() to manage a queue of tasks
let tasks = ['task1', 'task2', 'task3'];
let firstTask = tasks.shift();
console.log(tasks); // Output: ['task2', 'task3']
console.log(firstTask); // Output: 'task1'

// Example 5: Chaining shift() with other array methods
let colors = ['red', 'green', 'blue'];
let removedColor = colors.reverse().shift(); // Reverses and then removes the first element
console.log(colors); // Output: ['blue', 'green']
console.log(removedColor); // Output: 'red'

// Example 6: Using shift() to process and remove elements
let numbers = [10, 20, 30, 40];
while (numbers.length > 0) {
  console.log(numbers.shift()); // Output: 10, 20, 30, 40 (one by one)
}
console.log(numbers); // Output: []

// Example 7: Removing elements until a condition is met
let scores = [85, 90, 78, 92];
while (scores[0] < 90) {
  console.log("Removed a score below 90:", scores.shift());
}
console.log(scores); // Output: [90, 78, 92]

// Example 8: Using shift() to manage a history of actions
let history = ['start', 'login', 'view'];
let firstAction = history.shift();
console.log(history); // Output: ['login', 'view']
console.log(firstAction); // Output: 'start'

// Example 9: Using shift() to implement a "first-come, first-served" system
let customers = ['Alice', 'Bob', 'Charlie'];
let servedCustomer = customers.shift();
console.log(customers); // Output: ['Bob', 'Charlie']
console.log(`Served customer: ${servedCustomer}`); // Output: 'Served customer: Alice'

// Example 10: Using shift() with nested arrays
let nestedArrays = [[1, 2], [3, 4], [5, 6]];
let firstNestedArray = nestedArrays.shift();
console.log(nestedArrays); // Output: [[3, 4], [5, 6]]
console.log(firstNestedArray); // Output: [1, 2]
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-ainf', event)">
              scope of arrays in functions
            </td>
          </tr>
          <tr id="detail-tag-ainf" class="expandable-row-content">
            <td>
              <h3>scope of arrays in functions</h3>
              <p>In JavaScript, the scope of arrays within functions is governed by the principles of variable scope and how they are declared. Arrays declared inside a function using `var` are function-scoped, meaning they are accessible only within that function and are not available outside of it. If arrays are declared with `let` or `const` inside a function, they are block-scoped, which means they are confined to the block they are declared in, but within the same function, they act similarly to `var` regarding overall function scope. This encapsulation ensures that the array cannot be accessed or modified outside of its intended context, preventing potential conflicts and unintended side effects in larger codebases. When arrays are declared outside of functions and then accessed within, they fall under the category of global scope, unless a function redefines them with a local declaration. Passing arrays as arguments into functions does not alter their scope; the function simply receives a reference to the original array. This reference allows the function to modify the array's content, reflecting changes in the global or parent scope unless reassigned locally within the function. Thus, understanding how arrays interact with function scope is crucial for effective data manipulation and avoiding common pitfalls related to variable scope, such as accidental overwrites or unintended global state mutations.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Function-scoped array with var
function arrayWithVar() {
    var fruits = ['apple', 'banana', 'cherry'];
    console.log(fruits); // Output: ['apple', 'banana', 'cherry']
}
arrayWithVar();
// console.log(fruits); // ReferenceError: fruits is not defined

// Example 2: Block-scoped array with let
function arrayWithLet() {
    if (true) {
        let vegetables = ['carrot', 'broccoli', 'lettuce'];
        console.log(vegetables); // Output: ['carrot', 'broccoli', 'lettuce']
    }
    // console.log(vegetables); // ReferenceError: vegetables is not defined
}
arrayWithLet();

// Example 3: Block-scoped array with const
function arrayWithConst() {
    const animals = ['dog', 'cat', 'rabbit'];
    console.log(animals); // Output: ['dog', 'cat', 'rabbit']
    if (true) {
        const birds = ['sparrow', 'eagle'];
        console.log(birds); // Output: ['sparrow', 'eagle']
    }
    // console.log(birds); // ReferenceError: birds is not defined
}
arrayWithConst();

// Example 4: Global array accessed in a function
let colors = ['red', 'green', 'blue'];
function modifyColors() {
    colors.push('yellow');
    console.log(colors); // Output: ['red', 'green', 'blue', 'yellow']
}
modifyColors();
console.log(colors); // Output: ['red', 'green', 'blue', 'yellow']

// Example 5: Local array shadows global array
let numbers = [1, 2, 3];
function shadowGlobalArray() {
    let numbers = [4, 5, 6];
    console.log(numbers); // Output: [4, 5, 6]
}
shadowGlobalArray();
console.log(numbers); // Output: [1, 2, 3]

// Example 6: Modifying a global array inside a function
let scores = [10, 20, 30];
function updateScores() {
    for (let i = 0; i < scores.length; i++) {
        scores[i] += 10;
    }
    console.log(scores); // Output: [20, 30, 40]
}
updateScores();
console.log(scores); // Output: [20, 30, 40]

// Example 7: Passing an array as a function argument
function addElement(arr) {
    arr.push('newElement');
    console.log(arr); // Output will depend on the passed array
}
let items = ['item1', 'item2'];
addElement(items); // Output: ['item1', 'item2', 'newElement']
console.log(items); // Output: ['item1', 'item2', 'newElement']

// Example 8: Returning an array from a function
function createArray() {
    let newArray = ['a', 'b', 'c'];
    return newArray;
}
let returnedArray = createArray();
console.log(returnedArray); // Output: ['a', 'b', 'c']
            </code></pre>
              <br />
            </td>
          </tr>
          <tr>
            <td class="clickable" onclick="toggleDetail('detail-tag-nested', event)">
              nested arrays
            </td>
          </tr>
          <tr id="detail-tag-nested" class="expandable-row-content">
            <td>
              <h3>nested arrays</h3>
              <p>Nested arrays in JavaScript, often referred to as multidimensional arrays, are arrays that contain other arrays as their elements. This structure allows developers to create complex data models, such as matrices, grids, or any hierarchical data that require multiple levels of grouping. Each element in a nested array can be accessed using a pair of indices: the first index specifies the outer array, and the second index specifies the element within the nested array. For example, in a two-dimensional array `let matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];`, `matrix[1][2]` would access the element `6`. Nested arrays provide a flexible way to handle data that is naturally organized in layers, such as a table with rows and columns. However, working with nested arrays can become complex as the number of dimensions increases, requiring careful index management to navigate through the levels. JavaScript offers various methods to manipulate nested arrays, such as `.map()`, `.reduce()`, and `.forEach()`, allowing developers to iterate and transform data effectively. Despite the complexity, nested arrays are invaluable for representing and processing structured data, making them an essential concept in JavaScript programming for handling multi-level data scenarios.</p>
              <h4><u>Specifications</u></h4>
              <pre>
           <code class="language-js">
// Example 1: Creating a simple nested array
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];
console.log(matrix); // Output: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

// Example 2: Accessing elements in a nested array
let element = matrix[1][2];
console.log(element); // Output: 6 (second row, third column)

// Example 3: Modifying an element in a nested array
matrix[2][1] = 10;
console.log(matrix); // Output: [[1, 2, 3], [4, 5, 6], [7, 10, 9]]

// Example 4: Iterating over a nested array with nested loops
for (let i = 0; i < matrix.length; i++) {
    for (let j = 0; j < matrix[i].length; j++) {
        console.log(matrix[i][j]); // Output: 1, 2, 3, 4, 5, 6, 7, 10, 9
    }
}

// Example 5: Creating a 3D array
let cube = [
    [
        [1, 2], [3, 4]
    ],
    [
        [5, 6], [7, 8]
    ]
];
console.log(cube[1][0][1]); // Output: 6 (second block, first row, second column)

// Example 6: Using nested arrays to represent a tic-tac-toe board
let ticTacToeBoard = [
    ['X', 'O', 'X'],
    ['O', 'X', 'O'],
    ['X', 'O', 'X']
];
console.log(ticTacToeBoard[0][1]); // Output: 'O' (first row, second column)

// Example 7: Flattening a nested array
let nested = [[1, 2], [3, 4], [5, 6]];
let flat = nested.reduce((acc, curr) => acc.concat(curr), []);
console.log(flat); // Output: [1, 2, 3, 4, 5, 6]

// Example 8: Nesting arrays with mixed data types
let mixedNested = [
    [1, 'a', true],
    [2, 'b', false],
    [3, 'c', true]
];
console.log(mixedNested[1][2]); // Output: false (second row, third column)

// Example 9: Adding a new row to a nested array
let newRow = [10, 11, 12];
matrix.push(newRow);
console.log(matrix); // Output: [[1, 2, 3], [4, 5, 6], [7, 10, 9], [10, 11, 12]]

// Example 10: Removing a specific element from a nested array
let removedElement = matrix[0].pop(); // Removes the last element of the first row
console.log(removedElement); // Output: 3
console.log(matrix); // Output: [[1, 2], [4, 5, 6], [7, 10, 9], [10, 11, 12]]
            </code></pre>
              <br />
            </td>
          </tr>
          
        </tbody>

        <tfoot></tfoot>
      </table>
      <br />
    </main>
    <footer>
      <small> No Rights Reserved. </small>
    </footer>
    <script src="script.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
    <script>
      function toggleDetail(detailId, event) {
    var detailRow = document.getElementById(detailId);
    var isExpanded = detailRow.style.display === "table-row";
    detailRow.style.display = isExpanded ? "none" : "table-row";

    if (isExpanded) {
      event.target.classList.remove("expanded");
    } else {
      event.target.classList.add("expanded");
    }
  }
    </script> 
    <script src="https://unpkg.com/smoothscroll-polyfill/dist/smoothscroll.min.js"></script>
    <script src="https://unpkg.com/smoothscroll-anchor-polyfill"></script>
  </body>
</html>





